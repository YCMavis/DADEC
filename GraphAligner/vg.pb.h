// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vg_2eproto;
namespace vg {
class Alignment;
struct AlignmentDefaultTypeInternal;
extern AlignmentDefaultTypeInternal _Alignment_default_instance_;
class BasePileup;
struct BasePileupDefaultTypeInternal;
extern BasePileupDefaultTypeInternal _BasePileup_default_instance_;
class Edge;
struct EdgeDefaultTypeInternal;
extern EdgeDefaultTypeInternal _Edge_default_instance_;
class EdgePileup;
struct EdgePileupDefaultTypeInternal;
extern EdgePileupDefaultTypeInternal _EdgePileup_default_instance_;
class Edit;
struct EditDefaultTypeInternal;
extern EditDefaultTypeInternal _Edit_default_instance_;
class Genotype;
struct GenotypeDefaultTypeInternal;
extern GenotypeDefaultTypeInternal _Genotype_default_instance_;
class Graph;
struct GraphDefaultTypeInternal;
extern GraphDefaultTypeInternal _Graph_default_instance_;
class KmerMatch;
struct KmerMatchDefaultTypeInternal;
extern KmerMatchDefaultTypeInternal _KmerMatch_default_instance_;
class LocationSupport;
struct LocationSupportDefaultTypeInternal;
extern LocationSupportDefaultTypeInternal _LocationSupport_default_instance_;
class Locus;
struct LocusDefaultTypeInternal;
extern LocusDefaultTypeInternal _Locus_default_instance_;
class Mapping;
struct MappingDefaultTypeInternal;
extern MappingDefaultTypeInternal _Mapping_default_instance_;
class MultipathAlignment;
struct MultipathAlignmentDefaultTypeInternal;
extern MultipathAlignmentDefaultTypeInternal _MultipathAlignment_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodePileup;
struct NodePileupDefaultTypeInternal;
extern NodePileupDefaultTypeInternal _NodePileup_default_instance_;
class Path;
struct PathDefaultTypeInternal;
extern PathDefaultTypeInternal _Path_default_instance_;
class Pileup;
struct PileupDefaultTypeInternal;
extern PileupDefaultTypeInternal _Pileup_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Snarl;
struct SnarlDefaultTypeInternal;
extern SnarlDefaultTypeInternal _Snarl_default_instance_;
class SnarlTraversal;
struct SnarlTraversalDefaultTypeInternal;
extern SnarlTraversalDefaultTypeInternal _SnarlTraversal_default_instance_;
class Subpath;
struct SubpathDefaultTypeInternal;
extern SubpathDefaultTypeInternal _Subpath_default_instance_;
class Support;
struct SupportDefaultTypeInternal;
extern SupportDefaultTypeInternal _Support_default_instance_;
class Translation;
struct TranslationDefaultTypeInternal;
extern TranslationDefaultTypeInternal _Translation_default_instance_;
class Visit;
struct VisitDefaultTypeInternal;
extern VisitDefaultTypeInternal _Visit_default_instance_;
}  // namespace vg
PROTOBUF_NAMESPACE_OPEN
template<> ::vg::Alignment* Arena::CreateMaybeMessage<::vg::Alignment>(Arena*);
template<> ::vg::BasePileup* Arena::CreateMaybeMessage<::vg::BasePileup>(Arena*);
template<> ::vg::Edge* Arena::CreateMaybeMessage<::vg::Edge>(Arena*);
template<> ::vg::EdgePileup* Arena::CreateMaybeMessage<::vg::EdgePileup>(Arena*);
template<> ::vg::Edit* Arena::CreateMaybeMessage<::vg::Edit>(Arena*);
template<> ::vg::Genotype* Arena::CreateMaybeMessage<::vg::Genotype>(Arena*);
template<> ::vg::Graph* Arena::CreateMaybeMessage<::vg::Graph>(Arena*);
template<> ::vg::KmerMatch* Arena::CreateMaybeMessage<::vg::KmerMatch>(Arena*);
template<> ::vg::LocationSupport* Arena::CreateMaybeMessage<::vg::LocationSupport>(Arena*);
template<> ::vg::Locus* Arena::CreateMaybeMessage<::vg::Locus>(Arena*);
template<> ::vg::Mapping* Arena::CreateMaybeMessage<::vg::Mapping>(Arena*);
template<> ::vg::MultipathAlignment* Arena::CreateMaybeMessage<::vg::MultipathAlignment>(Arena*);
template<> ::vg::Node* Arena::CreateMaybeMessage<::vg::Node>(Arena*);
template<> ::vg::NodePileup* Arena::CreateMaybeMessage<::vg::NodePileup>(Arena*);
template<> ::vg::Path* Arena::CreateMaybeMessage<::vg::Path>(Arena*);
template<> ::vg::Pileup* Arena::CreateMaybeMessage<::vg::Pileup>(Arena*);
template<> ::vg::Position* Arena::CreateMaybeMessage<::vg::Position>(Arena*);
template<> ::vg::Snarl* Arena::CreateMaybeMessage<::vg::Snarl>(Arena*);
template<> ::vg::SnarlTraversal* Arena::CreateMaybeMessage<::vg::SnarlTraversal>(Arena*);
template<> ::vg::Subpath* Arena::CreateMaybeMessage<::vg::Subpath>(Arena*);
template<> ::vg::Support* Arena::CreateMaybeMessage<::vg::Support>(Arena*);
template<> ::vg::Translation* Arena::CreateMaybeMessage<::vg::Translation>(Arena*);
template<> ::vg::Visit* Arena::CreateMaybeMessage<::vg::Visit>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace vg {

enum SnarlType : int {
  UNCLASSIFIED = 0,
  ULTRABUBBLE = 1,
  UNARY = 2,
  SnarlType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SnarlType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SnarlType_IsValid(int value);
constexpr SnarlType SnarlType_MIN = UNCLASSIFIED;
constexpr SnarlType SnarlType_MAX = UNARY;
constexpr int SnarlType_ARRAYSIZE = SnarlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SnarlType_descriptor();
template<typename T>
inline const std::string& SnarlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SnarlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SnarlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SnarlType_descriptor(), enum_t_value);
}
inline bool SnarlType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SnarlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SnarlType>(
    SnarlType_descriptor(), name, value);
}
// ===================================================================

class Graph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Graph) */ {
 public:
  inline Graph() : Graph(nullptr) {}
  ~Graph() override;
  explicit PROTOBUF_CONSTEXPR Graph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Graph(const Graph& from);
  Graph(Graph&& from) noexcept
    : Graph() {
    *this = ::std::move(from);
  }

  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }
  inline Graph& operator=(Graph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Graph& default_instance() {
    return *internal_default_instance();
  }
  static inline const Graph* internal_default_instance() {
    return reinterpret_cast<const Graph*>(
               &_Graph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Graph& a, Graph& b) {
    a.Swap(&b);
  }
  inline void Swap(Graph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Graph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Graph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Graph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Graph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Graph& from) {
    Graph::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Graph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Graph";
  }
  protected:
  explicit Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kEdgeFieldNumber = 2,
    kPathFieldNumber = 3,
  };
  // repeated .vg.Node node = 1;
  int node_size() const;
  private:
  int _internal_node_size() const;
  public:
  void clear_node();
  ::vg::Node* mutable_node(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Node >*
      mutable_node();
  private:
  const ::vg::Node& _internal_node(int index) const;
  ::vg::Node* _internal_add_node();
  public:
  const ::vg::Node& node(int index) const;
  ::vg::Node* add_node();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Node >&
      node() const;

  // repeated .vg.Edge edge = 2;
  int edge_size() const;
  private:
  int _internal_edge_size() const;
  public:
  void clear_edge();
  ::vg::Edge* mutable_edge(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edge >*
      mutable_edge();
  private:
  const ::vg::Edge& _internal_edge(int index) const;
  ::vg::Edge* _internal_add_edge();
  public:
  const ::vg::Edge& edge(int index) const;
  ::vg::Edge* add_edge();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edge >&
      edge() const;

  // repeated .vg.Path path = 3;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  ::vg::Path* mutable_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >*
      mutable_path();
  private:
  const ::vg::Path& _internal_path(int index) const;
  ::vg::Path* _internal_add_path();
  public:
  const ::vg::Path& path(int index) const;
  ::vg::Path* add_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >&
      path() const;

  // @@protoc_insertion_point(class_scope:vg.Graph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Node > node_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edge > edge_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path > path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
    kNameFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // string sequence = 1;
  void clear_sequence();
  const std::string& sequence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence();
  PROTOBUF_NODISCARD std::string* release_sequence();
  void set_allocated_sequence(std::string* sequence);
  private:
  const std::string& _internal_sequence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence(const std::string& value);
  std::string* _internal_mutable_sequence();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 id = 3;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Edge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Edge) */ {
 public:
  inline Edge() : Edge(nullptr) {}
  ~Edge() override;
  explicit PROTOBUF_CONSTEXPR Edge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Edge(const Edge& from);
  Edge(Edge&& from) noexcept
    : Edge() {
    *this = ::std::move(from);
  }

  inline Edge& operator=(const Edge& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edge& operator=(Edge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edge& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edge* internal_default_instance() {
    return reinterpret_cast<const Edge*>(
               &_Edge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Edge& a, Edge& b) {
    a.Swap(&b);
  }
  inline void Swap(Edge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Edge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Edge& from) {
    Edge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Edge";
  }
  protected:
  explicit Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kFromStartFieldNumber = 3,
    kToEndFieldNumber = 4,
    kOverlapFieldNumber = 5,
  };
  // int64 from = 1;
  void clear_from();
  int64_t from() const;
  void set_from(int64_t value);
  private:
  int64_t _internal_from() const;
  void _internal_set_from(int64_t value);
  public:

  // int64 to = 2;
  void clear_to();
  int64_t to() const;
  void set_to(int64_t value);
  private:
  int64_t _internal_to() const;
  void _internal_set_to(int64_t value);
  public:

  // bool from_start = 3;
  void clear_from_start();
  bool from_start() const;
  void set_from_start(bool value);
  private:
  bool _internal_from_start() const;
  void _internal_set_from_start(bool value);
  public:

  // bool to_end = 4;
  void clear_to_end();
  bool to_end() const;
  void set_to_end(bool value);
  private:
  bool _internal_to_end() const;
  void _internal_set_to_end(bool value);
  public:

  // int32 overlap = 5;
  void clear_overlap();
  int32_t overlap() const;
  void set_overlap(int32_t value);
  private:
  int32_t _internal_overlap() const;
  void _internal_set_overlap(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Edge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t from_;
    int64_t to_;
    bool from_start_;
    bool to_end_;
    int32_t overlap_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Edit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Edit) */ {
 public:
  inline Edit() : Edit(nullptr) {}
  ~Edit() override;
  explicit PROTOBUF_CONSTEXPR Edit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Edit(const Edit& from);
  Edit(Edit&& from) noexcept
    : Edit() {
    *this = ::std::move(from);
  }

  inline Edit& operator=(const Edit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Edit& operator=(Edit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Edit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Edit* internal_default_instance() {
    return reinterpret_cast<const Edit*>(
               &_Edit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Edit& a, Edit& b) {
    a.Swap(&b);
  }
  inline void Swap(Edit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Edit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Edit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Edit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Edit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Edit& from) {
    Edit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Edit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Edit";
  }
  protected:
  explicit Edit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 3,
    kFromLengthFieldNumber = 1,
    kToLengthFieldNumber = 2,
  };
  // string sequence = 3;
  void clear_sequence();
  const std::string& sequence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence();
  PROTOBUF_NODISCARD std::string* release_sequence();
  void set_allocated_sequence(std::string* sequence);
  private:
  const std::string& _internal_sequence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence(const std::string& value);
  std::string* _internal_mutable_sequence();
  public:

  // int32 from_length = 1;
  void clear_from_length();
  int32_t from_length() const;
  void set_from_length(int32_t value);
  private:
  int32_t _internal_from_length() const;
  void _internal_set_from_length(int32_t value);
  public:

  // int32 to_length = 2;
  void clear_to_length();
  int32_t to_length() const;
  void set_to_length(int32_t value);
  private:
  int32_t _internal_to_length() const;
  void _internal_set_to_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Edit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_;
    int32_t from_length_;
    int32_t to_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Mapping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Mapping) */ {
 public:
  inline Mapping() : Mapping(nullptr) {}
  ~Mapping() override;
  explicit PROTOBUF_CONSTEXPR Mapping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mapping(const Mapping& from);
  Mapping(Mapping&& from) noexcept
    : Mapping() {
    *this = ::std::move(from);
  }

  inline Mapping& operator=(const Mapping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mapping& operator=(Mapping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mapping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mapping* internal_default_instance() {
    return reinterpret_cast<const Mapping*>(
               &_Mapping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Mapping& a, Mapping& b) {
    a.Swap(&b);
  }
  inline void Swap(Mapping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mapping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mapping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mapping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mapping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Mapping& from) {
    Mapping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mapping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Mapping";
  }
  protected:
  explicit Mapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEditFieldNumber = 2,
    kPositionFieldNumber = 1,
    kRankFieldNumber = 5,
  };
  // repeated .vg.Edit edit = 2;
  int edit_size() const;
  private:
  int _internal_edit_size() const;
  public:
  void clear_edit();
  ::vg::Edit* mutable_edit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edit >*
      mutable_edit();
  private:
  const ::vg::Edit& _internal_edit(int index) const;
  ::vg::Edit* _internal_add_edit();
  public:
  const ::vg::Edit& edit(int index) const;
  ::vg::Edit* add_edit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edit >&
      edit() const;

  // .vg.Position position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::vg::Position& position() const;
  PROTOBUF_NODISCARD ::vg::Position* release_position();
  ::vg::Position* mutable_position();
  void set_allocated_position(::vg::Position* position);
  private:
  const ::vg::Position& _internal_position() const;
  ::vg::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::vg::Position* position);
  ::vg::Position* unsafe_arena_release_position();

  // int64 rank = 5;
  void clear_rank();
  int64_t rank() const;
  void set_rank(int64_t value);
  private:
  int64_t _internal_rank() const;
  void _internal_set_rank(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Mapping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edit > edit_;
    ::vg::Position* position_;
    int64_t rank_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 5,
    kNodeIdFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kIsReverseFieldNumber = 4,
  };
  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 node_id = 1;
  void clear_node_id();
  int64_t node_id() const;
  void set_node_id(int64_t value);
  private:
  int64_t _internal_node_id() const;
  void _internal_set_node_id(int64_t value);
  public:

  // int64 offset = 2;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // bool is_reverse = 4;
  void clear_is_reverse();
  bool is_reverse() const;
  void set_is_reverse(bool value);
  private:
  bool _internal_is_reverse() const;
  void _internal_set_is_reverse(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t node_id_;
    int64_t offset_;
    bool is_reverse_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Path) */ {
 public:
  inline Path() : Path(nullptr) {}
  ~Path() override;
  explicit PROTOBUF_CONSTEXPR Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Path(const Path& from);
  Path(Path&& from) noexcept
    : Path() {
    *this = ::std::move(from);
  }

  inline Path& operator=(const Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline Path& operator=(Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const Path* internal_default_instance() {
    return reinterpret_cast<const Path*>(
               &_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Path& a, Path& b) {
    a.Swap(&b);
  }
  inline void Swap(Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Path& from) {
    Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Path";
  }
  protected:
  explicit Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMappingFieldNumber = 2,
    kNameFieldNumber = 1,
    kLengthFieldNumber = 4,
    kIsCircularFieldNumber = 3,
  };
  // repeated .vg.Mapping mapping = 2;
  int mapping_size() const;
  private:
  int _internal_mapping_size() const;
  public:
  void clear_mapping();
  ::vg::Mapping* mutable_mapping(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Mapping >*
      mutable_mapping();
  private:
  const ::vg::Mapping& _internal_mapping(int index) const;
  ::vg::Mapping* _internal_add_mapping();
  public:
  const ::vg::Mapping& mapping(int index) const;
  ::vg::Mapping* add_mapping();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Mapping >&
      mapping() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 length = 4;
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // bool is_circular = 3;
  void clear_is_circular();
  bool is_circular() const;
  void set_is_circular(bool value);
  private:
  bool _internal_is_circular() const;
  void _internal_set_is_circular(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Mapping > mapping_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t length_;
    bool is_circular_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Alignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Alignment) */ {
 public:
  inline Alignment() : Alignment(nullptr) {}
  ~Alignment() override;
  explicit PROTOBUF_CONSTEXPR Alignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Alignment(const Alignment& from);
  Alignment(Alignment&& from) noexcept
    : Alignment() {
    *this = ::std::move(from);
  }

  inline Alignment& operator=(const Alignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alignment& operator=(Alignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alignment* internal_default_instance() {
    return reinterpret_cast<const Alignment*>(
               &_Alignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Alignment& a, Alignment& b) {
    a.Swap(&b);
  }
  inline void Swap(Alignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Alignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Alignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Alignment& from) {
    Alignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Alignment";
  }
  protected:
  explicit Alignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 17,
    kLocusFieldNumber = 18,
    kRefposFieldNumber = 19,
    kSecondaryScoreFieldNumber = 29,
    kSequenceFieldNumber = 1,
    kNameFieldNumber = 3,
    kQualityFieldNumber = 4,
    kSampleNameFieldNumber = 9,
    kReadGroupFieldNumber = 10,
    kFragmentLengthDistributionFieldNumber = 32,
    kPathFieldNumber = 2,
    kFragmentPrevFieldNumber = 11,
    kFragmentNextFieldNumber = 12,
    kToCorrectFieldNumber = 36,
    kAnnotationFieldNumber = 100,
    kMappingQualityFieldNumber = 5,
    kScoreFieldNumber = 6,
    kIdentityFieldNumber = 16,
    kQueryPositionFieldNumber = 7,
    kIsSecondaryFieldNumber = 15,
    kReadPairedFieldNumber = 20,
    kReadMappedFieldNumber = 21,
    kMateUnmappedFieldNumber = 22,
    kUniquenessFieldNumber = 27,
    kCorrectFieldNumber = 28,
    kReadOnReverseStrandFieldNumber = 23,
    kMateOnReverseStrandFieldNumber = 24,
    kSoftClippedFieldNumber = 25,
    kDiscordantInsertSizeFieldNumber = 26,
    kMateMappedToDisjointSubgraphFieldNumber = 31,
    kHaplotypeScoredFieldNumber = 33,
    kCorrectlyMappedFieldNumber = 37,
    kFragmentScoreFieldNumber = 30,
    kHaplotypeLogprobFieldNumber = 34,
    kTimeUsedFieldNumber = 35,
  };
  // repeated .vg.Path fragment = 17;
  int fragment_size() const;
  private:
  int _internal_fragment_size() const;
  public:
  void clear_fragment();
  ::vg::Path* mutable_fragment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >*
      mutable_fragment();
  private:
  const ::vg::Path& _internal_fragment(int index) const;
  ::vg::Path* _internal_add_fragment();
  public:
  const ::vg::Path& fragment(int index) const;
  ::vg::Path* add_fragment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >&
      fragment() const;

  // repeated .vg.Locus locus = 18;
  int locus_size() const;
  private:
  int _internal_locus_size() const;
  public:
  void clear_locus();
  ::vg::Locus* mutable_locus(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Locus >*
      mutable_locus();
  private:
  const ::vg::Locus& _internal_locus(int index) const;
  ::vg::Locus* _internal_add_locus();
  public:
  const ::vg::Locus& locus(int index) const;
  ::vg::Locus* add_locus();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Locus >&
      locus() const;

  // repeated .vg.Position refpos = 19;
  int refpos_size() const;
  private:
  int _internal_refpos_size() const;
  public:
  void clear_refpos();
  ::vg::Position* mutable_refpos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Position >*
      mutable_refpos();
  private:
  const ::vg::Position& _internal_refpos(int index) const;
  ::vg::Position* _internal_add_refpos();
  public:
  const ::vg::Position& refpos(int index) const;
  ::vg::Position* add_refpos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Position >&
      refpos() const;

  // repeated int32 secondary_score = 29;
  int secondary_score_size() const;
  private:
  int _internal_secondary_score_size() const;
  public:
  void clear_secondary_score();
  private:
  int32_t _internal_secondary_score(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_secondary_score() const;
  void _internal_add_secondary_score(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_secondary_score();
  public:
  int32_t secondary_score(int index) const;
  void set_secondary_score(int index, int32_t value);
  void add_secondary_score(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      secondary_score() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_secondary_score();

  // string sequence = 1;
  void clear_sequence();
  const std::string& sequence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence();
  PROTOBUF_NODISCARD std::string* release_sequence();
  void set_allocated_sequence(std::string* sequence);
  private:
  const std::string& _internal_sequence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence(const std::string& value);
  std::string* _internal_mutable_sequence();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes quality = 4;
  void clear_quality();
  const std::string& quality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quality();
  PROTOBUF_NODISCARD std::string* release_quality();
  void set_allocated_quality(std::string* quality);
  private:
  const std::string& _internal_quality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quality(const std::string& value);
  std::string* _internal_mutable_quality();
  public:

  // string sample_name = 9;
  void clear_sample_name();
  const std::string& sample_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sample_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sample_name();
  PROTOBUF_NODISCARD std::string* release_sample_name();
  void set_allocated_sample_name(std::string* sample_name);
  private:
  const std::string& _internal_sample_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sample_name(const std::string& value);
  std::string* _internal_mutable_sample_name();
  public:

  // string read_group = 10;
  void clear_read_group();
  const std::string& read_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_group();
  PROTOBUF_NODISCARD std::string* release_read_group();
  void set_allocated_read_group(std::string* read_group);
  private:
  const std::string& _internal_read_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_group(const std::string& value);
  std::string* _internal_mutable_read_group();
  public:

  // string fragment_length_distribution = 32;
  void clear_fragment_length_distribution();
  const std::string& fragment_length_distribution() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fragment_length_distribution(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fragment_length_distribution();
  PROTOBUF_NODISCARD std::string* release_fragment_length_distribution();
  void set_allocated_fragment_length_distribution(std::string* fragment_length_distribution);
  private:
  const std::string& _internal_fragment_length_distribution() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_length_distribution(const std::string& value);
  std::string* _internal_mutable_fragment_length_distribution();
  public:

  // .vg.Path path = 2;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::vg::Path& path() const;
  PROTOBUF_NODISCARD ::vg::Path* release_path();
  ::vg::Path* mutable_path();
  void set_allocated_path(::vg::Path* path);
  private:
  const ::vg::Path& _internal_path() const;
  ::vg::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::vg::Path* path);
  ::vg::Path* unsafe_arena_release_path();

  // .vg.Alignment fragment_prev = 11;
  bool has_fragment_prev() const;
  private:
  bool _internal_has_fragment_prev() const;
  public:
  void clear_fragment_prev();
  const ::vg::Alignment& fragment_prev() const;
  PROTOBUF_NODISCARD ::vg::Alignment* release_fragment_prev();
  ::vg::Alignment* mutable_fragment_prev();
  void set_allocated_fragment_prev(::vg::Alignment* fragment_prev);
  private:
  const ::vg::Alignment& _internal_fragment_prev() const;
  ::vg::Alignment* _internal_mutable_fragment_prev();
  public:
  void unsafe_arena_set_allocated_fragment_prev(
      ::vg::Alignment* fragment_prev);
  ::vg::Alignment* unsafe_arena_release_fragment_prev();

  // .vg.Alignment fragment_next = 12;
  bool has_fragment_next() const;
  private:
  bool _internal_has_fragment_next() const;
  public:
  void clear_fragment_next();
  const ::vg::Alignment& fragment_next() const;
  PROTOBUF_NODISCARD ::vg::Alignment* release_fragment_next();
  ::vg::Alignment* mutable_fragment_next();
  void set_allocated_fragment_next(::vg::Alignment* fragment_next);
  private:
  const ::vg::Alignment& _internal_fragment_next() const;
  ::vg::Alignment* _internal_mutable_fragment_next();
  public:
  void unsafe_arena_set_allocated_fragment_next(
      ::vg::Alignment* fragment_next);
  ::vg::Alignment* unsafe_arena_release_fragment_next();

  // .vg.Position to_correct = 36;
  bool has_to_correct() const;
  private:
  bool _internal_has_to_correct() const;
  public:
  void clear_to_correct();
  const ::vg::Position& to_correct() const;
  PROTOBUF_NODISCARD ::vg::Position* release_to_correct();
  ::vg::Position* mutable_to_correct();
  void set_allocated_to_correct(::vg::Position* to_correct);
  private:
  const ::vg::Position& _internal_to_correct() const;
  ::vg::Position* _internal_mutable_to_correct();
  public:
  void unsafe_arena_set_allocated_to_correct(
      ::vg::Position* to_correct);
  ::vg::Position* unsafe_arena_release_to_correct();

  // .google.protobuf.Struct annotation = 100;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::PROTOBUF_NAMESPACE_ID::Struct& annotation() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_annotation();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_annotation();
  void set_allocated_annotation(::PROTOBUF_NAMESPACE_ID::Struct* annotation);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_annotation() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::PROTOBUF_NAMESPACE_ID::Struct* annotation);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_annotation();

  // int32 mapping_quality = 5;
  void clear_mapping_quality();
  int32_t mapping_quality() const;
  void set_mapping_quality(int32_t value);
  private:
  int32_t _internal_mapping_quality() const;
  void _internal_set_mapping_quality(int32_t value);
  public:

  // int32 score = 6;
  void clear_score();
  int32_t score() const;
  void set_score(int32_t value);
  private:
  int32_t _internal_score() const;
  void _internal_set_score(int32_t value);
  public:

  // double identity = 16;
  void clear_identity();
  double identity() const;
  void set_identity(double value);
  private:
  double _internal_identity() const;
  void _internal_set_identity(double value);
  public:

  // int32 query_position = 7;
  void clear_query_position();
  int32_t query_position() const;
  void set_query_position(int32_t value);
  private:
  int32_t _internal_query_position() const;
  void _internal_set_query_position(int32_t value);
  public:

  // bool is_secondary = 15;
  void clear_is_secondary();
  bool is_secondary() const;
  void set_is_secondary(bool value);
  private:
  bool _internal_is_secondary() const;
  void _internal_set_is_secondary(bool value);
  public:

  // bool read_paired = 20;
  void clear_read_paired();
  bool read_paired() const;
  void set_read_paired(bool value);
  private:
  bool _internal_read_paired() const;
  void _internal_set_read_paired(bool value);
  public:

  // bool read_mapped = 21;
  void clear_read_mapped();
  bool read_mapped() const;
  void set_read_mapped(bool value);
  private:
  bool _internal_read_mapped() const;
  void _internal_set_read_mapped(bool value);
  public:

  // bool mate_unmapped = 22;
  void clear_mate_unmapped();
  bool mate_unmapped() const;
  void set_mate_unmapped(bool value);
  private:
  bool _internal_mate_unmapped() const;
  void _internal_set_mate_unmapped(bool value);
  public:

  // double uniqueness = 27;
  void clear_uniqueness();
  double uniqueness() const;
  void set_uniqueness(double value);
  private:
  double _internal_uniqueness() const;
  void _internal_set_uniqueness(double value);
  public:

  // double correct = 28;
  void clear_correct();
  double correct() const;
  void set_correct(double value);
  private:
  double _internal_correct() const;
  void _internal_set_correct(double value);
  public:

  // bool read_on_reverse_strand = 23;
  void clear_read_on_reverse_strand();
  bool read_on_reverse_strand() const;
  void set_read_on_reverse_strand(bool value);
  private:
  bool _internal_read_on_reverse_strand() const;
  void _internal_set_read_on_reverse_strand(bool value);
  public:

  // bool mate_on_reverse_strand = 24;
  void clear_mate_on_reverse_strand();
  bool mate_on_reverse_strand() const;
  void set_mate_on_reverse_strand(bool value);
  private:
  bool _internal_mate_on_reverse_strand() const;
  void _internal_set_mate_on_reverse_strand(bool value);
  public:

  // bool soft_clipped = 25;
  void clear_soft_clipped();
  bool soft_clipped() const;
  void set_soft_clipped(bool value);
  private:
  bool _internal_soft_clipped() const;
  void _internal_set_soft_clipped(bool value);
  public:

  // bool discordant_insert_size = 26;
  void clear_discordant_insert_size();
  bool discordant_insert_size() const;
  void set_discordant_insert_size(bool value);
  private:
  bool _internal_discordant_insert_size() const;
  void _internal_set_discordant_insert_size(bool value);
  public:

  // bool mate_mapped_to_disjoint_subgraph = 31;
  void clear_mate_mapped_to_disjoint_subgraph();
  bool mate_mapped_to_disjoint_subgraph() const;
  void set_mate_mapped_to_disjoint_subgraph(bool value);
  private:
  bool _internal_mate_mapped_to_disjoint_subgraph() const;
  void _internal_set_mate_mapped_to_disjoint_subgraph(bool value);
  public:

  // bool haplotype_scored = 33;
  void clear_haplotype_scored();
  bool haplotype_scored() const;
  void set_haplotype_scored(bool value);
  private:
  bool _internal_haplotype_scored() const;
  void _internal_set_haplotype_scored(bool value);
  public:

  // bool correctly_mapped = 37;
  void clear_correctly_mapped();
  bool correctly_mapped() const;
  void set_correctly_mapped(bool value);
  private:
  bool _internal_correctly_mapped() const;
  void _internal_set_correctly_mapped(bool value);
  public:

  // double fragment_score = 30;
  void clear_fragment_score();
  double fragment_score() const;
  void set_fragment_score(double value);
  private:
  double _internal_fragment_score() const;
  void _internal_set_fragment_score(double value);
  public:

  // double haplotype_logprob = 34;
  void clear_haplotype_logprob();
  double haplotype_logprob() const;
  void set_haplotype_logprob(double value);
  private:
  double _internal_haplotype_logprob() const;
  void _internal_set_haplotype_logprob(double value);
  public:

  // double time_used = 35;
  void clear_time_used();
  double time_used() const;
  void set_time_used(double value);
  private:
  double _internal_time_used() const;
  void _internal_set_time_used(double value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Alignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path > fragment_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Locus > locus_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Position > refpos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > secondary_score_;
    mutable std::atomic<int> _secondary_score_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quality_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sample_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_length_distribution_;
    ::vg::Path* path_;
    ::vg::Alignment* fragment_prev_;
    ::vg::Alignment* fragment_next_;
    ::vg::Position* to_correct_;
    ::PROTOBUF_NAMESPACE_ID::Struct* annotation_;
    int32_t mapping_quality_;
    int32_t score_;
    double identity_;
    int32_t query_position_;
    bool is_secondary_;
    bool read_paired_;
    bool read_mapped_;
    bool mate_unmapped_;
    double uniqueness_;
    double correct_;
    bool read_on_reverse_strand_;
    bool mate_on_reverse_strand_;
    bool soft_clipped_;
    bool discordant_insert_size_;
    bool mate_mapped_to_disjoint_subgraph_;
    bool haplotype_scored_;
    bool correctly_mapped_;
    double fragment_score_;
    double haplotype_logprob_;
    double time_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class MultipathAlignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.MultipathAlignment) */ {
 public:
  inline MultipathAlignment() : MultipathAlignment(nullptr) {}
  ~MultipathAlignment() override;
  explicit PROTOBUF_CONSTEXPR MultipathAlignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultipathAlignment(const MultipathAlignment& from);
  MultipathAlignment(MultipathAlignment&& from) noexcept
    : MultipathAlignment() {
    *this = ::std::move(from);
  }

  inline MultipathAlignment& operator=(const MultipathAlignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultipathAlignment& operator=(MultipathAlignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultipathAlignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultipathAlignment* internal_default_instance() {
    return reinterpret_cast<const MultipathAlignment*>(
               &_MultipathAlignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MultipathAlignment& a, MultipathAlignment& b) {
    a.Swap(&b);
  }
  inline void Swap(MultipathAlignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultipathAlignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultipathAlignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultipathAlignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultipathAlignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultipathAlignment& from) {
    MultipathAlignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultipathAlignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.MultipathAlignment";
  }
  protected:
  explicit MultipathAlignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubpathFieldNumber = 6,
    kStartFieldNumber = 8,
    kSequenceFieldNumber = 1,
    kQualityFieldNumber = 2,
    kNameFieldNumber = 3,
    kSampleNameFieldNumber = 4,
    kReadGroupFieldNumber = 5,
    kPairedReadNameFieldNumber = 9,
    kAnnotationFieldNumber = 100,
    kMappingQualityFieldNumber = 7,
  };
  // repeated .vg.Subpath subpath = 6;
  int subpath_size() const;
  private:
  int _internal_subpath_size() const;
  public:
  void clear_subpath();
  ::vg::Subpath* mutable_subpath(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Subpath >*
      mutable_subpath();
  private:
  const ::vg::Subpath& _internal_subpath(int index) const;
  ::vg::Subpath* _internal_add_subpath();
  public:
  const ::vg::Subpath& subpath(int index) const;
  ::vg::Subpath* add_subpath();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Subpath >&
      subpath() const;

  // repeated uint32 start = 8;
  int start_size() const;
  private:
  int _internal_start_size() const;
  public:
  void clear_start();
  private:
  uint32_t _internal_start(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_start() const;
  void _internal_add_start(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_start();
  public:
  uint32_t start(int index) const;
  void set_start(int index, uint32_t value);
  void add_start(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      start() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_start();

  // string sequence = 1;
  void clear_sequence();
  const std::string& sequence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence();
  PROTOBUF_NODISCARD std::string* release_sequence();
  void set_allocated_sequence(std::string* sequence);
  private:
  const std::string& _internal_sequence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence(const std::string& value);
  std::string* _internal_mutable_sequence();
  public:

  // bytes quality = 2;
  void clear_quality();
  const std::string& quality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quality();
  PROTOBUF_NODISCARD std::string* release_quality();
  void set_allocated_quality(std::string* quality);
  private:
  const std::string& _internal_quality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quality(const std::string& value);
  std::string* _internal_mutable_quality();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string sample_name = 4;
  void clear_sample_name();
  const std::string& sample_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sample_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sample_name();
  PROTOBUF_NODISCARD std::string* release_sample_name();
  void set_allocated_sample_name(std::string* sample_name);
  private:
  const std::string& _internal_sample_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sample_name(const std::string& value);
  std::string* _internal_mutable_sample_name();
  public:

  // string read_group = 5;
  void clear_read_group();
  const std::string& read_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_read_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_read_group();
  PROTOBUF_NODISCARD std::string* release_read_group();
  void set_allocated_read_group(std::string* read_group);
  private:
  const std::string& _internal_read_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_read_group(const std::string& value);
  std::string* _internal_mutable_read_group();
  public:

  // string paired_read_name = 9;
  void clear_paired_read_name();
  const std::string& paired_read_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_paired_read_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_paired_read_name();
  PROTOBUF_NODISCARD std::string* release_paired_read_name();
  void set_allocated_paired_read_name(std::string* paired_read_name);
  private:
  const std::string& _internal_paired_read_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_paired_read_name(const std::string& value);
  std::string* _internal_mutable_paired_read_name();
  public:

  // .google.protobuf.Struct annotation = 100;
  bool has_annotation() const;
  private:
  bool _internal_has_annotation() const;
  public:
  void clear_annotation();
  const ::PROTOBUF_NAMESPACE_ID::Struct& annotation() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_annotation();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_annotation();
  void set_allocated_annotation(::PROTOBUF_NAMESPACE_ID::Struct* annotation);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_annotation() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_annotation();
  public:
  void unsafe_arena_set_allocated_annotation(
      ::PROTOBUF_NAMESPACE_ID::Struct* annotation);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_annotation();

  // int32 mapping_quality = 7;
  void clear_mapping_quality();
  int32_t mapping_quality() const;
  void set_mapping_quality(int32_t value);
  private:
  int32_t _internal_mapping_quality() const;
  void _internal_set_mapping_quality(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.MultipathAlignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Subpath > subpath_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > start_;
    mutable std::atomic<int> _start_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quality_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sample_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr read_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr paired_read_name_;
    ::PROTOBUF_NAMESPACE_ID::Struct* annotation_;
    int32_t mapping_quality_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Subpath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Subpath) */ {
 public:
  inline Subpath() : Subpath(nullptr) {}
  ~Subpath() override;
  explicit PROTOBUF_CONSTEXPR Subpath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Subpath(const Subpath& from);
  Subpath(Subpath&& from) noexcept
    : Subpath() {
    *this = ::std::move(from);
  }

  inline Subpath& operator=(const Subpath& from) {
    CopyFrom(from);
    return *this;
  }
  inline Subpath& operator=(Subpath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Subpath& default_instance() {
    return *internal_default_instance();
  }
  static inline const Subpath* internal_default_instance() {
    return reinterpret_cast<const Subpath*>(
               &_Subpath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Subpath& a, Subpath& b) {
    a.Swap(&b);
  }
  inline void Swap(Subpath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Subpath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Subpath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Subpath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Subpath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Subpath& from) {
    Subpath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Subpath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Subpath";
  }
  protected:
  explicit Subpath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextFieldNumber = 2,
    kPathFieldNumber = 1,
    kScoreFieldNumber = 3,
  };
  // repeated uint32 next = 2;
  int next_size() const;
  private:
  int _internal_next_size() const;
  public:
  void clear_next();
  private:
  uint32_t _internal_next(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_next() const;
  void _internal_add_next(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_next();
  public:
  uint32_t next(int index) const;
  void set_next(int index, uint32_t value);
  void add_next(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      next() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_next();

  // .vg.Path path = 1;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::vg::Path& path() const;
  PROTOBUF_NODISCARD ::vg::Path* release_path();
  ::vg::Path* mutable_path();
  void set_allocated_path(::vg::Path* path);
  private:
  const ::vg::Path& _internal_path() const;
  ::vg::Path* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::vg::Path* path);
  ::vg::Path* unsafe_arena_release_path();

  // int32 score = 3;
  void clear_score();
  int32_t score() const;
  void set_score(int32_t value);
  private:
  int32_t _internal_score() const;
  void _internal_set_score(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Subpath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > next_;
    mutable std::atomic<int> _next_cached_byte_size_;
    ::vg::Path* path_;
    int32_t score_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class KmerMatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.KmerMatch) */ {
 public:
  inline KmerMatch() : KmerMatch(nullptr) {}
  ~KmerMatch() override;
  explicit PROTOBUF_CONSTEXPR KmerMatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KmerMatch(const KmerMatch& from);
  KmerMatch(KmerMatch&& from) noexcept
    : KmerMatch() {
    *this = ::std::move(from);
  }

  inline KmerMatch& operator=(const KmerMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline KmerMatch& operator=(KmerMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KmerMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const KmerMatch* internal_default_instance() {
    return reinterpret_cast<const KmerMatch*>(
               &_KmerMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(KmerMatch& a, KmerMatch& b) {
    a.Swap(&b);
  }
  inline void Swap(KmerMatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KmerMatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KmerMatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KmerMatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KmerMatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KmerMatch& from) {
    KmerMatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KmerMatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.KmerMatch";
  }
  protected:
  explicit KmerMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
    kNodeIdFieldNumber = 2,
    kPositionFieldNumber = 3,
    kBackwardFieldNumber = 4,
  };
  // string sequence = 1;
  void clear_sequence();
  const std::string& sequence() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sequence(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sequence();
  PROTOBUF_NODISCARD std::string* release_sequence();
  void set_allocated_sequence(std::string* sequence);
  private:
  const std::string& _internal_sequence() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sequence(const std::string& value);
  std::string* _internal_mutable_sequence();
  public:

  // int64 node_id = 2;
  void clear_node_id();
  int64_t node_id() const;
  void set_node_id(int64_t value);
  private:
  int64_t _internal_node_id() const;
  void _internal_set_node_id(int64_t value);
  public:

  // sint32 position = 3;
  void clear_position();
  int32_t position() const;
  void set_position(int32_t value);
  private:
  int32_t _internal_position() const;
  void _internal_set_position(int32_t value);
  public:

  // bool backward = 4;
  void clear_backward();
  bool backward() const;
  void set_backward(bool value);
  private:
  bool _internal_backward() const;
  void _internal_set_backward(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vg.KmerMatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sequence_;
    int64_t node_id_;
    int32_t position_;
    bool backward_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class BasePileup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.BasePileup) */ {
 public:
  inline BasePileup() : BasePileup(nullptr) {}
  ~BasePileup() override;
  explicit PROTOBUF_CONSTEXPR BasePileup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasePileup(const BasePileup& from);
  BasePileup(BasePileup&& from) noexcept
    : BasePileup() {
    *this = ::std::move(from);
  }

  inline BasePileup& operator=(const BasePileup& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasePileup& operator=(BasePileup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasePileup& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasePileup* internal_default_instance() {
    return reinterpret_cast<const BasePileup*>(
               &_BasePileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BasePileup& a, BasePileup& b) {
    a.Swap(&b);
  }
  inline void Swap(BasePileup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasePileup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasePileup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasePileup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasePileup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BasePileup& from) {
    BasePileup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasePileup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.BasePileup";
  }
  protected:
  explicit BasePileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasesFieldNumber = 3,
    kQualitiesFieldNumber = 4,
    kRefBaseFieldNumber = 1,
    kNumBasesFieldNumber = 2,
  };
  // string bases = 3;
  void clear_bases();
  const std::string& bases() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bases(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bases();
  PROTOBUF_NODISCARD std::string* release_bases();
  void set_allocated_bases(std::string* bases);
  private:
  const std::string& _internal_bases() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bases(const std::string& value);
  std::string* _internal_mutable_bases();
  public:

  // bytes qualities = 4;
  void clear_qualities();
  const std::string& qualities() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_qualities(ArgT0&& arg0, ArgT... args);
  std::string* mutable_qualities();
  PROTOBUF_NODISCARD std::string* release_qualities();
  void set_allocated_qualities(std::string* qualities);
  private:
  const std::string& _internal_qualities() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qualities(const std::string& value);
  std::string* _internal_mutable_qualities();
  public:

  // int32 ref_base = 1;
  void clear_ref_base();
  int32_t ref_base() const;
  void set_ref_base(int32_t value);
  private:
  int32_t _internal_ref_base() const;
  void _internal_set_ref_base(int32_t value);
  public:

  // int32 num_bases = 2;
  void clear_num_bases();
  int32_t num_bases() const;
  void set_num_bases(int32_t value);
  private:
  int32_t _internal_num_bases() const;
  void _internal_set_num_bases(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.BasePileup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bases_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qualities_;
    int32_t ref_base_;
    int32_t num_bases_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class NodePileup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.NodePileup) */ {
 public:
  inline NodePileup() : NodePileup(nullptr) {}
  ~NodePileup() override;
  explicit PROTOBUF_CONSTEXPR NodePileup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodePileup(const NodePileup& from);
  NodePileup(NodePileup&& from) noexcept
    : NodePileup() {
    *this = ::std::move(from);
  }

  inline NodePileup& operator=(const NodePileup& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodePileup& operator=(NodePileup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodePileup& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodePileup* internal_default_instance() {
    return reinterpret_cast<const NodePileup*>(
               &_NodePileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NodePileup& a, NodePileup& b) {
    a.Swap(&b);
  }
  inline void Swap(NodePileup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodePileup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodePileup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodePileup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodePileup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodePileup& from) {
    NodePileup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodePileup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.NodePileup";
  }
  protected:
  explicit NodePileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBasePileupFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // repeated .vg.BasePileup base_pileup = 2;
  int base_pileup_size() const;
  private:
  int _internal_base_pileup_size() const;
  public:
  void clear_base_pileup();
  ::vg::BasePileup* mutable_base_pileup(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::BasePileup >*
      mutable_base_pileup();
  private:
  const ::vg::BasePileup& _internal_base_pileup(int index) const;
  ::vg::BasePileup* _internal_add_base_pileup();
  public:
  const ::vg::BasePileup& base_pileup(int index) const;
  ::vg::BasePileup* add_base_pileup();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::BasePileup >&
      base_pileup() const;

  // int64 node_id = 1;
  void clear_node_id();
  int64_t node_id() const;
  void set_node_id(int64_t value);
  private:
  int64_t _internal_node_id() const;
  void _internal_set_node_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.NodePileup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::BasePileup > base_pileup_;
    int64_t node_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class EdgePileup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.EdgePileup) */ {
 public:
  inline EdgePileup() : EdgePileup(nullptr) {}
  ~EdgePileup() override;
  explicit PROTOBUF_CONSTEXPR EdgePileup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgePileup(const EdgePileup& from);
  EdgePileup(EdgePileup&& from) noexcept
    : EdgePileup() {
    *this = ::std::move(from);
  }

  inline EdgePileup& operator=(const EdgePileup& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgePileup& operator=(EdgePileup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EdgePileup& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgePileup* internal_default_instance() {
    return reinterpret_cast<const EdgePileup*>(
               &_EdgePileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(EdgePileup& a, EdgePileup& b) {
    a.Swap(&b);
  }
  inline void Swap(EdgePileup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgePileup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgePileup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgePileup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EdgePileup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EdgePileup& from) {
    EdgePileup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EdgePileup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.EdgePileup";
  }
  protected:
  explicit EdgePileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualitiesFieldNumber = 4,
    kEdgeFieldNumber = 1,
    kNumReadsFieldNumber = 2,
    kNumForwardReadsFieldNumber = 3,
  };
  // bytes qualities = 4;
  void clear_qualities();
  const std::string& qualities() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_qualities(ArgT0&& arg0, ArgT... args);
  std::string* mutable_qualities();
  PROTOBUF_NODISCARD std::string* release_qualities();
  void set_allocated_qualities(std::string* qualities);
  private:
  const std::string& _internal_qualities() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qualities(const std::string& value);
  std::string* _internal_mutable_qualities();
  public:

  // .vg.Edge edge = 1;
  bool has_edge() const;
  private:
  bool _internal_has_edge() const;
  public:
  void clear_edge();
  const ::vg::Edge& edge() const;
  PROTOBUF_NODISCARD ::vg::Edge* release_edge();
  ::vg::Edge* mutable_edge();
  void set_allocated_edge(::vg::Edge* edge);
  private:
  const ::vg::Edge& _internal_edge() const;
  ::vg::Edge* _internal_mutable_edge();
  public:
  void unsafe_arena_set_allocated_edge(
      ::vg::Edge* edge);
  ::vg::Edge* unsafe_arena_release_edge();

  // int32 num_reads = 2;
  void clear_num_reads();
  int32_t num_reads() const;
  void set_num_reads(int32_t value);
  private:
  int32_t _internal_num_reads() const;
  void _internal_set_num_reads(int32_t value);
  public:

  // int32 num_forward_reads = 3;
  void clear_num_forward_reads();
  int32_t num_forward_reads() const;
  void set_num_forward_reads(int32_t value);
  private:
  int32_t _internal_num_forward_reads() const;
  void _internal_set_num_forward_reads(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:vg.EdgePileup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qualities_;
    ::vg::Edge* edge_;
    int32_t num_reads_;
    int32_t num_forward_reads_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Pileup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Pileup) */ {
 public:
  inline Pileup() : Pileup(nullptr) {}
  ~Pileup() override;
  explicit PROTOBUF_CONSTEXPR Pileup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pileup(const Pileup& from);
  Pileup(Pileup&& from) noexcept
    : Pileup() {
    *this = ::std::move(from);
  }

  inline Pileup& operator=(const Pileup& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pileup& operator=(Pileup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pileup& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pileup* internal_default_instance() {
    return reinterpret_cast<const Pileup*>(
               &_Pileup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Pileup& a, Pileup& b) {
    a.Swap(&b);
  }
  inline void Swap(Pileup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pileup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pileup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pileup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Pileup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Pileup& from) {
    Pileup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pileup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Pileup";
  }
  protected:
  explicit Pileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodePileupsFieldNumber = 1,
    kEdgePileupsFieldNumber = 2,
  };
  // repeated .vg.NodePileup node_pileups = 1;
  int node_pileups_size() const;
  private:
  int _internal_node_pileups_size() const;
  public:
  void clear_node_pileups();
  ::vg::NodePileup* mutable_node_pileups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::NodePileup >*
      mutable_node_pileups();
  private:
  const ::vg::NodePileup& _internal_node_pileups(int index) const;
  ::vg::NodePileup* _internal_add_node_pileups();
  public:
  const ::vg::NodePileup& node_pileups(int index) const;
  ::vg::NodePileup* add_node_pileups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::NodePileup >&
      node_pileups() const;

  // repeated .vg.EdgePileup edge_pileups = 2;
  int edge_pileups_size() const;
  private:
  int _internal_edge_pileups_size() const;
  public:
  void clear_edge_pileups();
  ::vg::EdgePileup* mutable_edge_pileups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::EdgePileup >*
      mutable_edge_pileups();
  private:
  const ::vg::EdgePileup& _internal_edge_pileups(int index) const;
  ::vg::EdgePileup* _internal_add_edge_pileups();
  public:
  const ::vg::EdgePileup& edge_pileups(int index) const;
  ::vg::EdgePileup* add_edge_pileups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::EdgePileup >&
      edge_pileups() const;

  // @@protoc_insertion_point(class_scope:vg.Pileup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::NodePileup > node_pileups_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::EdgePileup > edge_pileups_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Snarl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Snarl) */ {
 public:
  inline Snarl() : Snarl(nullptr) {}
  ~Snarl() override;
  explicit PROTOBUF_CONSTEXPR Snarl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Snarl(const Snarl& from);
  Snarl(Snarl&& from) noexcept
    : Snarl() {
    *this = ::std::move(from);
  }

  inline Snarl& operator=(const Snarl& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snarl& operator=(Snarl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Snarl& default_instance() {
    return *internal_default_instance();
  }
  static inline const Snarl* internal_default_instance() {
    return reinterpret_cast<const Snarl*>(
               &_Snarl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Snarl& a, Snarl& b) {
    a.Swap(&b);
  }
  inline void Swap(Snarl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snarl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Snarl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Snarl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Snarl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Snarl& from) {
    Snarl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snarl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Snarl";
  }
  protected:
  explicit Snarl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 5,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kParentFieldNumber = 4,
    kTypeFieldNumber = 1,
    kStartSelfReachableFieldNumber = 6,
    kEndSelfReachableFieldNumber = 7,
    kStartEndReachableFieldNumber = 8,
    kDirectedAcyclicNetGraphFieldNumber = 9,
  };
  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vg.Visit start = 2;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::vg::Visit& start() const;
  PROTOBUF_NODISCARD ::vg::Visit* release_start();
  ::vg::Visit* mutable_start();
  void set_allocated_start(::vg::Visit* start);
  private:
  const ::vg::Visit& _internal_start() const;
  ::vg::Visit* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::vg::Visit* start);
  ::vg::Visit* unsafe_arena_release_start();

  // .vg.Visit end = 3;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::vg::Visit& end() const;
  PROTOBUF_NODISCARD ::vg::Visit* release_end();
  ::vg::Visit* mutable_end();
  void set_allocated_end(::vg::Visit* end);
  private:
  const ::vg::Visit& _internal_end() const;
  ::vg::Visit* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::vg::Visit* end);
  ::vg::Visit* unsafe_arena_release_end();

  // .vg.Snarl parent = 4;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const ::vg::Snarl& parent() const;
  PROTOBUF_NODISCARD ::vg::Snarl* release_parent();
  ::vg::Snarl* mutable_parent();
  void set_allocated_parent(::vg::Snarl* parent);
  private:
  const ::vg::Snarl& _internal_parent() const;
  ::vg::Snarl* _internal_mutable_parent();
  public:
  void unsafe_arena_set_allocated_parent(
      ::vg::Snarl* parent);
  ::vg::Snarl* unsafe_arena_release_parent();

  // .vg.SnarlType type = 1;
  void clear_type();
  ::vg::SnarlType type() const;
  void set_type(::vg::SnarlType value);
  private:
  ::vg::SnarlType _internal_type() const;
  void _internal_set_type(::vg::SnarlType value);
  public:

  // bool start_self_reachable = 6;
  void clear_start_self_reachable();
  bool start_self_reachable() const;
  void set_start_self_reachable(bool value);
  private:
  bool _internal_start_self_reachable() const;
  void _internal_set_start_self_reachable(bool value);
  public:

  // bool end_self_reachable = 7;
  void clear_end_self_reachable();
  bool end_self_reachable() const;
  void set_end_self_reachable(bool value);
  private:
  bool _internal_end_self_reachable() const;
  void _internal_set_end_self_reachable(bool value);
  public:

  // bool start_end_reachable = 8;
  void clear_start_end_reachable();
  bool start_end_reachable() const;
  void set_start_end_reachable(bool value);
  private:
  bool _internal_start_end_reachable() const;
  void _internal_set_start_end_reachable(bool value);
  public:

  // bool directed_acyclic_net_graph = 9;
  void clear_directed_acyclic_net_graph();
  bool directed_acyclic_net_graph() const;
  void set_directed_acyclic_net_graph(bool value);
  private:
  bool _internal_directed_acyclic_net_graph() const;
  void _internal_set_directed_acyclic_net_graph(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Snarl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::vg::Visit* start_;
    ::vg::Visit* end_;
    ::vg::Snarl* parent_;
    int type_;
    bool start_self_reachable_;
    bool end_self_reachable_;
    bool start_end_reachable_;
    bool directed_acyclic_net_graph_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Visit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Visit) */ {
 public:
  inline Visit() : Visit(nullptr) {}
  ~Visit() override;
  explicit PROTOBUF_CONSTEXPR Visit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Visit(const Visit& from);
  Visit(Visit&& from) noexcept
    : Visit() {
    *this = ::std::move(from);
  }

  inline Visit& operator=(const Visit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Visit& operator=(Visit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Visit& default_instance() {
    return *internal_default_instance();
  }
  static inline const Visit* internal_default_instance() {
    return reinterpret_cast<const Visit*>(
               &_Visit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Visit& a, Visit& b) {
    a.Swap(&b);
  }
  inline void Swap(Visit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Visit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Visit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Visit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Visit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Visit& from) {
    Visit::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Visit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Visit";
  }
  protected:
  explicit Visit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnarlFieldNumber = 2,
    kNodeIdFieldNumber = 1,
    kBackwardFieldNumber = 3,
  };
  // .vg.Snarl snarl = 2;
  bool has_snarl() const;
  private:
  bool _internal_has_snarl() const;
  public:
  void clear_snarl();
  const ::vg::Snarl& snarl() const;
  PROTOBUF_NODISCARD ::vg::Snarl* release_snarl();
  ::vg::Snarl* mutable_snarl();
  void set_allocated_snarl(::vg::Snarl* snarl);
  private:
  const ::vg::Snarl& _internal_snarl() const;
  ::vg::Snarl* _internal_mutable_snarl();
  public:
  void unsafe_arena_set_allocated_snarl(
      ::vg::Snarl* snarl);
  ::vg::Snarl* unsafe_arena_release_snarl();

  // int64 node_id = 1;
  void clear_node_id();
  int64_t node_id() const;
  void set_node_id(int64_t value);
  private:
  int64_t _internal_node_id() const;
  void _internal_set_node_id(int64_t value);
  public:

  // bool backward = 3;
  void clear_backward();
  bool backward() const;
  void set_backward(bool value);
  private:
  bool _internal_backward() const;
  void _internal_set_backward(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Visit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vg::Snarl* snarl_;
    int64_t node_id_;
    bool backward_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class SnarlTraversal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.SnarlTraversal) */ {
 public:
  inline SnarlTraversal() : SnarlTraversal(nullptr) {}
  ~SnarlTraversal() override;
  explicit PROTOBUF_CONSTEXPR SnarlTraversal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnarlTraversal(const SnarlTraversal& from);
  SnarlTraversal(SnarlTraversal&& from) noexcept
    : SnarlTraversal() {
    *this = ::std::move(from);
  }

  inline SnarlTraversal& operator=(const SnarlTraversal& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnarlTraversal& operator=(SnarlTraversal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnarlTraversal& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnarlTraversal* internal_default_instance() {
    return reinterpret_cast<const SnarlTraversal*>(
               &_SnarlTraversal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SnarlTraversal& a, SnarlTraversal& b) {
    a.Swap(&b);
  }
  inline void Swap(SnarlTraversal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnarlTraversal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnarlTraversal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnarlTraversal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnarlTraversal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnarlTraversal& from) {
    SnarlTraversal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnarlTraversal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.SnarlTraversal";
  }
  protected:
  explicit SnarlTraversal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVisitFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // repeated .vg.Visit visit = 1;
  int visit_size() const;
  private:
  int _internal_visit_size() const;
  public:
  void clear_visit();
  ::vg::Visit* mutable_visit(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Visit >*
      mutable_visit();
  private:
  const ::vg::Visit& _internal_visit(int index) const;
  ::vg::Visit* _internal_add_visit();
  public:
  const ::vg::Visit& visit(int index) const;
  ::vg::Visit* add_visit();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Visit >&
      visit() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:vg.SnarlTraversal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Visit > visit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Locus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Locus) */ {
 public:
  inline Locus() : Locus(nullptr) {}
  ~Locus() override;
  explicit PROTOBUF_CONSTEXPR Locus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Locus(const Locus& from);
  Locus(Locus&& from) noexcept
    : Locus() {
    *this = ::std::move(from);
  }

  inline Locus& operator=(const Locus& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locus& operator=(Locus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Locus& default_instance() {
    return *internal_default_instance();
  }
  static inline const Locus* internal_default_instance() {
    return reinterpret_cast<const Locus*>(
               &_Locus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Locus& a, Locus& b) {
    a.Swap(&b);
  }
  inline void Swap(Locus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Locus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Locus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Locus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Locus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Locus& from) {
    Locus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Locus";
  }
  protected:
  explicit Locus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlleleFieldNumber = 2,
    kSupportFieldNumber = 3,
    kGenotypeFieldNumber = 4,
    kAlleleLogLikelihoodFieldNumber = 6,
    kNameFieldNumber = 1,
    kOverallSupportFieldNumber = 5,
  };
  // repeated .vg.Path allele = 2;
  int allele_size() const;
  private:
  int _internal_allele_size() const;
  public:
  void clear_allele();
  ::vg::Path* mutable_allele(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >*
      mutable_allele();
  private:
  const ::vg::Path& _internal_allele(int index) const;
  ::vg::Path* _internal_add_allele();
  public:
  const ::vg::Path& allele(int index) const;
  ::vg::Path* add_allele();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >&
      allele() const;

  // repeated .vg.Support support = 3;
  int support_size() const;
  private:
  int _internal_support_size() const;
  public:
  void clear_support();
  ::vg::Support* mutable_support(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Support >*
      mutable_support();
  private:
  const ::vg::Support& _internal_support(int index) const;
  ::vg::Support* _internal_add_support();
  public:
  const ::vg::Support& support(int index) const;
  ::vg::Support* add_support();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Support >&
      support() const;

  // repeated .vg.Genotype genotype = 4;
  int genotype_size() const;
  private:
  int _internal_genotype_size() const;
  public:
  void clear_genotype();
  ::vg::Genotype* mutable_genotype(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Genotype >*
      mutable_genotype();
  private:
  const ::vg::Genotype& _internal_genotype(int index) const;
  ::vg::Genotype* _internal_add_genotype();
  public:
  const ::vg::Genotype& genotype(int index) const;
  ::vg::Genotype* add_genotype();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Genotype >&
      genotype() const;

  // repeated double allele_log_likelihood = 6;
  int allele_log_likelihood_size() const;
  private:
  int _internal_allele_log_likelihood_size() const;
  public:
  void clear_allele_log_likelihood();
  private:
  double _internal_allele_log_likelihood(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_allele_log_likelihood() const;
  void _internal_add_allele_log_likelihood(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_allele_log_likelihood();
  public:
  double allele_log_likelihood(int index) const;
  void set_allele_log_likelihood(int index, double value);
  void add_allele_log_likelihood(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      allele_log_likelihood() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_allele_log_likelihood();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .vg.Support overall_support = 5;
  bool has_overall_support() const;
  private:
  bool _internal_has_overall_support() const;
  public:
  void clear_overall_support();
  const ::vg::Support& overall_support() const;
  PROTOBUF_NODISCARD ::vg::Support* release_overall_support();
  ::vg::Support* mutable_overall_support();
  void set_allocated_overall_support(::vg::Support* overall_support);
  private:
  const ::vg::Support& _internal_overall_support() const;
  ::vg::Support* _internal_mutable_overall_support();
  public:
  void unsafe_arena_set_allocated_overall_support(
      ::vg::Support* overall_support);
  ::vg::Support* unsafe_arena_release_overall_support();

  // @@protoc_insertion_point(class_scope:vg.Locus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path > allele_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Support > support_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Genotype > genotype_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > allele_log_likelihood_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::vg::Support* overall_support_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Genotype final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Genotype) */ {
 public:
  inline Genotype() : Genotype(nullptr) {}
  ~Genotype() override;
  explicit PROTOBUF_CONSTEXPR Genotype(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Genotype(const Genotype& from);
  Genotype(Genotype&& from) noexcept
    : Genotype() {
    *this = ::std::move(from);
  }

  inline Genotype& operator=(const Genotype& from) {
    CopyFrom(from);
    return *this;
  }
  inline Genotype& operator=(Genotype&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Genotype& default_instance() {
    return *internal_default_instance();
  }
  static inline const Genotype* internal_default_instance() {
    return reinterpret_cast<const Genotype*>(
               &_Genotype_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Genotype& a, Genotype& b) {
    a.Swap(&b);
  }
  inline void Swap(Genotype* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Genotype* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Genotype* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Genotype>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Genotype& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Genotype& from) {
    Genotype::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Genotype* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Genotype";
  }
  protected:
  explicit Genotype(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlleleFieldNumber = 1,
    kLikelihoodFieldNumber = 3,
    kLogLikelihoodFieldNumber = 4,
    kLogPriorFieldNumber = 5,
    kLogPosteriorFieldNumber = 6,
    kIsPhasedFieldNumber = 2,
  };
  // repeated int32 allele = 1;
  int allele_size() const;
  private:
  int _internal_allele_size() const;
  public:
  void clear_allele();
  private:
  int32_t _internal_allele(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_allele() const;
  void _internal_add_allele(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_allele();
  public:
  int32_t allele(int index) const;
  void set_allele(int index, int32_t value);
  void add_allele(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      allele() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_allele();

  // double likelihood = 3;
  void clear_likelihood();
  double likelihood() const;
  void set_likelihood(double value);
  private:
  double _internal_likelihood() const;
  void _internal_set_likelihood(double value);
  public:

  // double log_likelihood = 4;
  void clear_log_likelihood();
  double log_likelihood() const;
  void set_log_likelihood(double value);
  private:
  double _internal_log_likelihood() const;
  void _internal_set_log_likelihood(double value);
  public:

  // double log_prior = 5;
  void clear_log_prior();
  double log_prior() const;
  void set_log_prior(double value);
  private:
  double _internal_log_prior() const;
  void _internal_set_log_prior(double value);
  public:

  // double log_posterior = 6;
  void clear_log_posterior();
  double log_posterior() const;
  void set_log_posterior(double value);
  private:
  double _internal_log_posterior() const;
  void _internal_set_log_posterior(double value);
  public:

  // bool is_phased = 2;
  void clear_is_phased();
  bool is_phased() const;
  void set_is_phased(bool value);
  private:
  bool _internal_is_phased() const;
  void _internal_set_is_phased(bool value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Genotype)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > allele_;
    mutable std::atomic<int> _allele_cached_byte_size_;
    double likelihood_;
    double log_likelihood_;
    double log_prior_;
    double log_posterior_;
    bool is_phased_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Support final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Support) */ {
 public:
  inline Support() : Support(nullptr) {}
  ~Support() override;
  explicit PROTOBUF_CONSTEXPR Support(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Support(const Support& from);
  Support(Support&& from) noexcept
    : Support() {
    *this = ::std::move(from);
  }

  inline Support& operator=(const Support& from) {
    CopyFrom(from);
    return *this;
  }
  inline Support& operator=(Support&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Support& default_instance() {
    return *internal_default_instance();
  }
  static inline const Support* internal_default_instance() {
    return reinterpret_cast<const Support*>(
               &_Support_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Support& a, Support& b) {
    a.Swap(&b);
  }
  inline void Swap(Support* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Support* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Support* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Support>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Support& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Support& from) {
    Support::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Support* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Support";
  }
  protected:
  explicit Support(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualityFieldNumber = 1,
    kForwardFieldNumber = 2,
    kReverseFieldNumber = 3,
    kLeftFieldNumber = 4,
    kRightFieldNumber = 5,
  };
  // double quality = 1;
  void clear_quality();
  double quality() const;
  void set_quality(double value);
  private:
  double _internal_quality() const;
  void _internal_set_quality(double value);
  public:

  // double forward = 2;
  void clear_forward();
  double forward() const;
  void set_forward(double value);
  private:
  double _internal_forward() const;
  void _internal_set_forward(double value);
  public:

  // double reverse = 3;
  void clear_reverse();
  double reverse() const;
  void set_reverse(double value);
  private:
  double _internal_reverse() const;
  void _internal_set_reverse(double value);
  public:

  // double left = 4;
  void clear_left();
  double left() const;
  void set_left(double value);
  private:
  double _internal_left() const;
  void _internal_set_left(double value);
  public:

  // double right = 5;
  void clear_right();
  double right() const;
  void set_right(double value);
  private:
  double _internal_right() const;
  void _internal_set_right(double value);
  public:

  // @@protoc_insertion_point(class_scope:vg.Support)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double quality_;
    double forward_;
    double reverse_;
    double left_;
    double right_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class LocationSupport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.LocationSupport) */ {
 public:
  inline LocationSupport() : LocationSupport(nullptr) {}
  ~LocationSupport() override;
  explicit PROTOBUF_CONSTEXPR LocationSupport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocationSupport(const LocationSupport& from);
  LocationSupport(LocationSupport&& from) noexcept
    : LocationSupport() {
    *this = ::std::move(from);
  }

  inline LocationSupport& operator=(const LocationSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocationSupport& operator=(LocationSupport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocationSupport& default_instance() {
    return *internal_default_instance();
  }
  enum OneofLocationCase {
    kEdge = 2,
    kNodeId = 3,
    ONEOF_LOCATION_NOT_SET = 0,
  };

  static inline const LocationSupport* internal_default_instance() {
    return reinterpret_cast<const LocationSupport*>(
               &_LocationSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(LocationSupport& a, LocationSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(LocationSupport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocationSupport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocationSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocationSupport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocationSupport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LocationSupport& from) {
    LocationSupport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationSupport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.LocationSupport";
  }
  protected:
  explicit LocationSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportFieldNumber = 1,
    kEdgeFieldNumber = 2,
    kNodeIdFieldNumber = 3,
  };
  // .vg.Support support = 1;
  bool has_support() const;
  private:
  bool _internal_has_support() const;
  public:
  void clear_support();
  const ::vg::Support& support() const;
  PROTOBUF_NODISCARD ::vg::Support* release_support();
  ::vg::Support* mutable_support();
  void set_allocated_support(::vg::Support* support);
  private:
  const ::vg::Support& _internal_support() const;
  ::vg::Support* _internal_mutable_support();
  public:
  void unsafe_arena_set_allocated_support(
      ::vg::Support* support);
  ::vg::Support* unsafe_arena_release_support();

  // .vg.Edge edge = 2;
  bool has_edge() const;
  private:
  bool _internal_has_edge() const;
  public:
  void clear_edge();
  const ::vg::Edge& edge() const;
  PROTOBUF_NODISCARD ::vg::Edge* release_edge();
  ::vg::Edge* mutable_edge();
  void set_allocated_edge(::vg::Edge* edge);
  private:
  const ::vg::Edge& _internal_edge() const;
  ::vg::Edge* _internal_mutable_edge();
  public:
  void unsafe_arena_set_allocated_edge(
      ::vg::Edge* edge);
  ::vg::Edge* unsafe_arena_release_edge();

  // int64 node_id = 3;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  int64_t node_id() const;
  void set_node_id(int64_t value);
  private:
  int64_t _internal_node_id() const;
  void _internal_set_node_id(int64_t value);
  public:

  void clear_oneof_location();
  OneofLocationCase oneof_location_case() const;
  // @@protoc_insertion_point(class_scope:vg.LocationSupport)
 private:
  class _Internal;
  void set_has_edge();
  void set_has_node_id();

  inline bool has_oneof_location() const;
  inline void clear_has_oneof_location();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vg::Support* support_;
    union OneofLocationUnion {
      constexpr OneofLocationUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::vg::Edge* edge_;
      int64_t node_id_;
    } oneof_location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// -------------------------------------------------------------------

class Translation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:vg.Translation) */ {
 public:
  inline Translation() : Translation(nullptr) {}
  ~Translation() override;
  explicit PROTOBUF_CONSTEXPR Translation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Translation(const Translation& from);
  Translation(Translation&& from) noexcept
    : Translation() {
    *this = ::std::move(from);
  }

  inline Translation& operator=(const Translation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Translation& operator=(Translation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Translation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Translation* internal_default_instance() {
    return reinterpret_cast<const Translation*>(
               &_Translation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Translation& a, Translation& b) {
    a.Swap(&b);
  }
  inline void Swap(Translation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Translation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Translation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Translation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Translation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Translation& from) {
    Translation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Translation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "vg.Translation";
  }
  protected:
  explicit Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // .vg.Path from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::vg::Path& from() const;
  PROTOBUF_NODISCARD ::vg::Path* release_from();
  ::vg::Path* mutable_from();
  void set_allocated_from(::vg::Path* from);
  private:
  const ::vg::Path& _internal_from() const;
  ::vg::Path* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::vg::Path* from);
  ::vg::Path* unsafe_arena_release_from();

  // .vg.Path to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::vg::Path& to() const;
  PROTOBUF_NODISCARD ::vg::Path* release_to();
  ::vg::Path* mutable_to();
  void set_allocated_to(::vg::Path* to);
  private:
  const ::vg::Path& _internal_to() const;
  ::vg::Path* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::vg::Path* to);
  ::vg::Path* unsafe_arena_release_to();

  // @@protoc_insertion_point(class_scope:vg.Translation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::vg::Path* from_;
    ::vg::Path* to_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_vg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Graph

// repeated .vg.Node node = 1;
inline int Graph::_internal_node_size() const {
  return _impl_.node_.size();
}
inline int Graph::node_size() const {
  return _internal_node_size();
}
inline void Graph::clear_node() {
  _impl_.node_.Clear();
}
inline ::vg::Node* Graph::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.node)
  return _impl_.node_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Node >*
Graph::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.node)
  return &_impl_.node_;
}
inline const ::vg::Node& Graph::_internal_node(int index) const {
  return _impl_.node_.Get(index);
}
inline const ::vg::Node& Graph::node(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.node)
  return _internal_node(index);
}
inline ::vg::Node* Graph::_internal_add_node() {
  return _impl_.node_.Add();
}
inline ::vg::Node* Graph::add_node() {
  ::vg::Node* _add = _internal_add_node();
  // @@protoc_insertion_point(field_add:vg.Graph.node)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Node >&
Graph::node() const {
  // @@protoc_insertion_point(field_list:vg.Graph.node)
  return _impl_.node_;
}

// repeated .vg.Edge edge = 2;
inline int Graph::_internal_edge_size() const {
  return _impl_.edge_.size();
}
inline int Graph::edge_size() const {
  return _internal_edge_size();
}
inline void Graph::clear_edge() {
  _impl_.edge_.Clear();
}
inline ::vg::Edge* Graph::mutable_edge(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.edge)
  return _impl_.edge_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edge >*
Graph::mutable_edge() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.edge)
  return &_impl_.edge_;
}
inline const ::vg::Edge& Graph::_internal_edge(int index) const {
  return _impl_.edge_.Get(index);
}
inline const ::vg::Edge& Graph::edge(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.edge)
  return _internal_edge(index);
}
inline ::vg::Edge* Graph::_internal_add_edge() {
  return _impl_.edge_.Add();
}
inline ::vg::Edge* Graph::add_edge() {
  ::vg::Edge* _add = _internal_add_edge();
  // @@protoc_insertion_point(field_add:vg.Graph.edge)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edge >&
Graph::edge() const {
  // @@protoc_insertion_point(field_list:vg.Graph.edge)
  return _impl_.edge_;
}

// repeated .vg.Path path = 3;
inline int Graph::_internal_path_size() const {
  return _impl_.path_.size();
}
inline int Graph::path_size() const {
  return _internal_path_size();
}
inline void Graph::clear_path() {
  _impl_.path_.Clear();
}
inline ::vg::Path* Graph::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Graph.path)
  return _impl_.path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >*
Graph::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:vg.Graph.path)
  return &_impl_.path_;
}
inline const ::vg::Path& Graph::_internal_path(int index) const {
  return _impl_.path_.Get(index);
}
inline const ::vg::Path& Graph::path(int index) const {
  // @@protoc_insertion_point(field_get:vg.Graph.path)
  return _internal_path(index);
}
inline ::vg::Path* Graph::_internal_add_path() {
  return _impl_.path_.Add();
}
inline ::vg::Path* Graph::add_path() {
  ::vg::Path* _add = _internal_add_path();
  // @@protoc_insertion_point(field_add:vg.Graph.path)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >&
Graph::path() const {
  // @@protoc_insertion_point(field_list:vg.Graph.path)
  return _impl_.path_;
}

// -------------------------------------------------------------------

// Node

// string sequence = 1;
inline void Node::clear_sequence() {
  _impl_.sequence_.ClearToEmpty();
}
inline const std::string& Node::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Node.sequence)
  return _internal_sequence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_sequence(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Node.sequence)
}
inline std::string* Node::mutable_sequence() {
  std::string* _s = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:vg.Node.sequence)
  return _s;
}
inline const std::string& Node::_internal_sequence() const {
  return _impl_.sequence_.Get();
}
inline void Node::_internal_set_sequence(const std::string& value) {
  
  _impl_.sequence_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_sequence() {
  
  return _impl_.sequence_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Node.sequence)
  return _impl_.sequence_.Release();
}
inline void Node::set_allocated_sequence(std::string* sequence) {
  if (sequence != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_.SetAllocated(sequence, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_.IsDefault()) {
    _impl_.sequence_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Node.sequence)
}

// string name = 2;
inline void Node::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:vg.Node.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Node.name)
}
inline std::string* Node::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.Node.name)
  return _s;
}
inline const std::string& Node::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:vg.Node.name)
  return _impl_.name_.Release();
}
inline void Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Node.name)
}

// int64 id = 3;
inline void Node::clear_id() {
  _impl_.id_ = int64_t{0};
}
inline int64_t Node::_internal_id() const {
  return _impl_.id_;
}
inline int64_t Node::id() const {
  // @@protoc_insertion_point(field_get:vg.Node.id)
  return _internal_id();
}
inline void Node::_internal_set_id(int64_t value) {
  
  _impl_.id_ = value;
}
inline void Node::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:vg.Node.id)
}

// -------------------------------------------------------------------

// Edge

// int64 from = 1;
inline void Edge::clear_from() {
  _impl_.from_ = int64_t{0};
}
inline int64_t Edge::_internal_from() const {
  return _impl_.from_;
}
inline int64_t Edge::from() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from)
  return _internal_from();
}
inline void Edge::_internal_set_from(int64_t value) {
  
  _impl_.from_ = value;
}
inline void Edge::set_from(int64_t value) {
  _internal_set_from(value);
  // @@protoc_insertion_point(field_set:vg.Edge.from)
}

// int64 to = 2;
inline void Edge::clear_to() {
  _impl_.to_ = int64_t{0};
}
inline int64_t Edge::_internal_to() const {
  return _impl_.to_;
}
inline int64_t Edge::to() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to)
  return _internal_to();
}
inline void Edge::_internal_set_to(int64_t value) {
  
  _impl_.to_ = value;
}
inline void Edge::set_to(int64_t value) {
  _internal_set_to(value);
  // @@protoc_insertion_point(field_set:vg.Edge.to)
}

// bool from_start = 3;
inline void Edge::clear_from_start() {
  _impl_.from_start_ = false;
}
inline bool Edge::_internal_from_start() const {
  return _impl_.from_start_;
}
inline bool Edge::from_start() const {
  // @@protoc_insertion_point(field_get:vg.Edge.from_start)
  return _internal_from_start();
}
inline void Edge::_internal_set_from_start(bool value) {
  
  _impl_.from_start_ = value;
}
inline void Edge::set_from_start(bool value) {
  _internal_set_from_start(value);
  // @@protoc_insertion_point(field_set:vg.Edge.from_start)
}

// bool to_end = 4;
inline void Edge::clear_to_end() {
  _impl_.to_end_ = false;
}
inline bool Edge::_internal_to_end() const {
  return _impl_.to_end_;
}
inline bool Edge::to_end() const {
  // @@protoc_insertion_point(field_get:vg.Edge.to_end)
  return _internal_to_end();
}
inline void Edge::_internal_set_to_end(bool value) {
  
  _impl_.to_end_ = value;
}
inline void Edge::set_to_end(bool value) {
  _internal_set_to_end(value);
  // @@protoc_insertion_point(field_set:vg.Edge.to_end)
}

// int32 overlap = 5;
inline void Edge::clear_overlap() {
  _impl_.overlap_ = 0;
}
inline int32_t Edge::_internal_overlap() const {
  return _impl_.overlap_;
}
inline int32_t Edge::overlap() const {
  // @@protoc_insertion_point(field_get:vg.Edge.overlap)
  return _internal_overlap();
}
inline void Edge::_internal_set_overlap(int32_t value) {
  
  _impl_.overlap_ = value;
}
inline void Edge::set_overlap(int32_t value) {
  _internal_set_overlap(value);
  // @@protoc_insertion_point(field_set:vg.Edge.overlap)
}

// -------------------------------------------------------------------

// Edit

// int32 from_length = 1;
inline void Edit::clear_from_length() {
  _impl_.from_length_ = 0;
}
inline int32_t Edit::_internal_from_length() const {
  return _impl_.from_length_;
}
inline int32_t Edit::from_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.from_length)
  return _internal_from_length();
}
inline void Edit::_internal_set_from_length(int32_t value) {
  
  _impl_.from_length_ = value;
}
inline void Edit::set_from_length(int32_t value) {
  _internal_set_from_length(value);
  // @@protoc_insertion_point(field_set:vg.Edit.from_length)
}

// int32 to_length = 2;
inline void Edit::clear_to_length() {
  _impl_.to_length_ = 0;
}
inline int32_t Edit::_internal_to_length() const {
  return _impl_.to_length_;
}
inline int32_t Edit::to_length() const {
  // @@protoc_insertion_point(field_get:vg.Edit.to_length)
  return _internal_to_length();
}
inline void Edit::_internal_set_to_length(int32_t value) {
  
  _impl_.to_length_ = value;
}
inline void Edit::set_to_length(int32_t value) {
  _internal_set_to_length(value);
  // @@protoc_insertion_point(field_set:vg.Edit.to_length)
}

// string sequence = 3;
inline void Edit::clear_sequence() {
  _impl_.sequence_.ClearToEmpty();
}
inline const std::string& Edit::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Edit.sequence)
  return _internal_sequence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Edit::set_sequence(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Edit.sequence)
}
inline std::string* Edit::mutable_sequence() {
  std::string* _s = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:vg.Edit.sequence)
  return _s;
}
inline const std::string& Edit::_internal_sequence() const {
  return _impl_.sequence_.Get();
}
inline void Edit::_internal_set_sequence(const std::string& value) {
  
  _impl_.sequence_.Set(value, GetArenaForAllocation());
}
inline std::string* Edit::_internal_mutable_sequence() {
  
  return _impl_.sequence_.Mutable(GetArenaForAllocation());
}
inline std::string* Edit::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Edit.sequence)
  return _impl_.sequence_.Release();
}
inline void Edit::set_allocated_sequence(std::string* sequence) {
  if (sequence != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_.SetAllocated(sequence, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_.IsDefault()) {
    _impl_.sequence_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Edit.sequence)
}

// -------------------------------------------------------------------

// Mapping

// .vg.Position position = 1;
inline bool Mapping::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool Mapping::has_position() const {
  return _internal_has_position();
}
inline void Mapping::clear_position() {
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
}
inline const ::vg::Position& Mapping::_internal_position() const {
  const ::vg::Position* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Position&>(
      ::vg::_Position_default_instance_);
}
inline const ::vg::Position& Mapping::position() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.position)
  return _internal_position();
}
inline void Mapping::unsafe_arena_set_allocated_position(
    ::vg::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Mapping.position)
}
inline ::vg::Position* Mapping::release_position() {
  
  ::vg::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Position* Mapping::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:vg.Mapping.position)
  
  ::vg::Position* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::vg::Position* Mapping::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Position>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::vg::Position* Mapping::mutable_position() {
  ::vg::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:vg.Mapping.position)
  return _msg;
}
inline void Mapping::set_allocated_position(::vg::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:vg.Mapping.position)
}

// repeated .vg.Edit edit = 2;
inline int Mapping::_internal_edit_size() const {
  return _impl_.edit_.size();
}
inline int Mapping::edit_size() const {
  return _internal_edit_size();
}
inline void Mapping::clear_edit() {
  _impl_.edit_.Clear();
}
inline ::vg::Edit* Mapping::mutable_edit(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Mapping.edit)
  return _impl_.edit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edit >*
Mapping::mutable_edit() {
  // @@protoc_insertion_point(field_mutable_list:vg.Mapping.edit)
  return &_impl_.edit_;
}
inline const ::vg::Edit& Mapping::_internal_edit(int index) const {
  return _impl_.edit_.Get(index);
}
inline const ::vg::Edit& Mapping::edit(int index) const {
  // @@protoc_insertion_point(field_get:vg.Mapping.edit)
  return _internal_edit(index);
}
inline ::vg::Edit* Mapping::_internal_add_edit() {
  return _impl_.edit_.Add();
}
inline ::vg::Edit* Mapping::add_edit() {
  ::vg::Edit* _add = _internal_add_edit();
  // @@protoc_insertion_point(field_add:vg.Mapping.edit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Edit >&
Mapping::edit() const {
  // @@protoc_insertion_point(field_list:vg.Mapping.edit)
  return _impl_.edit_;
}

// int64 rank = 5;
inline void Mapping::clear_rank() {
  _impl_.rank_ = int64_t{0};
}
inline int64_t Mapping::_internal_rank() const {
  return _impl_.rank_;
}
inline int64_t Mapping::rank() const {
  // @@protoc_insertion_point(field_get:vg.Mapping.rank)
  return _internal_rank();
}
inline void Mapping::_internal_set_rank(int64_t value) {
  
  _impl_.rank_ = value;
}
inline void Mapping::set_rank(int64_t value) {
  _internal_set_rank(value);
  // @@protoc_insertion_point(field_set:vg.Mapping.rank)
}

// -------------------------------------------------------------------

// Position

// int64 node_id = 1;
inline void Position::clear_node_id() {
  _impl_.node_id_ = int64_t{0};
}
inline int64_t Position::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int64_t Position::node_id() const {
  // @@protoc_insertion_point(field_get:vg.Position.node_id)
  return _internal_node_id();
}
inline void Position::_internal_set_node_id(int64_t value) {
  
  _impl_.node_id_ = value;
}
inline void Position::set_node_id(int64_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:vg.Position.node_id)
}

// int64 offset = 2;
inline void Position::clear_offset() {
  _impl_.offset_ = int64_t{0};
}
inline int64_t Position::_internal_offset() const {
  return _impl_.offset_;
}
inline int64_t Position::offset() const {
  // @@protoc_insertion_point(field_get:vg.Position.offset)
  return _internal_offset();
}
inline void Position::_internal_set_offset(int64_t value) {
  
  _impl_.offset_ = value;
}
inline void Position::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:vg.Position.offset)
}

// bool is_reverse = 4;
inline void Position::clear_is_reverse() {
  _impl_.is_reverse_ = false;
}
inline bool Position::_internal_is_reverse() const {
  return _impl_.is_reverse_;
}
inline bool Position::is_reverse() const {
  // @@protoc_insertion_point(field_get:vg.Position.is_reverse)
  return _internal_is_reverse();
}
inline void Position::_internal_set_is_reverse(bool value) {
  
  _impl_.is_reverse_ = value;
}
inline void Position::set_is_reverse(bool value) {
  _internal_set_is_reverse(value);
  // @@protoc_insertion_point(field_set:vg.Position.is_reverse)
}

// string name = 5;
inline void Position::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Position::name() const {
  // @@protoc_insertion_point(field_get:vg.Position.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Position::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Position.name)
}
inline std::string* Position::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.Position.name)
  return _s;
}
inline const std::string& Position::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Position::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Position::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Position::release_name() {
  // @@protoc_insertion_point(field_release:vg.Position.name)
  return _impl_.name_.Release();
}
inline void Position::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Position.name)
}

// -------------------------------------------------------------------

// Path

// string name = 1;
inline void Path::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Path::name() const {
  // @@protoc_insertion_point(field_get:vg.Path.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Path::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Path.name)
}
inline std::string* Path::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.Path.name)
  return _s;
}
inline const std::string& Path::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Path::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Path::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Path::release_name() {
  // @@protoc_insertion_point(field_release:vg.Path.name)
  return _impl_.name_.Release();
}
inline void Path::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Path.name)
}

// repeated .vg.Mapping mapping = 2;
inline int Path::_internal_mapping_size() const {
  return _impl_.mapping_.size();
}
inline int Path::mapping_size() const {
  return _internal_mapping_size();
}
inline void Path::clear_mapping() {
  _impl_.mapping_.Clear();
}
inline ::vg::Mapping* Path::mutable_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Path.mapping)
  return _impl_.mapping_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Mapping >*
Path::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_list:vg.Path.mapping)
  return &_impl_.mapping_;
}
inline const ::vg::Mapping& Path::_internal_mapping(int index) const {
  return _impl_.mapping_.Get(index);
}
inline const ::vg::Mapping& Path::mapping(int index) const {
  // @@protoc_insertion_point(field_get:vg.Path.mapping)
  return _internal_mapping(index);
}
inline ::vg::Mapping* Path::_internal_add_mapping() {
  return _impl_.mapping_.Add();
}
inline ::vg::Mapping* Path::add_mapping() {
  ::vg::Mapping* _add = _internal_add_mapping();
  // @@protoc_insertion_point(field_add:vg.Path.mapping)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Mapping >&
Path::mapping() const {
  // @@protoc_insertion_point(field_list:vg.Path.mapping)
  return _impl_.mapping_;
}

// bool is_circular = 3;
inline void Path::clear_is_circular() {
  _impl_.is_circular_ = false;
}
inline bool Path::_internal_is_circular() const {
  return _impl_.is_circular_;
}
inline bool Path::is_circular() const {
  // @@protoc_insertion_point(field_get:vg.Path.is_circular)
  return _internal_is_circular();
}
inline void Path::_internal_set_is_circular(bool value) {
  
  _impl_.is_circular_ = value;
}
inline void Path::set_is_circular(bool value) {
  _internal_set_is_circular(value);
  // @@protoc_insertion_point(field_set:vg.Path.is_circular)
}

// int64 length = 4;
inline void Path::clear_length() {
  _impl_.length_ = int64_t{0};
}
inline int64_t Path::_internal_length() const {
  return _impl_.length_;
}
inline int64_t Path::length() const {
  // @@protoc_insertion_point(field_get:vg.Path.length)
  return _internal_length();
}
inline void Path::_internal_set_length(int64_t value) {
  
  _impl_.length_ = value;
}
inline void Path::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:vg.Path.length)
}

// -------------------------------------------------------------------

// Alignment

// string sequence = 1;
inline void Alignment::clear_sequence() {
  _impl_.sequence_.ClearToEmpty();
}
inline const std::string& Alignment::sequence() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sequence)
  return _internal_sequence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alignment::set_sequence(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Alignment.sequence)
}
inline std::string* Alignment::mutable_sequence() {
  std::string* _s = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sequence)
  return _s;
}
inline const std::string& Alignment::_internal_sequence() const {
  return _impl_.sequence_.Get();
}
inline void Alignment::_internal_set_sequence(const std::string& value) {
  
  _impl_.sequence_.Set(value, GetArenaForAllocation());
}
inline std::string* Alignment::_internal_mutable_sequence() {
  
  return _impl_.sequence_.Mutable(GetArenaForAllocation());
}
inline std::string* Alignment::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.Alignment.sequence)
  return _impl_.sequence_.Release();
}
inline void Alignment::set_allocated_sequence(std::string* sequence) {
  if (sequence != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_.SetAllocated(sequence, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_.IsDefault()) {
    _impl_.sequence_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sequence)
}

// .vg.Path path = 2;
inline bool Alignment::_internal_has_path() const {
  return this != internal_default_instance() && _impl_.path_ != nullptr;
}
inline bool Alignment::has_path() const {
  return _internal_has_path();
}
inline void Alignment::clear_path() {
  if (GetArenaForAllocation() == nullptr && _impl_.path_ != nullptr) {
    delete _impl_.path_;
  }
  _impl_.path_ = nullptr;
}
inline const ::vg::Path& Alignment::_internal_path() const {
  const ::vg::Path* p = _impl_.path_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Path&>(
      ::vg::_Path_default_instance_);
}
inline const ::vg::Path& Alignment::path() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.path)
  return _internal_path();
}
inline void Alignment::unsafe_arena_set_allocated_path(
    ::vg::Path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  _impl_.path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Alignment.path)
}
inline ::vg::Path* Alignment::release_path() {
  
  ::vg::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Path* Alignment::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:vg.Alignment.path)
  
  ::vg::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
  return temp;
}
inline ::vg::Path* Alignment::_internal_mutable_path() {
  
  if (_impl_.path_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaForAllocation());
    _impl_.path_ = p;
  }
  return _impl_.path_;
}
inline ::vg::Path* Alignment::mutable_path() {
  ::vg::Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.path)
  return _msg;
}
inline void Alignment::set_allocated_path(::vg::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.path_ = path;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.path)
}

// string name = 3;
inline void Alignment::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Alignment::name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alignment::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Alignment.name)
}
inline std::string* Alignment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.name)
  return _s;
}
inline const std::string& Alignment::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Alignment::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Alignment::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Alignment::release_name() {
  // @@protoc_insertion_point(field_release:vg.Alignment.name)
  return _impl_.name_.Release();
}
inline void Alignment::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.name)
}

// bytes quality = 4;
inline void Alignment::clear_quality() {
  _impl_.quality_.ClearToEmpty();
}
inline const std::string& Alignment::quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.quality)
  return _internal_quality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alignment::set_quality(ArgT0&& arg0, ArgT... args) {
 
 _impl_.quality_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Alignment.quality)
}
inline std::string* Alignment::mutable_quality() {
  std::string* _s = _internal_mutable_quality();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.quality)
  return _s;
}
inline const std::string& Alignment::_internal_quality() const {
  return _impl_.quality_.Get();
}
inline void Alignment::_internal_set_quality(const std::string& value) {
  
  _impl_.quality_.Set(value, GetArenaForAllocation());
}
inline std::string* Alignment::_internal_mutable_quality() {
  
  return _impl_.quality_.Mutable(GetArenaForAllocation());
}
inline std::string* Alignment::release_quality() {
  // @@protoc_insertion_point(field_release:vg.Alignment.quality)
  return _impl_.quality_.Release();
}
inline void Alignment::set_allocated_quality(std::string* quality) {
  if (quality != nullptr) {
    
  } else {
    
  }
  _impl_.quality_.SetAllocated(quality, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.quality_.IsDefault()) {
    _impl_.quality_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.quality)
}

// int32 mapping_quality = 5;
inline void Alignment::clear_mapping_quality() {
  _impl_.mapping_quality_ = 0;
}
inline int32_t Alignment::_internal_mapping_quality() const {
  return _impl_.mapping_quality_;
}
inline int32_t Alignment::mapping_quality() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mapping_quality)
  return _internal_mapping_quality();
}
inline void Alignment::_internal_set_mapping_quality(int32_t value) {
  
  _impl_.mapping_quality_ = value;
}
inline void Alignment::set_mapping_quality(int32_t value) {
  _internal_set_mapping_quality(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.mapping_quality)
}

// int32 score = 6;
inline void Alignment::clear_score() {
  _impl_.score_ = 0;
}
inline int32_t Alignment::_internal_score() const {
  return _impl_.score_;
}
inline int32_t Alignment::score() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.score)
  return _internal_score();
}
inline void Alignment::_internal_set_score(int32_t value) {
  
  _impl_.score_ = value;
}
inline void Alignment::set_score(int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.score)
}

// int32 query_position = 7;
inline void Alignment::clear_query_position() {
  _impl_.query_position_ = 0;
}
inline int32_t Alignment::_internal_query_position() const {
  return _impl_.query_position_;
}
inline int32_t Alignment::query_position() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.query_position)
  return _internal_query_position();
}
inline void Alignment::_internal_set_query_position(int32_t value) {
  
  _impl_.query_position_ = value;
}
inline void Alignment::set_query_position(int32_t value) {
  _internal_set_query_position(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.query_position)
}

// string sample_name = 9;
inline void Alignment::clear_sample_name() {
  _impl_.sample_name_.ClearToEmpty();
}
inline const std::string& Alignment::sample_name() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.sample_name)
  return _internal_sample_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alignment::set_sample_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sample_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Alignment.sample_name)
}
inline std::string* Alignment::mutable_sample_name() {
  std::string* _s = _internal_mutable_sample_name();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.sample_name)
  return _s;
}
inline const std::string& Alignment::_internal_sample_name() const {
  return _impl_.sample_name_.Get();
}
inline void Alignment::_internal_set_sample_name(const std::string& value) {
  
  _impl_.sample_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Alignment::_internal_mutable_sample_name() {
  
  return _impl_.sample_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Alignment::release_sample_name() {
  // @@protoc_insertion_point(field_release:vg.Alignment.sample_name)
  return _impl_.sample_name_.Release();
}
inline void Alignment::set_allocated_sample_name(std::string* sample_name) {
  if (sample_name != nullptr) {
    
  } else {
    
  }
  _impl_.sample_name_.SetAllocated(sample_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sample_name_.IsDefault()) {
    _impl_.sample_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.sample_name)
}

// string read_group = 10;
inline void Alignment::clear_read_group() {
  _impl_.read_group_.ClearToEmpty();
}
inline const std::string& Alignment::read_group() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_group)
  return _internal_read_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alignment::set_read_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Alignment.read_group)
}
inline std::string* Alignment::mutable_read_group() {
  std::string* _s = _internal_mutable_read_group();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.read_group)
  return _s;
}
inline const std::string& Alignment::_internal_read_group() const {
  return _impl_.read_group_.Get();
}
inline void Alignment::_internal_set_read_group(const std::string& value) {
  
  _impl_.read_group_.Set(value, GetArenaForAllocation());
}
inline std::string* Alignment::_internal_mutable_read_group() {
  
  return _impl_.read_group_.Mutable(GetArenaForAllocation());
}
inline std::string* Alignment::release_read_group() {
  // @@protoc_insertion_point(field_release:vg.Alignment.read_group)
  return _impl_.read_group_.Release();
}
inline void Alignment::set_allocated_read_group(std::string* read_group) {
  if (read_group != nullptr) {
    
  } else {
    
  }
  _impl_.read_group_.SetAllocated(read_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_group_.IsDefault()) {
    _impl_.read_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.read_group)
}

// .vg.Alignment fragment_prev = 11;
inline bool Alignment::_internal_has_fragment_prev() const {
  return this != internal_default_instance() && _impl_.fragment_prev_ != nullptr;
}
inline bool Alignment::has_fragment_prev() const {
  return _internal_has_fragment_prev();
}
inline void Alignment::clear_fragment_prev() {
  if (GetArenaForAllocation() == nullptr && _impl_.fragment_prev_ != nullptr) {
    delete _impl_.fragment_prev_;
  }
  _impl_.fragment_prev_ = nullptr;
}
inline const ::vg::Alignment& Alignment::_internal_fragment_prev() const {
  const ::vg::Alignment* p = _impl_.fragment_prev_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Alignment&>(
      ::vg::_Alignment_default_instance_);
}
inline const ::vg::Alignment& Alignment::fragment_prev() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_prev)
  return _internal_fragment_prev();
}
inline void Alignment::unsafe_arena_set_allocated_fragment_prev(
    ::vg::Alignment* fragment_prev) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fragment_prev_);
  }
  _impl_.fragment_prev_ = fragment_prev;
  if (fragment_prev) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Alignment.fragment_prev)
}
inline ::vg::Alignment* Alignment::release_fragment_prev() {
  
  ::vg::Alignment* temp = _impl_.fragment_prev_;
  _impl_.fragment_prev_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Alignment* Alignment::unsafe_arena_release_fragment_prev() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_prev)
  
  ::vg::Alignment* temp = _impl_.fragment_prev_;
  _impl_.fragment_prev_ = nullptr;
  return temp;
}
inline ::vg::Alignment* Alignment::_internal_mutable_fragment_prev() {
  
  if (_impl_.fragment_prev_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Alignment>(GetArenaForAllocation());
    _impl_.fragment_prev_ = p;
  }
  return _impl_.fragment_prev_;
}
inline ::vg::Alignment* Alignment::mutable_fragment_prev() {
  ::vg::Alignment* _msg = _internal_mutable_fragment_prev();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_prev)
  return _msg;
}
inline void Alignment::set_allocated_fragment_prev(::vg::Alignment* fragment_prev) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fragment_prev_;
  }
  if (fragment_prev) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment_prev);
    if (message_arena != submessage_arena) {
      fragment_prev = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment_prev, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fragment_prev_ = fragment_prev;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_prev)
}

// .vg.Alignment fragment_next = 12;
inline bool Alignment::_internal_has_fragment_next() const {
  return this != internal_default_instance() && _impl_.fragment_next_ != nullptr;
}
inline bool Alignment::has_fragment_next() const {
  return _internal_has_fragment_next();
}
inline void Alignment::clear_fragment_next() {
  if (GetArenaForAllocation() == nullptr && _impl_.fragment_next_ != nullptr) {
    delete _impl_.fragment_next_;
  }
  _impl_.fragment_next_ = nullptr;
}
inline const ::vg::Alignment& Alignment::_internal_fragment_next() const {
  const ::vg::Alignment* p = _impl_.fragment_next_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Alignment&>(
      ::vg::_Alignment_default_instance_);
}
inline const ::vg::Alignment& Alignment::fragment_next() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_next)
  return _internal_fragment_next();
}
inline void Alignment::unsafe_arena_set_allocated_fragment_next(
    ::vg::Alignment* fragment_next) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.fragment_next_);
  }
  _impl_.fragment_next_ = fragment_next;
  if (fragment_next) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Alignment.fragment_next)
}
inline ::vg::Alignment* Alignment::release_fragment_next() {
  
  ::vg::Alignment* temp = _impl_.fragment_next_;
  _impl_.fragment_next_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Alignment* Alignment::unsafe_arena_release_fragment_next() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_next)
  
  ::vg::Alignment* temp = _impl_.fragment_next_;
  _impl_.fragment_next_ = nullptr;
  return temp;
}
inline ::vg::Alignment* Alignment::_internal_mutable_fragment_next() {
  
  if (_impl_.fragment_next_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Alignment>(GetArenaForAllocation());
    _impl_.fragment_next_ = p;
  }
  return _impl_.fragment_next_;
}
inline ::vg::Alignment* Alignment::mutable_fragment_next() {
  ::vg::Alignment* _msg = _internal_mutable_fragment_next();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_next)
  return _msg;
}
inline void Alignment::set_allocated_fragment_next(::vg::Alignment* fragment_next) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.fragment_next_;
  }
  if (fragment_next) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fragment_next);
    if (message_arena != submessage_arena) {
      fragment_next = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fragment_next, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.fragment_next_ = fragment_next;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_next)
}

// bool is_secondary = 15;
inline void Alignment::clear_is_secondary() {
  _impl_.is_secondary_ = false;
}
inline bool Alignment::_internal_is_secondary() const {
  return _impl_.is_secondary_;
}
inline bool Alignment::is_secondary() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.is_secondary)
  return _internal_is_secondary();
}
inline void Alignment::_internal_set_is_secondary(bool value) {
  
  _impl_.is_secondary_ = value;
}
inline void Alignment::set_is_secondary(bool value) {
  _internal_set_is_secondary(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.is_secondary)
}

// double identity = 16;
inline void Alignment::clear_identity() {
  _impl_.identity_ = 0;
}
inline double Alignment::_internal_identity() const {
  return _impl_.identity_;
}
inline double Alignment::identity() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.identity)
  return _internal_identity();
}
inline void Alignment::_internal_set_identity(double value) {
  
  _impl_.identity_ = value;
}
inline void Alignment::set_identity(double value) {
  _internal_set_identity(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.identity)
}

// repeated .vg.Path fragment = 17;
inline int Alignment::_internal_fragment_size() const {
  return _impl_.fragment_.size();
}
inline int Alignment::fragment_size() const {
  return _internal_fragment_size();
}
inline void Alignment::clear_fragment() {
  _impl_.fragment_.Clear();
}
inline ::vg::Path* Alignment::mutable_fragment(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment)
  return _impl_.fragment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >*
Alignment::mutable_fragment() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.fragment)
  return &_impl_.fragment_;
}
inline const ::vg::Path& Alignment::_internal_fragment(int index) const {
  return _impl_.fragment_.Get(index);
}
inline const ::vg::Path& Alignment::fragment(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment)
  return _internal_fragment(index);
}
inline ::vg::Path* Alignment::_internal_add_fragment() {
  return _impl_.fragment_.Add();
}
inline ::vg::Path* Alignment::add_fragment() {
  ::vg::Path* _add = _internal_add_fragment();
  // @@protoc_insertion_point(field_add:vg.Alignment.fragment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >&
Alignment::fragment() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.fragment)
  return _impl_.fragment_;
}

// repeated .vg.Locus locus = 18;
inline int Alignment::_internal_locus_size() const {
  return _impl_.locus_.size();
}
inline int Alignment::locus_size() const {
  return _internal_locus_size();
}
inline void Alignment::clear_locus() {
  _impl_.locus_.Clear();
}
inline ::vg::Locus* Alignment::mutable_locus(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.locus)
  return _impl_.locus_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Locus >*
Alignment::mutable_locus() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.locus)
  return &_impl_.locus_;
}
inline const ::vg::Locus& Alignment::_internal_locus(int index) const {
  return _impl_.locus_.Get(index);
}
inline const ::vg::Locus& Alignment::locus(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.locus)
  return _internal_locus(index);
}
inline ::vg::Locus* Alignment::_internal_add_locus() {
  return _impl_.locus_.Add();
}
inline ::vg::Locus* Alignment::add_locus() {
  ::vg::Locus* _add = _internal_add_locus();
  // @@protoc_insertion_point(field_add:vg.Alignment.locus)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Locus >&
Alignment::locus() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.locus)
  return _impl_.locus_;
}

// repeated .vg.Position refpos = 19;
inline int Alignment::_internal_refpos_size() const {
  return _impl_.refpos_.size();
}
inline int Alignment::refpos_size() const {
  return _internal_refpos_size();
}
inline void Alignment::clear_refpos() {
  _impl_.refpos_.Clear();
}
inline ::vg::Position* Alignment::mutable_refpos(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Alignment.refpos)
  return _impl_.refpos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Position >*
Alignment::mutable_refpos() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.refpos)
  return &_impl_.refpos_;
}
inline const ::vg::Position& Alignment::_internal_refpos(int index) const {
  return _impl_.refpos_.Get(index);
}
inline const ::vg::Position& Alignment::refpos(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.refpos)
  return _internal_refpos(index);
}
inline ::vg::Position* Alignment::_internal_add_refpos() {
  return _impl_.refpos_.Add();
}
inline ::vg::Position* Alignment::add_refpos() {
  ::vg::Position* _add = _internal_add_refpos();
  // @@protoc_insertion_point(field_add:vg.Alignment.refpos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Position >&
Alignment::refpos() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.refpos)
  return _impl_.refpos_;
}

// bool read_paired = 20;
inline void Alignment::clear_read_paired() {
  _impl_.read_paired_ = false;
}
inline bool Alignment::_internal_read_paired() const {
  return _impl_.read_paired_;
}
inline bool Alignment::read_paired() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_paired)
  return _internal_read_paired();
}
inline void Alignment::_internal_set_read_paired(bool value) {
  
  _impl_.read_paired_ = value;
}
inline void Alignment::set_read_paired(bool value) {
  _internal_set_read_paired(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.read_paired)
}

// bool read_mapped = 21;
inline void Alignment::clear_read_mapped() {
  _impl_.read_mapped_ = false;
}
inline bool Alignment::_internal_read_mapped() const {
  return _impl_.read_mapped_;
}
inline bool Alignment::read_mapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_mapped)
  return _internal_read_mapped();
}
inline void Alignment::_internal_set_read_mapped(bool value) {
  
  _impl_.read_mapped_ = value;
}
inline void Alignment::set_read_mapped(bool value) {
  _internal_set_read_mapped(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.read_mapped)
}

// bool mate_unmapped = 22;
inline void Alignment::clear_mate_unmapped() {
  _impl_.mate_unmapped_ = false;
}
inline bool Alignment::_internal_mate_unmapped() const {
  return _impl_.mate_unmapped_;
}
inline bool Alignment::mate_unmapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_unmapped)
  return _internal_mate_unmapped();
}
inline void Alignment::_internal_set_mate_unmapped(bool value) {
  
  _impl_.mate_unmapped_ = value;
}
inline void Alignment::set_mate_unmapped(bool value) {
  _internal_set_mate_unmapped(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_unmapped)
}

// bool read_on_reverse_strand = 23;
inline void Alignment::clear_read_on_reverse_strand() {
  _impl_.read_on_reverse_strand_ = false;
}
inline bool Alignment::_internal_read_on_reverse_strand() const {
  return _impl_.read_on_reverse_strand_;
}
inline bool Alignment::read_on_reverse_strand() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.read_on_reverse_strand)
  return _internal_read_on_reverse_strand();
}
inline void Alignment::_internal_set_read_on_reverse_strand(bool value) {
  
  _impl_.read_on_reverse_strand_ = value;
}
inline void Alignment::set_read_on_reverse_strand(bool value) {
  _internal_set_read_on_reverse_strand(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.read_on_reverse_strand)
}

// bool mate_on_reverse_strand = 24;
inline void Alignment::clear_mate_on_reverse_strand() {
  _impl_.mate_on_reverse_strand_ = false;
}
inline bool Alignment::_internal_mate_on_reverse_strand() const {
  return _impl_.mate_on_reverse_strand_;
}
inline bool Alignment::mate_on_reverse_strand() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_on_reverse_strand)
  return _internal_mate_on_reverse_strand();
}
inline void Alignment::_internal_set_mate_on_reverse_strand(bool value) {
  
  _impl_.mate_on_reverse_strand_ = value;
}
inline void Alignment::set_mate_on_reverse_strand(bool value) {
  _internal_set_mate_on_reverse_strand(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_on_reverse_strand)
}

// bool soft_clipped = 25;
inline void Alignment::clear_soft_clipped() {
  _impl_.soft_clipped_ = false;
}
inline bool Alignment::_internal_soft_clipped() const {
  return _impl_.soft_clipped_;
}
inline bool Alignment::soft_clipped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.soft_clipped)
  return _internal_soft_clipped();
}
inline void Alignment::_internal_set_soft_clipped(bool value) {
  
  _impl_.soft_clipped_ = value;
}
inline void Alignment::set_soft_clipped(bool value) {
  _internal_set_soft_clipped(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.soft_clipped)
}

// bool discordant_insert_size = 26;
inline void Alignment::clear_discordant_insert_size() {
  _impl_.discordant_insert_size_ = false;
}
inline bool Alignment::_internal_discordant_insert_size() const {
  return _impl_.discordant_insert_size_;
}
inline bool Alignment::discordant_insert_size() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.discordant_insert_size)
  return _internal_discordant_insert_size();
}
inline void Alignment::_internal_set_discordant_insert_size(bool value) {
  
  _impl_.discordant_insert_size_ = value;
}
inline void Alignment::set_discordant_insert_size(bool value) {
  _internal_set_discordant_insert_size(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.discordant_insert_size)
}

// double uniqueness = 27;
inline void Alignment::clear_uniqueness() {
  _impl_.uniqueness_ = 0;
}
inline double Alignment::_internal_uniqueness() const {
  return _impl_.uniqueness_;
}
inline double Alignment::uniqueness() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.uniqueness)
  return _internal_uniqueness();
}
inline void Alignment::_internal_set_uniqueness(double value) {
  
  _impl_.uniqueness_ = value;
}
inline void Alignment::set_uniqueness(double value) {
  _internal_set_uniqueness(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.uniqueness)
}

// double correct = 28;
inline void Alignment::clear_correct() {
  _impl_.correct_ = 0;
}
inline double Alignment::_internal_correct() const {
  return _impl_.correct_;
}
inline double Alignment::correct() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.correct)
  return _internal_correct();
}
inline void Alignment::_internal_set_correct(double value) {
  
  _impl_.correct_ = value;
}
inline void Alignment::set_correct(double value) {
  _internal_set_correct(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.correct)
}

// repeated int32 secondary_score = 29;
inline int Alignment::_internal_secondary_score_size() const {
  return _impl_.secondary_score_.size();
}
inline int Alignment::secondary_score_size() const {
  return _internal_secondary_score_size();
}
inline void Alignment::clear_secondary_score() {
  _impl_.secondary_score_.Clear();
}
inline int32_t Alignment::_internal_secondary_score(int index) const {
  return _impl_.secondary_score_.Get(index);
}
inline int32_t Alignment::secondary_score(int index) const {
  // @@protoc_insertion_point(field_get:vg.Alignment.secondary_score)
  return _internal_secondary_score(index);
}
inline void Alignment::set_secondary_score(int index, int32_t value) {
  _impl_.secondary_score_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Alignment.secondary_score)
}
inline void Alignment::_internal_add_secondary_score(int32_t value) {
  _impl_.secondary_score_.Add(value);
}
inline void Alignment::add_secondary_score(int32_t value) {
  _internal_add_secondary_score(value);
  // @@protoc_insertion_point(field_add:vg.Alignment.secondary_score)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Alignment::_internal_secondary_score() const {
  return _impl_.secondary_score_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Alignment::secondary_score() const {
  // @@protoc_insertion_point(field_list:vg.Alignment.secondary_score)
  return _internal_secondary_score();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Alignment::_internal_mutable_secondary_score() {
  return &_impl_.secondary_score_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Alignment::mutable_secondary_score() {
  // @@protoc_insertion_point(field_mutable_list:vg.Alignment.secondary_score)
  return _internal_mutable_secondary_score();
}

// double fragment_score = 30;
inline void Alignment::clear_fragment_score() {
  _impl_.fragment_score_ = 0;
}
inline double Alignment::_internal_fragment_score() const {
  return _impl_.fragment_score_;
}
inline double Alignment::fragment_score() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_score)
  return _internal_fragment_score();
}
inline void Alignment::_internal_set_fragment_score(double value) {
  
  _impl_.fragment_score_ = value;
}
inline void Alignment::set_fragment_score(double value) {
  _internal_set_fragment_score(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.fragment_score)
}

// bool mate_mapped_to_disjoint_subgraph = 31;
inline void Alignment::clear_mate_mapped_to_disjoint_subgraph() {
  _impl_.mate_mapped_to_disjoint_subgraph_ = false;
}
inline bool Alignment::_internal_mate_mapped_to_disjoint_subgraph() const {
  return _impl_.mate_mapped_to_disjoint_subgraph_;
}
inline bool Alignment::mate_mapped_to_disjoint_subgraph() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.mate_mapped_to_disjoint_subgraph)
  return _internal_mate_mapped_to_disjoint_subgraph();
}
inline void Alignment::_internal_set_mate_mapped_to_disjoint_subgraph(bool value) {
  
  _impl_.mate_mapped_to_disjoint_subgraph_ = value;
}
inline void Alignment::set_mate_mapped_to_disjoint_subgraph(bool value) {
  _internal_set_mate_mapped_to_disjoint_subgraph(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.mate_mapped_to_disjoint_subgraph)
}

// string fragment_length_distribution = 32;
inline void Alignment::clear_fragment_length_distribution() {
  _impl_.fragment_length_distribution_.ClearToEmpty();
}
inline const std::string& Alignment::fragment_length_distribution() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.fragment_length_distribution)
  return _internal_fragment_length_distribution();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alignment::set_fragment_length_distribution(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fragment_length_distribution_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Alignment.fragment_length_distribution)
}
inline std::string* Alignment::mutable_fragment_length_distribution() {
  std::string* _s = _internal_mutable_fragment_length_distribution();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.fragment_length_distribution)
  return _s;
}
inline const std::string& Alignment::_internal_fragment_length_distribution() const {
  return _impl_.fragment_length_distribution_.Get();
}
inline void Alignment::_internal_set_fragment_length_distribution(const std::string& value) {
  
  _impl_.fragment_length_distribution_.Set(value, GetArenaForAllocation());
}
inline std::string* Alignment::_internal_mutable_fragment_length_distribution() {
  
  return _impl_.fragment_length_distribution_.Mutable(GetArenaForAllocation());
}
inline std::string* Alignment::release_fragment_length_distribution() {
  // @@protoc_insertion_point(field_release:vg.Alignment.fragment_length_distribution)
  return _impl_.fragment_length_distribution_.Release();
}
inline void Alignment::set_allocated_fragment_length_distribution(std::string* fragment_length_distribution) {
  if (fragment_length_distribution != nullptr) {
    
  } else {
    
  }
  _impl_.fragment_length_distribution_.SetAllocated(fragment_length_distribution, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fragment_length_distribution_.IsDefault()) {
    _impl_.fragment_length_distribution_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.fragment_length_distribution)
}

// bool haplotype_scored = 33;
inline void Alignment::clear_haplotype_scored() {
  _impl_.haplotype_scored_ = false;
}
inline bool Alignment::_internal_haplotype_scored() const {
  return _impl_.haplotype_scored_;
}
inline bool Alignment::haplotype_scored() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.haplotype_scored)
  return _internal_haplotype_scored();
}
inline void Alignment::_internal_set_haplotype_scored(bool value) {
  
  _impl_.haplotype_scored_ = value;
}
inline void Alignment::set_haplotype_scored(bool value) {
  _internal_set_haplotype_scored(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.haplotype_scored)
}

// double haplotype_logprob = 34;
inline void Alignment::clear_haplotype_logprob() {
  _impl_.haplotype_logprob_ = 0;
}
inline double Alignment::_internal_haplotype_logprob() const {
  return _impl_.haplotype_logprob_;
}
inline double Alignment::haplotype_logprob() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.haplotype_logprob)
  return _internal_haplotype_logprob();
}
inline void Alignment::_internal_set_haplotype_logprob(double value) {
  
  _impl_.haplotype_logprob_ = value;
}
inline void Alignment::set_haplotype_logprob(double value) {
  _internal_set_haplotype_logprob(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.haplotype_logprob)
}

// double time_used = 35;
inline void Alignment::clear_time_used() {
  _impl_.time_used_ = 0;
}
inline double Alignment::_internal_time_used() const {
  return _impl_.time_used_;
}
inline double Alignment::time_used() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.time_used)
  return _internal_time_used();
}
inline void Alignment::_internal_set_time_used(double value) {
  
  _impl_.time_used_ = value;
}
inline void Alignment::set_time_used(double value) {
  _internal_set_time_used(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.time_used)
}

// .vg.Position to_correct = 36;
inline bool Alignment::_internal_has_to_correct() const {
  return this != internal_default_instance() && _impl_.to_correct_ != nullptr;
}
inline bool Alignment::has_to_correct() const {
  return _internal_has_to_correct();
}
inline void Alignment::clear_to_correct() {
  if (GetArenaForAllocation() == nullptr && _impl_.to_correct_ != nullptr) {
    delete _impl_.to_correct_;
  }
  _impl_.to_correct_ = nullptr;
}
inline const ::vg::Position& Alignment::_internal_to_correct() const {
  const ::vg::Position* p = _impl_.to_correct_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Position&>(
      ::vg::_Position_default_instance_);
}
inline const ::vg::Position& Alignment::to_correct() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.to_correct)
  return _internal_to_correct();
}
inline void Alignment::unsafe_arena_set_allocated_to_correct(
    ::vg::Position* to_correct) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_correct_);
  }
  _impl_.to_correct_ = to_correct;
  if (to_correct) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Alignment.to_correct)
}
inline ::vg::Position* Alignment::release_to_correct() {
  
  ::vg::Position* temp = _impl_.to_correct_;
  _impl_.to_correct_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Position* Alignment::unsafe_arena_release_to_correct() {
  // @@protoc_insertion_point(field_release:vg.Alignment.to_correct)
  
  ::vg::Position* temp = _impl_.to_correct_;
  _impl_.to_correct_ = nullptr;
  return temp;
}
inline ::vg::Position* Alignment::_internal_mutable_to_correct() {
  
  if (_impl_.to_correct_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Position>(GetArenaForAllocation());
    _impl_.to_correct_ = p;
  }
  return _impl_.to_correct_;
}
inline ::vg::Position* Alignment::mutable_to_correct() {
  ::vg::Position* _msg = _internal_mutable_to_correct();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.to_correct)
  return _msg;
}
inline void Alignment::set_allocated_to_correct(::vg::Position* to_correct) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_correct_;
  }
  if (to_correct) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to_correct);
    if (message_arena != submessage_arena) {
      to_correct = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to_correct, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_correct_ = to_correct;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.to_correct)
}

// bool correctly_mapped = 37;
inline void Alignment::clear_correctly_mapped() {
  _impl_.correctly_mapped_ = false;
}
inline bool Alignment::_internal_correctly_mapped() const {
  return _impl_.correctly_mapped_;
}
inline bool Alignment::correctly_mapped() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.correctly_mapped)
  return _internal_correctly_mapped();
}
inline void Alignment::_internal_set_correctly_mapped(bool value) {
  
  _impl_.correctly_mapped_ = value;
}
inline void Alignment::set_correctly_mapped(bool value) {
  _internal_set_correctly_mapped(value);
  // @@protoc_insertion_point(field_set:vg.Alignment.correctly_mapped)
}

// .google.protobuf.Struct annotation = 100;
inline bool Alignment::_internal_has_annotation() const {
  return this != internal_default_instance() && _impl_.annotation_ != nullptr;
}
inline bool Alignment::has_annotation() const {
  return _internal_has_annotation();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Alignment::_internal_annotation() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& Alignment::annotation() const {
  // @@protoc_insertion_point(field_get:vg.Alignment.annotation)
  return _internal_annotation();
}
inline void Alignment::unsafe_arena_set_allocated_annotation(
    ::PROTOBUF_NAMESPACE_ID::Struct* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  _impl_.annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Alignment.annotation)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Alignment::release_annotation() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Alignment::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:vg.Alignment.annotation)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Alignment::_internal_mutable_annotation() {
  
  if (_impl_.annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.annotation_ = p;
  }
  return _impl_.annotation_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* Alignment::mutable_annotation() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:vg.Alignment.annotation)
  return _msg;
}
inline void Alignment::set_allocated_annotation(::PROTOBUF_NAMESPACE_ID::Struct* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation));
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:vg.Alignment.annotation)
}

// -------------------------------------------------------------------

// MultipathAlignment

// string sequence = 1;
inline void MultipathAlignment::clear_sequence() {
  _impl_.sequence_.ClearToEmpty();
}
inline const std::string& MultipathAlignment::sequence() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.sequence)
  return _internal_sequence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultipathAlignment::set_sequence(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.sequence)
}
inline std::string* MultipathAlignment::mutable_sequence() {
  std::string* _s = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.sequence)
  return _s;
}
inline const std::string& MultipathAlignment::_internal_sequence() const {
  return _impl_.sequence_.Get();
}
inline void MultipathAlignment::_internal_set_sequence(const std::string& value) {
  
  _impl_.sequence_.Set(value, GetArenaForAllocation());
}
inline std::string* MultipathAlignment::_internal_mutable_sequence() {
  
  return _impl_.sequence_.Mutable(GetArenaForAllocation());
}
inline std::string* MultipathAlignment::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.sequence)
  return _impl_.sequence_.Release();
}
inline void MultipathAlignment::set_allocated_sequence(std::string* sequence) {
  if (sequence != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_.SetAllocated(sequence, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_.IsDefault()) {
    _impl_.sequence_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.sequence)
}

// bytes quality = 2;
inline void MultipathAlignment::clear_quality() {
  _impl_.quality_.ClearToEmpty();
}
inline const std::string& MultipathAlignment::quality() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.quality)
  return _internal_quality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultipathAlignment::set_quality(ArgT0&& arg0, ArgT... args) {
 
 _impl_.quality_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.quality)
}
inline std::string* MultipathAlignment::mutable_quality() {
  std::string* _s = _internal_mutable_quality();
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.quality)
  return _s;
}
inline const std::string& MultipathAlignment::_internal_quality() const {
  return _impl_.quality_.Get();
}
inline void MultipathAlignment::_internal_set_quality(const std::string& value) {
  
  _impl_.quality_.Set(value, GetArenaForAllocation());
}
inline std::string* MultipathAlignment::_internal_mutable_quality() {
  
  return _impl_.quality_.Mutable(GetArenaForAllocation());
}
inline std::string* MultipathAlignment::release_quality() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.quality)
  return _impl_.quality_.Release();
}
inline void MultipathAlignment::set_allocated_quality(std::string* quality) {
  if (quality != nullptr) {
    
  } else {
    
  }
  _impl_.quality_.SetAllocated(quality, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.quality_.IsDefault()) {
    _impl_.quality_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.quality)
}

// string name = 3;
inline void MultipathAlignment::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MultipathAlignment::name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultipathAlignment::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.name)
}
inline std::string* MultipathAlignment::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.name)
  return _s;
}
inline const std::string& MultipathAlignment::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MultipathAlignment::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MultipathAlignment::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MultipathAlignment::release_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.name)
  return _impl_.name_.Release();
}
inline void MultipathAlignment::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.name)
}

// string sample_name = 4;
inline void MultipathAlignment::clear_sample_name() {
  _impl_.sample_name_.ClearToEmpty();
}
inline const std::string& MultipathAlignment::sample_name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.sample_name)
  return _internal_sample_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultipathAlignment::set_sample_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sample_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.sample_name)
}
inline std::string* MultipathAlignment::mutable_sample_name() {
  std::string* _s = _internal_mutable_sample_name();
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.sample_name)
  return _s;
}
inline const std::string& MultipathAlignment::_internal_sample_name() const {
  return _impl_.sample_name_.Get();
}
inline void MultipathAlignment::_internal_set_sample_name(const std::string& value) {
  
  _impl_.sample_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MultipathAlignment::_internal_mutable_sample_name() {
  
  return _impl_.sample_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MultipathAlignment::release_sample_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.sample_name)
  return _impl_.sample_name_.Release();
}
inline void MultipathAlignment::set_allocated_sample_name(std::string* sample_name) {
  if (sample_name != nullptr) {
    
  } else {
    
  }
  _impl_.sample_name_.SetAllocated(sample_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sample_name_.IsDefault()) {
    _impl_.sample_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.sample_name)
}

// string read_group = 5;
inline void MultipathAlignment::clear_read_group() {
  _impl_.read_group_.ClearToEmpty();
}
inline const std::string& MultipathAlignment::read_group() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.read_group)
  return _internal_read_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultipathAlignment::set_read_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.read_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.read_group)
}
inline std::string* MultipathAlignment::mutable_read_group() {
  std::string* _s = _internal_mutable_read_group();
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.read_group)
  return _s;
}
inline const std::string& MultipathAlignment::_internal_read_group() const {
  return _impl_.read_group_.Get();
}
inline void MultipathAlignment::_internal_set_read_group(const std::string& value) {
  
  _impl_.read_group_.Set(value, GetArenaForAllocation());
}
inline std::string* MultipathAlignment::_internal_mutable_read_group() {
  
  return _impl_.read_group_.Mutable(GetArenaForAllocation());
}
inline std::string* MultipathAlignment::release_read_group() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.read_group)
  return _impl_.read_group_.Release();
}
inline void MultipathAlignment::set_allocated_read_group(std::string* read_group) {
  if (read_group != nullptr) {
    
  } else {
    
  }
  _impl_.read_group_.SetAllocated(read_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.read_group_.IsDefault()) {
    _impl_.read_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.read_group)
}

// repeated .vg.Subpath subpath = 6;
inline int MultipathAlignment::_internal_subpath_size() const {
  return _impl_.subpath_.size();
}
inline int MultipathAlignment::subpath_size() const {
  return _internal_subpath_size();
}
inline void MultipathAlignment::clear_subpath() {
  _impl_.subpath_.Clear();
}
inline ::vg::Subpath* MultipathAlignment::mutable_subpath(int index) {
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.subpath)
  return _impl_.subpath_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Subpath >*
MultipathAlignment::mutable_subpath() {
  // @@protoc_insertion_point(field_mutable_list:vg.MultipathAlignment.subpath)
  return &_impl_.subpath_;
}
inline const ::vg::Subpath& MultipathAlignment::_internal_subpath(int index) const {
  return _impl_.subpath_.Get(index);
}
inline const ::vg::Subpath& MultipathAlignment::subpath(int index) const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.subpath)
  return _internal_subpath(index);
}
inline ::vg::Subpath* MultipathAlignment::_internal_add_subpath() {
  return _impl_.subpath_.Add();
}
inline ::vg::Subpath* MultipathAlignment::add_subpath() {
  ::vg::Subpath* _add = _internal_add_subpath();
  // @@protoc_insertion_point(field_add:vg.MultipathAlignment.subpath)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Subpath >&
MultipathAlignment::subpath() const {
  // @@protoc_insertion_point(field_list:vg.MultipathAlignment.subpath)
  return _impl_.subpath_;
}

// int32 mapping_quality = 7;
inline void MultipathAlignment::clear_mapping_quality() {
  _impl_.mapping_quality_ = 0;
}
inline int32_t MultipathAlignment::_internal_mapping_quality() const {
  return _impl_.mapping_quality_;
}
inline int32_t MultipathAlignment::mapping_quality() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.mapping_quality)
  return _internal_mapping_quality();
}
inline void MultipathAlignment::_internal_set_mapping_quality(int32_t value) {
  
  _impl_.mapping_quality_ = value;
}
inline void MultipathAlignment::set_mapping_quality(int32_t value) {
  _internal_set_mapping_quality(value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.mapping_quality)
}

// repeated uint32 start = 8;
inline int MultipathAlignment::_internal_start_size() const {
  return _impl_.start_.size();
}
inline int MultipathAlignment::start_size() const {
  return _internal_start_size();
}
inline void MultipathAlignment::clear_start() {
  _impl_.start_.Clear();
}
inline uint32_t MultipathAlignment::_internal_start(int index) const {
  return _impl_.start_.Get(index);
}
inline uint32_t MultipathAlignment::start(int index) const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.start)
  return _internal_start(index);
}
inline void MultipathAlignment::set_start(int index, uint32_t value) {
  _impl_.start_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.start)
}
inline void MultipathAlignment::_internal_add_start(uint32_t value) {
  _impl_.start_.Add(value);
}
inline void MultipathAlignment::add_start(uint32_t value) {
  _internal_add_start(value);
  // @@protoc_insertion_point(field_add:vg.MultipathAlignment.start)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MultipathAlignment::_internal_start() const {
  return _impl_.start_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
MultipathAlignment::start() const {
  // @@protoc_insertion_point(field_list:vg.MultipathAlignment.start)
  return _internal_start();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MultipathAlignment::_internal_mutable_start() {
  return &_impl_.start_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
MultipathAlignment::mutable_start() {
  // @@protoc_insertion_point(field_mutable_list:vg.MultipathAlignment.start)
  return _internal_mutable_start();
}

// string paired_read_name = 9;
inline void MultipathAlignment::clear_paired_read_name() {
  _impl_.paired_read_name_.ClearToEmpty();
}
inline const std::string& MultipathAlignment::paired_read_name() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.paired_read_name)
  return _internal_paired_read_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultipathAlignment::set_paired_read_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.paired_read_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.MultipathAlignment.paired_read_name)
}
inline std::string* MultipathAlignment::mutable_paired_read_name() {
  std::string* _s = _internal_mutable_paired_read_name();
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.paired_read_name)
  return _s;
}
inline const std::string& MultipathAlignment::_internal_paired_read_name() const {
  return _impl_.paired_read_name_.Get();
}
inline void MultipathAlignment::_internal_set_paired_read_name(const std::string& value) {
  
  _impl_.paired_read_name_.Set(value, GetArenaForAllocation());
}
inline std::string* MultipathAlignment::_internal_mutable_paired_read_name() {
  
  return _impl_.paired_read_name_.Mutable(GetArenaForAllocation());
}
inline std::string* MultipathAlignment::release_paired_read_name() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.paired_read_name)
  return _impl_.paired_read_name_.Release();
}
inline void MultipathAlignment::set_allocated_paired_read_name(std::string* paired_read_name) {
  if (paired_read_name != nullptr) {
    
  } else {
    
  }
  _impl_.paired_read_name_.SetAllocated(paired_read_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.paired_read_name_.IsDefault()) {
    _impl_.paired_read_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.paired_read_name)
}

// .google.protobuf.Struct annotation = 100;
inline bool MultipathAlignment::_internal_has_annotation() const {
  return this != internal_default_instance() && _impl_.annotation_ != nullptr;
}
inline bool MultipathAlignment::has_annotation() const {
  return _internal_has_annotation();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MultipathAlignment::_internal_annotation() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.annotation_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& MultipathAlignment::annotation() const {
  // @@protoc_insertion_point(field_get:vg.MultipathAlignment.annotation)
  return _internal_annotation();
}
inline void MultipathAlignment::unsafe_arena_set_allocated_annotation(
    ::PROTOBUF_NAMESPACE_ID::Struct* annotation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  _impl_.annotation_ = annotation;
  if (annotation) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.MultipathAlignment.annotation)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MultipathAlignment::release_annotation() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MultipathAlignment::unsafe_arena_release_annotation() {
  // @@protoc_insertion_point(field_release:vg.MultipathAlignment.annotation)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.annotation_;
  _impl_.annotation_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MultipathAlignment::_internal_mutable_annotation() {
  
  if (_impl_.annotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.annotation_ = p;
  }
  return _impl_.annotation_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* MultipathAlignment::mutable_annotation() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_annotation();
  // @@protoc_insertion_point(field_mutable:vg.MultipathAlignment.annotation)
  return _msg;
}
inline void MultipathAlignment::set_allocated_annotation(::PROTOBUF_NAMESPACE_ID::Struct* annotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.annotation_);
  }
  if (annotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(annotation));
    if (message_arena != submessage_arena) {
      annotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, annotation, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.annotation_ = annotation;
  // @@protoc_insertion_point(field_set_allocated:vg.MultipathAlignment.annotation)
}

// -------------------------------------------------------------------

// Subpath

// .vg.Path path = 1;
inline bool Subpath::_internal_has_path() const {
  return this != internal_default_instance() && _impl_.path_ != nullptr;
}
inline bool Subpath::has_path() const {
  return _internal_has_path();
}
inline void Subpath::clear_path() {
  if (GetArenaForAllocation() == nullptr && _impl_.path_ != nullptr) {
    delete _impl_.path_;
  }
  _impl_.path_ = nullptr;
}
inline const ::vg::Path& Subpath::_internal_path() const {
  const ::vg::Path* p = _impl_.path_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Path&>(
      ::vg::_Path_default_instance_);
}
inline const ::vg::Path& Subpath::path() const {
  // @@protoc_insertion_point(field_get:vg.Subpath.path)
  return _internal_path();
}
inline void Subpath::unsafe_arena_set_allocated_path(
    ::vg::Path* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_);
  }
  _impl_.path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Subpath.path)
}
inline ::vg::Path* Subpath::release_path() {
  
  ::vg::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Path* Subpath::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:vg.Subpath.path)
  
  ::vg::Path* temp = _impl_.path_;
  _impl_.path_ = nullptr;
  return temp;
}
inline ::vg::Path* Subpath::_internal_mutable_path() {
  
  if (_impl_.path_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaForAllocation());
    _impl_.path_ = p;
  }
  return _impl_.path_;
}
inline ::vg::Path* Subpath::mutable_path() {
  ::vg::Path* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:vg.Subpath.path)
  return _msg;
}
inline void Subpath::set_allocated_path(::vg::Path* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.path_ = path;
  // @@protoc_insertion_point(field_set_allocated:vg.Subpath.path)
}

// repeated uint32 next = 2;
inline int Subpath::_internal_next_size() const {
  return _impl_.next_.size();
}
inline int Subpath::next_size() const {
  return _internal_next_size();
}
inline void Subpath::clear_next() {
  _impl_.next_.Clear();
}
inline uint32_t Subpath::_internal_next(int index) const {
  return _impl_.next_.Get(index);
}
inline uint32_t Subpath::next(int index) const {
  // @@protoc_insertion_point(field_get:vg.Subpath.next)
  return _internal_next(index);
}
inline void Subpath::set_next(int index, uint32_t value) {
  _impl_.next_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Subpath.next)
}
inline void Subpath::_internal_add_next(uint32_t value) {
  _impl_.next_.Add(value);
}
inline void Subpath::add_next(uint32_t value) {
  _internal_add_next(value);
  // @@protoc_insertion_point(field_add:vg.Subpath.next)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Subpath::_internal_next() const {
  return _impl_.next_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Subpath::next() const {
  // @@protoc_insertion_point(field_list:vg.Subpath.next)
  return _internal_next();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Subpath::_internal_mutable_next() {
  return &_impl_.next_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Subpath::mutable_next() {
  // @@protoc_insertion_point(field_mutable_list:vg.Subpath.next)
  return _internal_mutable_next();
}

// int32 score = 3;
inline void Subpath::clear_score() {
  _impl_.score_ = 0;
}
inline int32_t Subpath::_internal_score() const {
  return _impl_.score_;
}
inline int32_t Subpath::score() const {
  // @@protoc_insertion_point(field_get:vg.Subpath.score)
  return _internal_score();
}
inline void Subpath::_internal_set_score(int32_t value) {
  
  _impl_.score_ = value;
}
inline void Subpath::set_score(int32_t value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:vg.Subpath.score)
}

// -------------------------------------------------------------------

// KmerMatch

// string sequence = 1;
inline void KmerMatch::clear_sequence() {
  _impl_.sequence_.ClearToEmpty();
}
inline const std::string& KmerMatch::sequence() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.sequence)
  return _internal_sequence();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KmerMatch::set_sequence(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sequence_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.KmerMatch.sequence)
}
inline std::string* KmerMatch::mutable_sequence() {
  std::string* _s = _internal_mutable_sequence();
  // @@protoc_insertion_point(field_mutable:vg.KmerMatch.sequence)
  return _s;
}
inline const std::string& KmerMatch::_internal_sequence() const {
  return _impl_.sequence_.Get();
}
inline void KmerMatch::_internal_set_sequence(const std::string& value) {
  
  _impl_.sequence_.Set(value, GetArenaForAllocation());
}
inline std::string* KmerMatch::_internal_mutable_sequence() {
  
  return _impl_.sequence_.Mutable(GetArenaForAllocation());
}
inline std::string* KmerMatch::release_sequence() {
  // @@protoc_insertion_point(field_release:vg.KmerMatch.sequence)
  return _impl_.sequence_.Release();
}
inline void KmerMatch::set_allocated_sequence(std::string* sequence) {
  if (sequence != nullptr) {
    
  } else {
    
  }
  _impl_.sequence_.SetAllocated(sequence, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sequence_.IsDefault()) {
    _impl_.sequence_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.KmerMatch.sequence)
}

// int64 node_id = 2;
inline void KmerMatch::clear_node_id() {
  _impl_.node_id_ = int64_t{0};
}
inline int64_t KmerMatch::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int64_t KmerMatch::node_id() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.node_id)
  return _internal_node_id();
}
inline void KmerMatch::_internal_set_node_id(int64_t value) {
  
  _impl_.node_id_ = value;
}
inline void KmerMatch::set_node_id(int64_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:vg.KmerMatch.node_id)
}

// sint32 position = 3;
inline void KmerMatch::clear_position() {
  _impl_.position_ = 0;
}
inline int32_t KmerMatch::_internal_position() const {
  return _impl_.position_;
}
inline int32_t KmerMatch::position() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.position)
  return _internal_position();
}
inline void KmerMatch::_internal_set_position(int32_t value) {
  
  _impl_.position_ = value;
}
inline void KmerMatch::set_position(int32_t value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:vg.KmerMatch.position)
}

// bool backward = 4;
inline void KmerMatch::clear_backward() {
  _impl_.backward_ = false;
}
inline bool KmerMatch::_internal_backward() const {
  return _impl_.backward_;
}
inline bool KmerMatch::backward() const {
  // @@protoc_insertion_point(field_get:vg.KmerMatch.backward)
  return _internal_backward();
}
inline void KmerMatch::_internal_set_backward(bool value) {
  
  _impl_.backward_ = value;
}
inline void KmerMatch::set_backward(bool value) {
  _internal_set_backward(value);
  // @@protoc_insertion_point(field_set:vg.KmerMatch.backward)
}

// -------------------------------------------------------------------

// BasePileup

// int32 ref_base = 1;
inline void BasePileup::clear_ref_base() {
  _impl_.ref_base_ = 0;
}
inline int32_t BasePileup::_internal_ref_base() const {
  return _impl_.ref_base_;
}
inline int32_t BasePileup::ref_base() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.ref_base)
  return _internal_ref_base();
}
inline void BasePileup::_internal_set_ref_base(int32_t value) {
  
  _impl_.ref_base_ = value;
}
inline void BasePileup::set_ref_base(int32_t value) {
  _internal_set_ref_base(value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.ref_base)
}

// int32 num_bases = 2;
inline void BasePileup::clear_num_bases() {
  _impl_.num_bases_ = 0;
}
inline int32_t BasePileup::_internal_num_bases() const {
  return _impl_.num_bases_;
}
inline int32_t BasePileup::num_bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.num_bases)
  return _internal_num_bases();
}
inline void BasePileup::_internal_set_num_bases(int32_t value) {
  
  _impl_.num_bases_ = value;
}
inline void BasePileup::set_num_bases(int32_t value) {
  _internal_set_num_bases(value);
  // @@protoc_insertion_point(field_set:vg.BasePileup.num_bases)
}

// string bases = 3;
inline void BasePileup::clear_bases() {
  _impl_.bases_.ClearToEmpty();
}
inline const std::string& BasePileup::bases() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.bases)
  return _internal_bases();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePileup::set_bases(ArgT0&& arg0, ArgT... args) {
 
 _impl_.bases_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.BasePileup.bases)
}
inline std::string* BasePileup::mutable_bases() {
  std::string* _s = _internal_mutable_bases();
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.bases)
  return _s;
}
inline const std::string& BasePileup::_internal_bases() const {
  return _impl_.bases_.Get();
}
inline void BasePileup::_internal_set_bases(const std::string& value) {
  
  _impl_.bases_.Set(value, GetArenaForAllocation());
}
inline std::string* BasePileup::_internal_mutable_bases() {
  
  return _impl_.bases_.Mutable(GetArenaForAllocation());
}
inline std::string* BasePileup::release_bases() {
  // @@protoc_insertion_point(field_release:vg.BasePileup.bases)
  return _impl_.bases_.Release();
}
inline void BasePileup::set_allocated_bases(std::string* bases) {
  if (bases != nullptr) {
    
  } else {
    
  }
  _impl_.bases_.SetAllocated(bases, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.bases_.IsDefault()) {
    _impl_.bases_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.bases)
}

// bytes qualities = 4;
inline void BasePileup::clear_qualities() {
  _impl_.qualities_.ClearToEmpty();
}
inline const std::string& BasePileup::qualities() const {
  // @@protoc_insertion_point(field_get:vg.BasePileup.qualities)
  return _internal_qualities();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePileup::set_qualities(ArgT0&& arg0, ArgT... args) {
 
 _impl_.qualities_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.BasePileup.qualities)
}
inline std::string* BasePileup::mutable_qualities() {
  std::string* _s = _internal_mutable_qualities();
  // @@protoc_insertion_point(field_mutable:vg.BasePileup.qualities)
  return _s;
}
inline const std::string& BasePileup::_internal_qualities() const {
  return _impl_.qualities_.Get();
}
inline void BasePileup::_internal_set_qualities(const std::string& value) {
  
  _impl_.qualities_.Set(value, GetArenaForAllocation());
}
inline std::string* BasePileup::_internal_mutable_qualities() {
  
  return _impl_.qualities_.Mutable(GetArenaForAllocation());
}
inline std::string* BasePileup::release_qualities() {
  // @@protoc_insertion_point(field_release:vg.BasePileup.qualities)
  return _impl_.qualities_.Release();
}
inline void BasePileup::set_allocated_qualities(std::string* qualities) {
  if (qualities != nullptr) {
    
  } else {
    
  }
  _impl_.qualities_.SetAllocated(qualities, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.qualities_.IsDefault()) {
    _impl_.qualities_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.BasePileup.qualities)
}

// -------------------------------------------------------------------

// NodePileup

// int64 node_id = 1;
inline void NodePileup::clear_node_id() {
  _impl_.node_id_ = int64_t{0};
}
inline int64_t NodePileup::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int64_t NodePileup::node_id() const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.node_id)
  return _internal_node_id();
}
inline void NodePileup::_internal_set_node_id(int64_t value) {
  
  _impl_.node_id_ = value;
}
inline void NodePileup::set_node_id(int64_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:vg.NodePileup.node_id)
}

// repeated .vg.BasePileup base_pileup = 2;
inline int NodePileup::_internal_base_pileup_size() const {
  return _impl_.base_pileup_.size();
}
inline int NodePileup::base_pileup_size() const {
  return _internal_base_pileup_size();
}
inline void NodePileup::clear_base_pileup() {
  _impl_.base_pileup_.Clear();
}
inline ::vg::BasePileup* NodePileup::mutable_base_pileup(int index) {
  // @@protoc_insertion_point(field_mutable:vg.NodePileup.base_pileup)
  return _impl_.base_pileup_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::BasePileup >*
NodePileup::mutable_base_pileup() {
  // @@protoc_insertion_point(field_mutable_list:vg.NodePileup.base_pileup)
  return &_impl_.base_pileup_;
}
inline const ::vg::BasePileup& NodePileup::_internal_base_pileup(int index) const {
  return _impl_.base_pileup_.Get(index);
}
inline const ::vg::BasePileup& NodePileup::base_pileup(int index) const {
  // @@protoc_insertion_point(field_get:vg.NodePileup.base_pileup)
  return _internal_base_pileup(index);
}
inline ::vg::BasePileup* NodePileup::_internal_add_base_pileup() {
  return _impl_.base_pileup_.Add();
}
inline ::vg::BasePileup* NodePileup::add_base_pileup() {
  ::vg::BasePileup* _add = _internal_add_base_pileup();
  // @@protoc_insertion_point(field_add:vg.NodePileup.base_pileup)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::BasePileup >&
NodePileup::base_pileup() const {
  // @@protoc_insertion_point(field_list:vg.NodePileup.base_pileup)
  return _impl_.base_pileup_;
}

// -------------------------------------------------------------------

// EdgePileup

// .vg.Edge edge = 1;
inline bool EdgePileup::_internal_has_edge() const {
  return this != internal_default_instance() && _impl_.edge_ != nullptr;
}
inline bool EdgePileup::has_edge() const {
  return _internal_has_edge();
}
inline void EdgePileup::clear_edge() {
  if (GetArenaForAllocation() == nullptr && _impl_.edge_ != nullptr) {
    delete _impl_.edge_;
  }
  _impl_.edge_ = nullptr;
}
inline const ::vg::Edge& EdgePileup::_internal_edge() const {
  const ::vg::Edge* p = _impl_.edge_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Edge&>(
      ::vg::_Edge_default_instance_);
}
inline const ::vg::Edge& EdgePileup::edge() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.edge)
  return _internal_edge();
}
inline void EdgePileup::unsafe_arena_set_allocated_edge(
    ::vg::Edge* edge) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.edge_);
  }
  _impl_.edge_ = edge;
  if (edge) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.EdgePileup.edge)
}
inline ::vg::Edge* EdgePileup::release_edge() {
  
  ::vg::Edge* temp = _impl_.edge_;
  _impl_.edge_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Edge* EdgePileup::unsafe_arena_release_edge() {
  // @@protoc_insertion_point(field_release:vg.EdgePileup.edge)
  
  ::vg::Edge* temp = _impl_.edge_;
  _impl_.edge_ = nullptr;
  return temp;
}
inline ::vg::Edge* EdgePileup::_internal_mutable_edge() {
  
  if (_impl_.edge_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Edge>(GetArenaForAllocation());
    _impl_.edge_ = p;
  }
  return _impl_.edge_;
}
inline ::vg::Edge* EdgePileup::mutable_edge() {
  ::vg::Edge* _msg = _internal_mutable_edge();
  // @@protoc_insertion_point(field_mutable:vg.EdgePileup.edge)
  return _msg;
}
inline void EdgePileup::set_allocated_edge(::vg::Edge* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.edge_;
  }
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge);
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.edge_ = edge;
  // @@protoc_insertion_point(field_set_allocated:vg.EdgePileup.edge)
}

// int32 num_reads = 2;
inline void EdgePileup::clear_num_reads() {
  _impl_.num_reads_ = 0;
}
inline int32_t EdgePileup::_internal_num_reads() const {
  return _impl_.num_reads_;
}
inline int32_t EdgePileup::num_reads() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.num_reads)
  return _internal_num_reads();
}
inline void EdgePileup::_internal_set_num_reads(int32_t value) {
  
  _impl_.num_reads_ = value;
}
inline void EdgePileup::set_num_reads(int32_t value) {
  _internal_set_num_reads(value);
  // @@protoc_insertion_point(field_set:vg.EdgePileup.num_reads)
}

// int32 num_forward_reads = 3;
inline void EdgePileup::clear_num_forward_reads() {
  _impl_.num_forward_reads_ = 0;
}
inline int32_t EdgePileup::_internal_num_forward_reads() const {
  return _impl_.num_forward_reads_;
}
inline int32_t EdgePileup::num_forward_reads() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.num_forward_reads)
  return _internal_num_forward_reads();
}
inline void EdgePileup::_internal_set_num_forward_reads(int32_t value) {
  
  _impl_.num_forward_reads_ = value;
}
inline void EdgePileup::set_num_forward_reads(int32_t value) {
  _internal_set_num_forward_reads(value);
  // @@protoc_insertion_point(field_set:vg.EdgePileup.num_forward_reads)
}

// bytes qualities = 4;
inline void EdgePileup::clear_qualities() {
  _impl_.qualities_.ClearToEmpty();
}
inline const std::string& EdgePileup::qualities() const {
  // @@protoc_insertion_point(field_get:vg.EdgePileup.qualities)
  return _internal_qualities();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdgePileup::set_qualities(ArgT0&& arg0, ArgT... args) {
 
 _impl_.qualities_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.EdgePileup.qualities)
}
inline std::string* EdgePileup::mutable_qualities() {
  std::string* _s = _internal_mutable_qualities();
  // @@protoc_insertion_point(field_mutable:vg.EdgePileup.qualities)
  return _s;
}
inline const std::string& EdgePileup::_internal_qualities() const {
  return _impl_.qualities_.Get();
}
inline void EdgePileup::_internal_set_qualities(const std::string& value) {
  
  _impl_.qualities_.Set(value, GetArenaForAllocation());
}
inline std::string* EdgePileup::_internal_mutable_qualities() {
  
  return _impl_.qualities_.Mutable(GetArenaForAllocation());
}
inline std::string* EdgePileup::release_qualities() {
  // @@protoc_insertion_point(field_release:vg.EdgePileup.qualities)
  return _impl_.qualities_.Release();
}
inline void EdgePileup::set_allocated_qualities(std::string* qualities) {
  if (qualities != nullptr) {
    
  } else {
    
  }
  _impl_.qualities_.SetAllocated(qualities, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.qualities_.IsDefault()) {
    _impl_.qualities_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.EdgePileup.qualities)
}

// -------------------------------------------------------------------

// Pileup

// repeated .vg.NodePileup node_pileups = 1;
inline int Pileup::_internal_node_pileups_size() const {
  return _impl_.node_pileups_.size();
}
inline int Pileup::node_pileups_size() const {
  return _internal_node_pileups_size();
}
inline void Pileup::clear_node_pileups() {
  _impl_.node_pileups_.Clear();
}
inline ::vg::NodePileup* Pileup::mutable_node_pileups(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Pileup.node_pileups)
  return _impl_.node_pileups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::NodePileup >*
Pileup::mutable_node_pileups() {
  // @@protoc_insertion_point(field_mutable_list:vg.Pileup.node_pileups)
  return &_impl_.node_pileups_;
}
inline const ::vg::NodePileup& Pileup::_internal_node_pileups(int index) const {
  return _impl_.node_pileups_.Get(index);
}
inline const ::vg::NodePileup& Pileup::node_pileups(int index) const {
  // @@protoc_insertion_point(field_get:vg.Pileup.node_pileups)
  return _internal_node_pileups(index);
}
inline ::vg::NodePileup* Pileup::_internal_add_node_pileups() {
  return _impl_.node_pileups_.Add();
}
inline ::vg::NodePileup* Pileup::add_node_pileups() {
  ::vg::NodePileup* _add = _internal_add_node_pileups();
  // @@protoc_insertion_point(field_add:vg.Pileup.node_pileups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::NodePileup >&
Pileup::node_pileups() const {
  // @@protoc_insertion_point(field_list:vg.Pileup.node_pileups)
  return _impl_.node_pileups_;
}

// repeated .vg.EdgePileup edge_pileups = 2;
inline int Pileup::_internal_edge_pileups_size() const {
  return _impl_.edge_pileups_.size();
}
inline int Pileup::edge_pileups_size() const {
  return _internal_edge_pileups_size();
}
inline void Pileup::clear_edge_pileups() {
  _impl_.edge_pileups_.Clear();
}
inline ::vg::EdgePileup* Pileup::mutable_edge_pileups(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Pileup.edge_pileups)
  return _impl_.edge_pileups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::EdgePileup >*
Pileup::mutable_edge_pileups() {
  // @@protoc_insertion_point(field_mutable_list:vg.Pileup.edge_pileups)
  return &_impl_.edge_pileups_;
}
inline const ::vg::EdgePileup& Pileup::_internal_edge_pileups(int index) const {
  return _impl_.edge_pileups_.Get(index);
}
inline const ::vg::EdgePileup& Pileup::edge_pileups(int index) const {
  // @@protoc_insertion_point(field_get:vg.Pileup.edge_pileups)
  return _internal_edge_pileups(index);
}
inline ::vg::EdgePileup* Pileup::_internal_add_edge_pileups() {
  return _impl_.edge_pileups_.Add();
}
inline ::vg::EdgePileup* Pileup::add_edge_pileups() {
  ::vg::EdgePileup* _add = _internal_add_edge_pileups();
  // @@protoc_insertion_point(field_add:vg.Pileup.edge_pileups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::EdgePileup >&
Pileup::edge_pileups() const {
  // @@protoc_insertion_point(field_list:vg.Pileup.edge_pileups)
  return _impl_.edge_pileups_;
}

// -------------------------------------------------------------------

// Snarl

// .vg.SnarlType type = 1;
inline void Snarl::clear_type() {
  _impl_.type_ = 0;
}
inline ::vg::SnarlType Snarl::_internal_type() const {
  return static_cast< ::vg::SnarlType >(_impl_.type_);
}
inline ::vg::SnarlType Snarl::type() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.type)
  return _internal_type();
}
inline void Snarl::_internal_set_type(::vg::SnarlType value) {
  
  _impl_.type_ = value;
}
inline void Snarl::set_type(::vg::SnarlType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:vg.Snarl.type)
}

// .vg.Visit start = 2;
inline bool Snarl::_internal_has_start() const {
  return this != internal_default_instance() && _impl_.start_ != nullptr;
}
inline bool Snarl::has_start() const {
  return _internal_has_start();
}
inline void Snarl::clear_start() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
}
inline const ::vg::Visit& Snarl::_internal_start() const {
  const ::vg::Visit* p = _impl_.start_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Visit&>(
      ::vg::_Visit_default_instance_);
}
inline const ::vg::Visit& Snarl::start() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.start)
  return _internal_start();
}
inline void Snarl::unsafe_arena_set_allocated_start(
    ::vg::Visit* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
  }
  _impl_.start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Snarl.start)
}
inline ::vg::Visit* Snarl::release_start() {
  
  ::vg::Visit* temp = _impl_.start_;
  _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Visit* Snarl::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:vg.Snarl.start)
  
  ::vg::Visit* temp = _impl_.start_;
  _impl_.start_ = nullptr;
  return temp;
}
inline ::vg::Visit* Snarl::_internal_mutable_start() {
  
  if (_impl_.start_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Visit>(GetArenaForAllocation());
    _impl_.start_ = p;
  }
  return _impl_.start_;
}
inline ::vg::Visit* Snarl::mutable_start() {
  ::vg::Visit* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:vg.Snarl.start)
  return _msg;
}
inline void Snarl::set_allocated_start(::vg::Visit* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_ = start;
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.start)
}

// .vg.Visit end = 3;
inline bool Snarl::_internal_has_end() const {
  return this != internal_default_instance() && _impl_.end_ != nullptr;
}
inline bool Snarl::has_end() const {
  return _internal_has_end();
}
inline void Snarl::clear_end() {
  if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
    delete _impl_.end_;
  }
  _impl_.end_ = nullptr;
}
inline const ::vg::Visit& Snarl::_internal_end() const {
  const ::vg::Visit* p = _impl_.end_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Visit&>(
      ::vg::_Visit_default_instance_);
}
inline const ::vg::Visit& Snarl::end() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.end)
  return _internal_end();
}
inline void Snarl::unsafe_arena_set_allocated_end(
    ::vg::Visit* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
  }
  _impl_.end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Snarl.end)
}
inline ::vg::Visit* Snarl::release_end() {
  
  ::vg::Visit* temp = _impl_.end_;
  _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Visit* Snarl::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:vg.Snarl.end)
  
  ::vg::Visit* temp = _impl_.end_;
  _impl_.end_ = nullptr;
  return temp;
}
inline ::vg::Visit* Snarl::_internal_mutable_end() {
  
  if (_impl_.end_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Visit>(GetArenaForAllocation());
    _impl_.end_ = p;
  }
  return _impl_.end_;
}
inline ::vg::Visit* Snarl::mutable_end() {
  ::vg::Visit* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:vg.Snarl.end)
  return _msg;
}
inline void Snarl::set_allocated_end(::vg::Visit* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.end_ = end;
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.end)
}

// .vg.Snarl parent = 4;
inline bool Snarl::_internal_has_parent() const {
  return this != internal_default_instance() && _impl_.parent_ != nullptr;
}
inline bool Snarl::has_parent() const {
  return _internal_has_parent();
}
inline void Snarl::clear_parent() {
  if (GetArenaForAllocation() == nullptr && _impl_.parent_ != nullptr) {
    delete _impl_.parent_;
  }
  _impl_.parent_ = nullptr;
}
inline const ::vg::Snarl& Snarl::_internal_parent() const {
  const ::vg::Snarl* p = _impl_.parent_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Snarl&>(
      ::vg::_Snarl_default_instance_);
}
inline const ::vg::Snarl& Snarl::parent() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.parent)
  return _internal_parent();
}
inline void Snarl::unsafe_arena_set_allocated_parent(
    ::vg::Snarl* parent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_);
  }
  _impl_.parent_ = parent;
  if (parent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Snarl.parent)
}
inline ::vg::Snarl* Snarl::release_parent() {
  
  ::vg::Snarl* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Snarl* Snarl::unsafe_arena_release_parent() {
  // @@protoc_insertion_point(field_release:vg.Snarl.parent)
  
  ::vg::Snarl* temp = _impl_.parent_;
  _impl_.parent_ = nullptr;
  return temp;
}
inline ::vg::Snarl* Snarl::_internal_mutable_parent() {
  
  if (_impl_.parent_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Snarl>(GetArenaForAllocation());
    _impl_.parent_ = p;
  }
  return _impl_.parent_;
}
inline ::vg::Snarl* Snarl::mutable_parent() {
  ::vg::Snarl* _msg = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:vg.Snarl.parent)
  return _msg;
}
inline void Snarl::set_allocated_parent(::vg::Snarl* parent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.parent_;
  }
  if (parent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(parent);
    if (message_arena != submessage_arena) {
      parent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.parent_ = parent;
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.parent)
}

// string name = 5;
inline void Snarl::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Snarl::name() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Snarl::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Snarl.name)
}
inline std::string* Snarl::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.Snarl.name)
  return _s;
}
inline const std::string& Snarl::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Snarl::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Snarl::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Snarl::release_name() {
  // @@protoc_insertion_point(field_release:vg.Snarl.name)
  return _impl_.name_.Release();
}
inline void Snarl::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Snarl.name)
}

// bool start_self_reachable = 6;
inline void Snarl::clear_start_self_reachable() {
  _impl_.start_self_reachable_ = false;
}
inline bool Snarl::_internal_start_self_reachable() const {
  return _impl_.start_self_reachable_;
}
inline bool Snarl::start_self_reachable() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.start_self_reachable)
  return _internal_start_self_reachable();
}
inline void Snarl::_internal_set_start_self_reachable(bool value) {
  
  _impl_.start_self_reachable_ = value;
}
inline void Snarl::set_start_self_reachable(bool value) {
  _internal_set_start_self_reachable(value);
  // @@protoc_insertion_point(field_set:vg.Snarl.start_self_reachable)
}

// bool end_self_reachable = 7;
inline void Snarl::clear_end_self_reachable() {
  _impl_.end_self_reachable_ = false;
}
inline bool Snarl::_internal_end_self_reachable() const {
  return _impl_.end_self_reachable_;
}
inline bool Snarl::end_self_reachable() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.end_self_reachable)
  return _internal_end_self_reachable();
}
inline void Snarl::_internal_set_end_self_reachable(bool value) {
  
  _impl_.end_self_reachable_ = value;
}
inline void Snarl::set_end_self_reachable(bool value) {
  _internal_set_end_self_reachable(value);
  // @@protoc_insertion_point(field_set:vg.Snarl.end_self_reachable)
}

// bool start_end_reachable = 8;
inline void Snarl::clear_start_end_reachable() {
  _impl_.start_end_reachable_ = false;
}
inline bool Snarl::_internal_start_end_reachable() const {
  return _impl_.start_end_reachable_;
}
inline bool Snarl::start_end_reachable() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.start_end_reachable)
  return _internal_start_end_reachable();
}
inline void Snarl::_internal_set_start_end_reachable(bool value) {
  
  _impl_.start_end_reachable_ = value;
}
inline void Snarl::set_start_end_reachable(bool value) {
  _internal_set_start_end_reachable(value);
  // @@protoc_insertion_point(field_set:vg.Snarl.start_end_reachable)
}

// bool directed_acyclic_net_graph = 9;
inline void Snarl::clear_directed_acyclic_net_graph() {
  _impl_.directed_acyclic_net_graph_ = false;
}
inline bool Snarl::_internal_directed_acyclic_net_graph() const {
  return _impl_.directed_acyclic_net_graph_;
}
inline bool Snarl::directed_acyclic_net_graph() const {
  // @@protoc_insertion_point(field_get:vg.Snarl.directed_acyclic_net_graph)
  return _internal_directed_acyclic_net_graph();
}
inline void Snarl::_internal_set_directed_acyclic_net_graph(bool value) {
  
  _impl_.directed_acyclic_net_graph_ = value;
}
inline void Snarl::set_directed_acyclic_net_graph(bool value) {
  _internal_set_directed_acyclic_net_graph(value);
  // @@protoc_insertion_point(field_set:vg.Snarl.directed_acyclic_net_graph)
}

// -------------------------------------------------------------------

// Visit

// int64 node_id = 1;
inline void Visit::clear_node_id() {
  _impl_.node_id_ = int64_t{0};
}
inline int64_t Visit::_internal_node_id() const {
  return _impl_.node_id_;
}
inline int64_t Visit::node_id() const {
  // @@protoc_insertion_point(field_get:vg.Visit.node_id)
  return _internal_node_id();
}
inline void Visit::_internal_set_node_id(int64_t value) {
  
  _impl_.node_id_ = value;
}
inline void Visit::set_node_id(int64_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:vg.Visit.node_id)
}

// .vg.Snarl snarl = 2;
inline bool Visit::_internal_has_snarl() const {
  return this != internal_default_instance() && _impl_.snarl_ != nullptr;
}
inline bool Visit::has_snarl() const {
  return _internal_has_snarl();
}
inline void Visit::clear_snarl() {
  if (GetArenaForAllocation() == nullptr && _impl_.snarl_ != nullptr) {
    delete _impl_.snarl_;
  }
  _impl_.snarl_ = nullptr;
}
inline const ::vg::Snarl& Visit::_internal_snarl() const {
  const ::vg::Snarl* p = _impl_.snarl_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Snarl&>(
      ::vg::_Snarl_default_instance_);
}
inline const ::vg::Snarl& Visit::snarl() const {
  // @@protoc_insertion_point(field_get:vg.Visit.snarl)
  return _internal_snarl();
}
inline void Visit::unsafe_arena_set_allocated_snarl(
    ::vg::Snarl* snarl) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.snarl_);
  }
  _impl_.snarl_ = snarl;
  if (snarl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Visit.snarl)
}
inline ::vg::Snarl* Visit::release_snarl() {
  
  ::vg::Snarl* temp = _impl_.snarl_;
  _impl_.snarl_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Snarl* Visit::unsafe_arena_release_snarl() {
  // @@protoc_insertion_point(field_release:vg.Visit.snarl)
  
  ::vg::Snarl* temp = _impl_.snarl_;
  _impl_.snarl_ = nullptr;
  return temp;
}
inline ::vg::Snarl* Visit::_internal_mutable_snarl() {
  
  if (_impl_.snarl_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Snarl>(GetArenaForAllocation());
    _impl_.snarl_ = p;
  }
  return _impl_.snarl_;
}
inline ::vg::Snarl* Visit::mutable_snarl() {
  ::vg::Snarl* _msg = _internal_mutable_snarl();
  // @@protoc_insertion_point(field_mutable:vg.Visit.snarl)
  return _msg;
}
inline void Visit::set_allocated_snarl(::vg::Snarl* snarl) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.snarl_;
  }
  if (snarl) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snarl);
    if (message_arena != submessage_arena) {
      snarl = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snarl, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.snarl_ = snarl;
  // @@protoc_insertion_point(field_set_allocated:vg.Visit.snarl)
}

// bool backward = 3;
inline void Visit::clear_backward() {
  _impl_.backward_ = false;
}
inline bool Visit::_internal_backward() const {
  return _impl_.backward_;
}
inline bool Visit::backward() const {
  // @@protoc_insertion_point(field_get:vg.Visit.backward)
  return _internal_backward();
}
inline void Visit::_internal_set_backward(bool value) {
  
  _impl_.backward_ = value;
}
inline void Visit::set_backward(bool value) {
  _internal_set_backward(value);
  // @@protoc_insertion_point(field_set:vg.Visit.backward)
}

// -------------------------------------------------------------------

// SnarlTraversal

// repeated .vg.Visit visit = 1;
inline int SnarlTraversal::_internal_visit_size() const {
  return _impl_.visit_.size();
}
inline int SnarlTraversal::visit_size() const {
  return _internal_visit_size();
}
inline void SnarlTraversal::clear_visit() {
  _impl_.visit_.Clear();
}
inline ::vg::Visit* SnarlTraversal::mutable_visit(int index) {
  // @@protoc_insertion_point(field_mutable:vg.SnarlTraversal.visit)
  return _impl_.visit_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Visit >*
SnarlTraversal::mutable_visit() {
  // @@protoc_insertion_point(field_mutable_list:vg.SnarlTraversal.visit)
  return &_impl_.visit_;
}
inline const ::vg::Visit& SnarlTraversal::_internal_visit(int index) const {
  return _impl_.visit_.Get(index);
}
inline const ::vg::Visit& SnarlTraversal::visit(int index) const {
  // @@protoc_insertion_point(field_get:vg.SnarlTraversal.visit)
  return _internal_visit(index);
}
inline ::vg::Visit* SnarlTraversal::_internal_add_visit() {
  return _impl_.visit_.Add();
}
inline ::vg::Visit* SnarlTraversal::add_visit() {
  ::vg::Visit* _add = _internal_add_visit();
  // @@protoc_insertion_point(field_add:vg.SnarlTraversal.visit)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Visit >&
SnarlTraversal::visit() const {
  // @@protoc_insertion_point(field_list:vg.SnarlTraversal.visit)
  return _impl_.visit_;
}

// string name = 2;
inline void SnarlTraversal::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SnarlTraversal::name() const {
  // @@protoc_insertion_point(field_get:vg.SnarlTraversal.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnarlTraversal::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.SnarlTraversal.name)
}
inline std::string* SnarlTraversal::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.SnarlTraversal.name)
  return _s;
}
inline const std::string& SnarlTraversal::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SnarlTraversal::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SnarlTraversal::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SnarlTraversal::release_name() {
  // @@protoc_insertion_point(field_release:vg.SnarlTraversal.name)
  return _impl_.name_.Release();
}
inline void SnarlTraversal::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.SnarlTraversal.name)
}

// -------------------------------------------------------------------

// Locus

// string name = 1;
inline void Locus::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Locus::name() const {
  // @@protoc_insertion_point(field_get:vg.Locus.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Locus::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:vg.Locus.name)
}
inline std::string* Locus::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:vg.Locus.name)
  return _s;
}
inline const std::string& Locus::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Locus::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Locus::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Locus::release_name() {
  // @@protoc_insertion_point(field_release:vg.Locus.name)
  return _impl_.name_.Release();
}
inline void Locus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:vg.Locus.name)
}

// repeated .vg.Path allele = 2;
inline int Locus::_internal_allele_size() const {
  return _impl_.allele_.size();
}
inline int Locus::allele_size() const {
  return _internal_allele_size();
}
inline void Locus::clear_allele() {
  _impl_.allele_.Clear();
}
inline ::vg::Path* Locus::mutable_allele(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.allele)
  return _impl_.allele_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >*
Locus::mutable_allele() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.allele)
  return &_impl_.allele_;
}
inline const ::vg::Path& Locus::_internal_allele(int index) const {
  return _impl_.allele_.Get(index);
}
inline const ::vg::Path& Locus::allele(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.allele)
  return _internal_allele(index);
}
inline ::vg::Path* Locus::_internal_add_allele() {
  return _impl_.allele_.Add();
}
inline ::vg::Path* Locus::add_allele() {
  ::vg::Path* _add = _internal_add_allele();
  // @@protoc_insertion_point(field_add:vg.Locus.allele)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Path >&
Locus::allele() const {
  // @@protoc_insertion_point(field_list:vg.Locus.allele)
  return _impl_.allele_;
}

// repeated .vg.Support support = 3;
inline int Locus::_internal_support_size() const {
  return _impl_.support_.size();
}
inline int Locus::support_size() const {
  return _internal_support_size();
}
inline void Locus::clear_support() {
  _impl_.support_.Clear();
}
inline ::vg::Support* Locus::mutable_support(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.support)
  return _impl_.support_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Support >*
Locus::mutable_support() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.support)
  return &_impl_.support_;
}
inline const ::vg::Support& Locus::_internal_support(int index) const {
  return _impl_.support_.Get(index);
}
inline const ::vg::Support& Locus::support(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.support)
  return _internal_support(index);
}
inline ::vg::Support* Locus::_internal_add_support() {
  return _impl_.support_.Add();
}
inline ::vg::Support* Locus::add_support() {
  ::vg::Support* _add = _internal_add_support();
  // @@protoc_insertion_point(field_add:vg.Locus.support)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Support >&
Locus::support() const {
  // @@protoc_insertion_point(field_list:vg.Locus.support)
  return _impl_.support_;
}

// repeated .vg.Genotype genotype = 4;
inline int Locus::_internal_genotype_size() const {
  return _impl_.genotype_.size();
}
inline int Locus::genotype_size() const {
  return _internal_genotype_size();
}
inline void Locus::clear_genotype() {
  _impl_.genotype_.Clear();
}
inline ::vg::Genotype* Locus::mutable_genotype(int index) {
  // @@protoc_insertion_point(field_mutable:vg.Locus.genotype)
  return _impl_.genotype_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Genotype >*
Locus::mutable_genotype() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.genotype)
  return &_impl_.genotype_;
}
inline const ::vg::Genotype& Locus::_internal_genotype(int index) const {
  return _impl_.genotype_.Get(index);
}
inline const ::vg::Genotype& Locus::genotype(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.genotype)
  return _internal_genotype(index);
}
inline ::vg::Genotype* Locus::_internal_add_genotype() {
  return _impl_.genotype_.Add();
}
inline ::vg::Genotype* Locus::add_genotype() {
  ::vg::Genotype* _add = _internal_add_genotype();
  // @@protoc_insertion_point(field_add:vg.Locus.genotype)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::vg::Genotype >&
Locus::genotype() const {
  // @@protoc_insertion_point(field_list:vg.Locus.genotype)
  return _impl_.genotype_;
}

// .vg.Support overall_support = 5;
inline bool Locus::_internal_has_overall_support() const {
  return this != internal_default_instance() && _impl_.overall_support_ != nullptr;
}
inline bool Locus::has_overall_support() const {
  return _internal_has_overall_support();
}
inline void Locus::clear_overall_support() {
  if (GetArenaForAllocation() == nullptr && _impl_.overall_support_ != nullptr) {
    delete _impl_.overall_support_;
  }
  _impl_.overall_support_ = nullptr;
}
inline const ::vg::Support& Locus::_internal_overall_support() const {
  const ::vg::Support* p = _impl_.overall_support_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Support&>(
      ::vg::_Support_default_instance_);
}
inline const ::vg::Support& Locus::overall_support() const {
  // @@protoc_insertion_point(field_get:vg.Locus.overall_support)
  return _internal_overall_support();
}
inline void Locus::unsafe_arena_set_allocated_overall_support(
    ::vg::Support* overall_support) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.overall_support_);
  }
  _impl_.overall_support_ = overall_support;
  if (overall_support) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Locus.overall_support)
}
inline ::vg::Support* Locus::release_overall_support() {
  
  ::vg::Support* temp = _impl_.overall_support_;
  _impl_.overall_support_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Support* Locus::unsafe_arena_release_overall_support() {
  // @@protoc_insertion_point(field_release:vg.Locus.overall_support)
  
  ::vg::Support* temp = _impl_.overall_support_;
  _impl_.overall_support_ = nullptr;
  return temp;
}
inline ::vg::Support* Locus::_internal_mutable_overall_support() {
  
  if (_impl_.overall_support_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Support>(GetArenaForAllocation());
    _impl_.overall_support_ = p;
  }
  return _impl_.overall_support_;
}
inline ::vg::Support* Locus::mutable_overall_support() {
  ::vg::Support* _msg = _internal_mutable_overall_support();
  // @@protoc_insertion_point(field_mutable:vg.Locus.overall_support)
  return _msg;
}
inline void Locus::set_allocated_overall_support(::vg::Support* overall_support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.overall_support_;
  }
  if (overall_support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(overall_support);
    if (message_arena != submessage_arena) {
      overall_support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, overall_support, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.overall_support_ = overall_support;
  // @@protoc_insertion_point(field_set_allocated:vg.Locus.overall_support)
}

// repeated double allele_log_likelihood = 6;
inline int Locus::_internal_allele_log_likelihood_size() const {
  return _impl_.allele_log_likelihood_.size();
}
inline int Locus::allele_log_likelihood_size() const {
  return _internal_allele_log_likelihood_size();
}
inline void Locus::clear_allele_log_likelihood() {
  _impl_.allele_log_likelihood_.Clear();
}
inline double Locus::_internal_allele_log_likelihood(int index) const {
  return _impl_.allele_log_likelihood_.Get(index);
}
inline double Locus::allele_log_likelihood(int index) const {
  // @@protoc_insertion_point(field_get:vg.Locus.allele_log_likelihood)
  return _internal_allele_log_likelihood(index);
}
inline void Locus::set_allele_log_likelihood(int index, double value) {
  _impl_.allele_log_likelihood_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Locus.allele_log_likelihood)
}
inline void Locus::_internal_add_allele_log_likelihood(double value) {
  _impl_.allele_log_likelihood_.Add(value);
}
inline void Locus::add_allele_log_likelihood(double value) {
  _internal_add_allele_log_likelihood(value);
  // @@protoc_insertion_point(field_add:vg.Locus.allele_log_likelihood)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Locus::_internal_allele_log_likelihood() const {
  return _impl_.allele_log_likelihood_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
Locus::allele_log_likelihood() const {
  // @@protoc_insertion_point(field_list:vg.Locus.allele_log_likelihood)
  return _internal_allele_log_likelihood();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Locus::_internal_mutable_allele_log_likelihood() {
  return &_impl_.allele_log_likelihood_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
Locus::mutable_allele_log_likelihood() {
  // @@protoc_insertion_point(field_mutable_list:vg.Locus.allele_log_likelihood)
  return _internal_mutable_allele_log_likelihood();
}

// -------------------------------------------------------------------

// Genotype

// repeated int32 allele = 1;
inline int Genotype::_internal_allele_size() const {
  return _impl_.allele_.size();
}
inline int Genotype::allele_size() const {
  return _internal_allele_size();
}
inline void Genotype::clear_allele() {
  _impl_.allele_.Clear();
}
inline int32_t Genotype::_internal_allele(int index) const {
  return _impl_.allele_.Get(index);
}
inline int32_t Genotype::allele(int index) const {
  // @@protoc_insertion_point(field_get:vg.Genotype.allele)
  return _internal_allele(index);
}
inline void Genotype::set_allele(int index, int32_t value) {
  _impl_.allele_.Set(index, value);
  // @@protoc_insertion_point(field_set:vg.Genotype.allele)
}
inline void Genotype::_internal_add_allele(int32_t value) {
  _impl_.allele_.Add(value);
}
inline void Genotype::add_allele(int32_t value) {
  _internal_add_allele(value);
  // @@protoc_insertion_point(field_add:vg.Genotype.allele)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Genotype::_internal_allele() const {
  return _impl_.allele_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Genotype::allele() const {
  // @@protoc_insertion_point(field_list:vg.Genotype.allele)
  return _internal_allele();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Genotype::_internal_mutable_allele() {
  return &_impl_.allele_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Genotype::mutable_allele() {
  // @@protoc_insertion_point(field_mutable_list:vg.Genotype.allele)
  return _internal_mutable_allele();
}

// bool is_phased = 2;
inline void Genotype::clear_is_phased() {
  _impl_.is_phased_ = false;
}
inline bool Genotype::_internal_is_phased() const {
  return _impl_.is_phased_;
}
inline bool Genotype::is_phased() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.is_phased)
  return _internal_is_phased();
}
inline void Genotype::_internal_set_is_phased(bool value) {
  
  _impl_.is_phased_ = value;
}
inline void Genotype::set_is_phased(bool value) {
  _internal_set_is_phased(value);
  // @@protoc_insertion_point(field_set:vg.Genotype.is_phased)
}

// double likelihood = 3;
inline void Genotype::clear_likelihood() {
  _impl_.likelihood_ = 0;
}
inline double Genotype::_internal_likelihood() const {
  return _impl_.likelihood_;
}
inline double Genotype::likelihood() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.likelihood)
  return _internal_likelihood();
}
inline void Genotype::_internal_set_likelihood(double value) {
  
  _impl_.likelihood_ = value;
}
inline void Genotype::set_likelihood(double value) {
  _internal_set_likelihood(value);
  // @@protoc_insertion_point(field_set:vg.Genotype.likelihood)
}

// double log_likelihood = 4;
inline void Genotype::clear_log_likelihood() {
  _impl_.log_likelihood_ = 0;
}
inline double Genotype::_internal_log_likelihood() const {
  return _impl_.log_likelihood_;
}
inline double Genotype::log_likelihood() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_likelihood)
  return _internal_log_likelihood();
}
inline void Genotype::_internal_set_log_likelihood(double value) {
  
  _impl_.log_likelihood_ = value;
}
inline void Genotype::set_log_likelihood(double value) {
  _internal_set_log_likelihood(value);
  // @@protoc_insertion_point(field_set:vg.Genotype.log_likelihood)
}

// double log_prior = 5;
inline void Genotype::clear_log_prior() {
  _impl_.log_prior_ = 0;
}
inline double Genotype::_internal_log_prior() const {
  return _impl_.log_prior_;
}
inline double Genotype::log_prior() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_prior)
  return _internal_log_prior();
}
inline void Genotype::_internal_set_log_prior(double value) {
  
  _impl_.log_prior_ = value;
}
inline void Genotype::set_log_prior(double value) {
  _internal_set_log_prior(value);
  // @@protoc_insertion_point(field_set:vg.Genotype.log_prior)
}

// double log_posterior = 6;
inline void Genotype::clear_log_posterior() {
  _impl_.log_posterior_ = 0;
}
inline double Genotype::_internal_log_posterior() const {
  return _impl_.log_posterior_;
}
inline double Genotype::log_posterior() const {
  // @@protoc_insertion_point(field_get:vg.Genotype.log_posterior)
  return _internal_log_posterior();
}
inline void Genotype::_internal_set_log_posterior(double value) {
  
  _impl_.log_posterior_ = value;
}
inline void Genotype::set_log_posterior(double value) {
  _internal_set_log_posterior(value);
  // @@protoc_insertion_point(field_set:vg.Genotype.log_posterior)
}

// -------------------------------------------------------------------

// Support

// double quality = 1;
inline void Support::clear_quality() {
  _impl_.quality_ = 0;
}
inline double Support::_internal_quality() const {
  return _impl_.quality_;
}
inline double Support::quality() const {
  // @@protoc_insertion_point(field_get:vg.Support.quality)
  return _internal_quality();
}
inline void Support::_internal_set_quality(double value) {
  
  _impl_.quality_ = value;
}
inline void Support::set_quality(double value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:vg.Support.quality)
}

// double forward = 2;
inline void Support::clear_forward() {
  _impl_.forward_ = 0;
}
inline double Support::_internal_forward() const {
  return _impl_.forward_;
}
inline double Support::forward() const {
  // @@protoc_insertion_point(field_get:vg.Support.forward)
  return _internal_forward();
}
inline void Support::_internal_set_forward(double value) {
  
  _impl_.forward_ = value;
}
inline void Support::set_forward(double value) {
  _internal_set_forward(value);
  // @@protoc_insertion_point(field_set:vg.Support.forward)
}

// double reverse = 3;
inline void Support::clear_reverse() {
  _impl_.reverse_ = 0;
}
inline double Support::_internal_reverse() const {
  return _impl_.reverse_;
}
inline double Support::reverse() const {
  // @@protoc_insertion_point(field_get:vg.Support.reverse)
  return _internal_reverse();
}
inline void Support::_internal_set_reverse(double value) {
  
  _impl_.reverse_ = value;
}
inline void Support::set_reverse(double value) {
  _internal_set_reverse(value);
  // @@protoc_insertion_point(field_set:vg.Support.reverse)
}

// double left = 4;
inline void Support::clear_left() {
  _impl_.left_ = 0;
}
inline double Support::_internal_left() const {
  return _impl_.left_;
}
inline double Support::left() const {
  // @@protoc_insertion_point(field_get:vg.Support.left)
  return _internal_left();
}
inline void Support::_internal_set_left(double value) {
  
  _impl_.left_ = value;
}
inline void Support::set_left(double value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:vg.Support.left)
}

// double right = 5;
inline void Support::clear_right() {
  _impl_.right_ = 0;
}
inline double Support::_internal_right() const {
  return _impl_.right_;
}
inline double Support::right() const {
  // @@protoc_insertion_point(field_get:vg.Support.right)
  return _internal_right();
}
inline void Support::_internal_set_right(double value) {
  
  _impl_.right_ = value;
}
inline void Support::set_right(double value) {
  _internal_set_right(value);
  // @@protoc_insertion_point(field_set:vg.Support.right)
}

// -------------------------------------------------------------------

// LocationSupport

// .vg.Support support = 1;
inline bool LocationSupport::_internal_has_support() const {
  return this != internal_default_instance() && _impl_.support_ != nullptr;
}
inline bool LocationSupport::has_support() const {
  return _internal_has_support();
}
inline void LocationSupport::clear_support() {
  if (GetArenaForAllocation() == nullptr && _impl_.support_ != nullptr) {
    delete _impl_.support_;
  }
  _impl_.support_ = nullptr;
}
inline const ::vg::Support& LocationSupport::_internal_support() const {
  const ::vg::Support* p = _impl_.support_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Support&>(
      ::vg::_Support_default_instance_);
}
inline const ::vg::Support& LocationSupport::support() const {
  // @@protoc_insertion_point(field_get:vg.LocationSupport.support)
  return _internal_support();
}
inline void LocationSupport::unsafe_arena_set_allocated_support(
    ::vg::Support* support) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.support_);
  }
  _impl_.support_ = support;
  if (support) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.LocationSupport.support)
}
inline ::vg::Support* LocationSupport::release_support() {
  
  ::vg::Support* temp = _impl_.support_;
  _impl_.support_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Support* LocationSupport::unsafe_arena_release_support() {
  // @@protoc_insertion_point(field_release:vg.LocationSupport.support)
  
  ::vg::Support* temp = _impl_.support_;
  _impl_.support_ = nullptr;
  return temp;
}
inline ::vg::Support* LocationSupport::_internal_mutable_support() {
  
  if (_impl_.support_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Support>(GetArenaForAllocation());
    _impl_.support_ = p;
  }
  return _impl_.support_;
}
inline ::vg::Support* LocationSupport::mutable_support() {
  ::vg::Support* _msg = _internal_mutable_support();
  // @@protoc_insertion_point(field_mutable:vg.LocationSupport.support)
  return _msg;
}
inline void LocationSupport::set_allocated_support(::vg::Support* support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.support_;
  }
  if (support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(support);
    if (message_arena != submessage_arena) {
      support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, support, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.support_ = support;
  // @@protoc_insertion_point(field_set_allocated:vg.LocationSupport.support)
}

// .vg.Edge edge = 2;
inline bool LocationSupport::_internal_has_edge() const {
  return oneof_location_case() == kEdge;
}
inline bool LocationSupport::has_edge() const {
  return _internal_has_edge();
}
inline void LocationSupport::set_has_edge() {
  _impl_._oneof_case_[0] = kEdge;
}
inline void LocationSupport::clear_edge() {
  if (_internal_has_edge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.oneof_location_.edge_;
    }
    clear_has_oneof_location();
  }
}
inline ::vg::Edge* LocationSupport::release_edge() {
  // @@protoc_insertion_point(field_release:vg.LocationSupport.edge)
  if (_internal_has_edge()) {
    clear_has_oneof_location();
    ::vg::Edge* temp = _impl_.oneof_location_.edge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.oneof_location_.edge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::vg::Edge& LocationSupport::_internal_edge() const {
  return _internal_has_edge()
      ? *_impl_.oneof_location_.edge_
      : reinterpret_cast< ::vg::Edge&>(::vg::_Edge_default_instance_);
}
inline const ::vg::Edge& LocationSupport::edge() const {
  // @@protoc_insertion_point(field_get:vg.LocationSupport.edge)
  return _internal_edge();
}
inline ::vg::Edge* LocationSupport::unsafe_arena_release_edge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:vg.LocationSupport.edge)
  if (_internal_has_edge()) {
    clear_has_oneof_location();
    ::vg::Edge* temp = _impl_.oneof_location_.edge_;
    _impl_.oneof_location_.edge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LocationSupport::unsafe_arena_set_allocated_edge(::vg::Edge* edge) {
  clear_oneof_location();
  if (edge) {
    set_has_edge();
    _impl_.oneof_location_.edge_ = edge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.LocationSupport.edge)
}
inline ::vg::Edge* LocationSupport::_internal_mutable_edge() {
  if (!_internal_has_edge()) {
    clear_oneof_location();
    set_has_edge();
    _impl_.oneof_location_.edge_ = CreateMaybeMessage< ::vg::Edge >(GetArenaForAllocation());
  }
  return _impl_.oneof_location_.edge_;
}
inline ::vg::Edge* LocationSupport::mutable_edge() {
  ::vg::Edge* _msg = _internal_mutable_edge();
  // @@protoc_insertion_point(field_mutable:vg.LocationSupport.edge)
  return _msg;
}

// int64 node_id = 3;
inline bool LocationSupport::_internal_has_node_id() const {
  return oneof_location_case() == kNodeId;
}
inline bool LocationSupport::has_node_id() const {
  return _internal_has_node_id();
}
inline void LocationSupport::set_has_node_id() {
  _impl_._oneof_case_[0] = kNodeId;
}
inline void LocationSupport::clear_node_id() {
  if (_internal_has_node_id()) {
    _impl_.oneof_location_.node_id_ = int64_t{0};
    clear_has_oneof_location();
  }
}
inline int64_t LocationSupport::_internal_node_id() const {
  if (_internal_has_node_id()) {
    return _impl_.oneof_location_.node_id_;
  }
  return int64_t{0};
}
inline void LocationSupport::_internal_set_node_id(int64_t value) {
  if (!_internal_has_node_id()) {
    clear_oneof_location();
    set_has_node_id();
  }
  _impl_.oneof_location_.node_id_ = value;
}
inline int64_t LocationSupport::node_id() const {
  // @@protoc_insertion_point(field_get:vg.LocationSupport.node_id)
  return _internal_node_id();
}
inline void LocationSupport::set_node_id(int64_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:vg.LocationSupport.node_id)
}

inline bool LocationSupport::has_oneof_location() const {
  return oneof_location_case() != ONEOF_LOCATION_NOT_SET;
}
inline void LocationSupport::clear_has_oneof_location() {
  _impl_._oneof_case_[0] = ONEOF_LOCATION_NOT_SET;
}
inline LocationSupport::OneofLocationCase LocationSupport::oneof_location_case() const {
  return LocationSupport::OneofLocationCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Translation

// .vg.Path from = 1;
inline bool Translation::_internal_has_from() const {
  return this != internal_default_instance() && _impl_.from_ != nullptr;
}
inline bool Translation::has_from() const {
  return _internal_has_from();
}
inline void Translation::clear_from() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
}
inline const ::vg::Path& Translation::_internal_from() const {
  const ::vg::Path* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Path&>(
      ::vg::_Path_default_instance_);
}
inline const ::vg::Path& Translation::from() const {
  // @@protoc_insertion_point(field_get:vg.Translation.from)
  return _internal_from();
}
inline void Translation::unsafe_arena_set_allocated_from(
    ::vg::Path* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Translation.from)
}
inline ::vg::Path* Translation::release_from() {
  
  ::vg::Path* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Path* Translation::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:vg.Translation.from)
  
  ::vg::Path* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::vg::Path* Translation::_internal_mutable_from() {
  
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::vg::Path* Translation::mutable_from() {
  ::vg::Path* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:vg.Translation.from)
  return _msg;
}
inline void Translation::set_allocated_from(::vg::Path* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:vg.Translation.from)
}

// .vg.Path to = 2;
inline bool Translation::_internal_has_to() const {
  return this != internal_default_instance() && _impl_.to_ != nullptr;
}
inline bool Translation::has_to() const {
  return _internal_has_to();
}
inline void Translation::clear_to() {
  if (GetArenaForAllocation() == nullptr && _impl_.to_ != nullptr) {
    delete _impl_.to_;
  }
  _impl_.to_ = nullptr;
}
inline const ::vg::Path& Translation::_internal_to() const {
  const ::vg::Path* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::vg::Path&>(
      ::vg::_Path_default_instance_);
}
inline const ::vg::Path& Translation::to() const {
  // @@protoc_insertion_point(field_get:vg.Translation.to)
  return _internal_to();
}
inline void Translation::unsafe_arena_set_allocated_to(
    ::vg::Path* to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = to;
  if (to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:vg.Translation.to)
}
inline ::vg::Path* Translation::release_to() {
  
  ::vg::Path* temp = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::vg::Path* Translation::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:vg.Translation.to)
  
  ::vg::Path* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::vg::Path* Translation::_internal_mutable_to() {
  
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::vg::Path>(GetArenaForAllocation());
    _impl_.to_ = p;
  }
  return _impl_.to_;
}
inline ::vg::Path* Translation::mutable_to() {
  ::vg::Path* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:vg.Translation.to)
  return _msg;
}
inline void Translation::set_allocated_to(::vg::Path* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to);
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_ = to;
  // @@protoc_insertion_point(field_set_allocated:vg.Translation.to)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::vg::SnarlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::vg::SnarlType>() {
  return ::vg::SnarlType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vg_2eproto
