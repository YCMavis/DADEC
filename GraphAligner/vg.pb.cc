// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vg.proto

#include "vg.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace vg {
PROTOBUF_CONSTEXPR Graph::Graph(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.node_)*/{}
  , /*decltype(_impl_.edge_)*/{}
  , /*decltype(_impl_.path_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GraphDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GraphDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GraphDefaultTypeInternal() {}
  union {
    Graph _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GraphDefaultTypeInternal _Graph_default_instance_;
PROTOBUF_CONSTEXPR Node::Node(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sequence_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.id_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeDefaultTypeInternal() {}
  union {
    Node _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeDefaultTypeInternal _Node_default_instance_;
PROTOBUF_CONSTEXPR Edge::Edge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_)*/int64_t{0}
  , /*decltype(_impl_.to_)*/int64_t{0}
  , /*decltype(_impl_.from_start_)*/false
  , /*decltype(_impl_.to_end_)*/false
  , /*decltype(_impl_.overlap_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EdgeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgeDefaultTypeInternal() {}
  union {
    Edge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgeDefaultTypeInternal _Edge_default_instance_;
PROTOBUF_CONSTEXPR Edit::Edit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sequence_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.from_length_)*/0
  , /*decltype(_impl_.to_length_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EditDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EditDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EditDefaultTypeInternal() {}
  union {
    Edit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EditDefaultTypeInternal _Edit_default_instance_;
PROTOBUF_CONSTEXPR Mapping::Mapping(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.edit_)*/{}
  , /*decltype(_impl_.position_)*/nullptr
  , /*decltype(_impl_.rank_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MappingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MappingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MappingDefaultTypeInternal() {}
  union {
    Mapping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MappingDefaultTypeInternal _Mapping_default_instance_;
PROTOBUF_CONSTEXPR Position::Position(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_id_)*/int64_t{0}
  , /*decltype(_impl_.offset_)*/int64_t{0}
  , /*decltype(_impl_.is_reverse_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PositionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PositionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PositionDefaultTypeInternal() {}
  union {
    Position _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PositionDefaultTypeInternal _Position_default_instance_;
PROTOBUF_CONSTEXPR Path::Path(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.mapping_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.length_)*/int64_t{0}
  , /*decltype(_impl_.is_circular_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathDefaultTypeInternal() {}
  union {
    Path _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathDefaultTypeInternal _Path_default_instance_;
PROTOBUF_CONSTEXPR Alignment::Alignment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.fragment_)*/{}
  , /*decltype(_impl_.locus_)*/{}
  , /*decltype(_impl_.refpos_)*/{}
  , /*decltype(_impl_.secondary_score_)*/{}
  , /*decltype(_impl_._secondary_score_cached_byte_size_)*/{0}
  , /*decltype(_impl_.sequence_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sample_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_group_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fragment_length_distribution_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.path_)*/nullptr
  , /*decltype(_impl_.fragment_prev_)*/nullptr
  , /*decltype(_impl_.fragment_next_)*/nullptr
  , /*decltype(_impl_.to_correct_)*/nullptr
  , /*decltype(_impl_.annotation_)*/nullptr
  , /*decltype(_impl_.mapping_quality_)*/0
  , /*decltype(_impl_.score_)*/0
  , /*decltype(_impl_.identity_)*/0
  , /*decltype(_impl_.query_position_)*/0
  , /*decltype(_impl_.is_secondary_)*/false
  , /*decltype(_impl_.read_paired_)*/false
  , /*decltype(_impl_.read_mapped_)*/false
  , /*decltype(_impl_.mate_unmapped_)*/false
  , /*decltype(_impl_.uniqueness_)*/0
  , /*decltype(_impl_.correct_)*/0
  , /*decltype(_impl_.read_on_reverse_strand_)*/false
  , /*decltype(_impl_.mate_on_reverse_strand_)*/false
  , /*decltype(_impl_.soft_clipped_)*/false
  , /*decltype(_impl_.discordant_insert_size_)*/false
  , /*decltype(_impl_.mate_mapped_to_disjoint_subgraph_)*/false
  , /*decltype(_impl_.haplotype_scored_)*/false
  , /*decltype(_impl_.correctly_mapped_)*/false
  , /*decltype(_impl_.fragment_score_)*/0
  , /*decltype(_impl_.haplotype_logprob_)*/0
  , /*decltype(_impl_.time_used_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AlignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlignmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlignmentDefaultTypeInternal() {}
  union {
    Alignment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlignmentDefaultTypeInternal _Alignment_default_instance_;
PROTOBUF_CONSTEXPR MultipathAlignment::MultipathAlignment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.subpath_)*/{}
  , /*decltype(_impl_.start_)*/{}
  , /*decltype(_impl_._start_cached_byte_size_)*/{0}
  , /*decltype(_impl_.sequence_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sample_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.read_group_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.paired_read_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.annotation_)*/nullptr
  , /*decltype(_impl_.mapping_quality_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct MultipathAlignmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MultipathAlignmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MultipathAlignmentDefaultTypeInternal() {}
  union {
    MultipathAlignment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MultipathAlignmentDefaultTypeInternal _MultipathAlignment_default_instance_;
PROTOBUF_CONSTEXPR Subpath::Subpath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.next_)*/{}
  , /*decltype(_impl_._next_cached_byte_size_)*/{0}
  , /*decltype(_impl_.path_)*/nullptr
  , /*decltype(_impl_.score_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SubpathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SubpathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SubpathDefaultTypeInternal() {}
  union {
    Subpath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubpathDefaultTypeInternal _Subpath_default_instance_;
PROTOBUF_CONSTEXPR KmerMatch::KmerMatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.sequence_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.node_id_)*/int64_t{0}
  , /*decltype(_impl_.position_)*/0
  , /*decltype(_impl_.backward_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct KmerMatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KmerMatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~KmerMatchDefaultTypeInternal() {}
  union {
    KmerMatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KmerMatchDefaultTypeInternal _KmerMatch_default_instance_;
PROTOBUF_CONSTEXPR BasePileup::BasePileup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.bases_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.qualities_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.ref_base_)*/0
  , /*decltype(_impl_.num_bases_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BasePileupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BasePileupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BasePileupDefaultTypeInternal() {}
  union {
    BasePileup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BasePileupDefaultTypeInternal _BasePileup_default_instance_;
PROTOBUF_CONSTEXPR NodePileup::NodePileup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.base_pileup_)*/{}
  , /*decltype(_impl_.node_id_)*/int64_t{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NodePileupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodePileupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodePileupDefaultTypeInternal() {}
  union {
    NodePileup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodePileupDefaultTypeInternal _NodePileup_default_instance_;
PROTOBUF_CONSTEXPR EdgePileup::EdgePileup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.qualities_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.edge_)*/nullptr
  , /*decltype(_impl_.num_reads_)*/0
  , /*decltype(_impl_.num_forward_reads_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EdgePileupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgePileupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgePileupDefaultTypeInternal() {}
  union {
    EdgePileup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgePileupDefaultTypeInternal _EdgePileup_default_instance_;
PROTOBUF_CONSTEXPR Pileup::Pileup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.node_pileups_)*/{}
  , /*decltype(_impl_.edge_pileups_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PileupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PileupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PileupDefaultTypeInternal() {}
  union {
    Pileup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PileupDefaultTypeInternal _Pileup_default_instance_;
PROTOBUF_CONSTEXPR Snarl::Snarl(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.parent_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.start_self_reachable_)*/false
  , /*decltype(_impl_.end_self_reachable_)*/false
  , /*decltype(_impl_.start_end_reachable_)*/false
  , /*decltype(_impl_.directed_acyclic_net_graph_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SnarlDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnarlDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnarlDefaultTypeInternal() {}
  union {
    Snarl _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnarlDefaultTypeInternal _Snarl_default_instance_;
PROTOBUF_CONSTEXPR Visit::Visit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.snarl_)*/nullptr
  , /*decltype(_impl_.node_id_)*/int64_t{0}
  , /*decltype(_impl_.backward_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VisitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VisitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VisitDefaultTypeInternal() {}
  union {
    Visit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VisitDefaultTypeInternal _Visit_default_instance_;
PROTOBUF_CONSTEXPR SnarlTraversal::SnarlTraversal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.visit_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SnarlTraversalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnarlTraversalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnarlTraversalDefaultTypeInternal() {}
  union {
    SnarlTraversal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnarlTraversalDefaultTypeInternal _SnarlTraversal_default_instance_;
PROTOBUF_CONSTEXPR Locus::Locus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.allele_)*/{}
  , /*decltype(_impl_.support_)*/{}
  , /*decltype(_impl_.genotype_)*/{}
  , /*decltype(_impl_.allele_log_likelihood_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.overall_support_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LocusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocusDefaultTypeInternal() {}
  union {
    Locus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocusDefaultTypeInternal _Locus_default_instance_;
PROTOBUF_CONSTEXPR Genotype::Genotype(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.allele_)*/{}
  , /*decltype(_impl_._allele_cached_byte_size_)*/{0}
  , /*decltype(_impl_.likelihood_)*/0
  , /*decltype(_impl_.log_likelihood_)*/0
  , /*decltype(_impl_.log_prior_)*/0
  , /*decltype(_impl_.log_posterior_)*/0
  , /*decltype(_impl_.is_phased_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GenotypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GenotypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GenotypeDefaultTypeInternal() {}
  union {
    Genotype _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GenotypeDefaultTypeInternal _Genotype_default_instance_;
PROTOBUF_CONSTEXPR Support::Support(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.quality_)*/0
  , /*decltype(_impl_.forward_)*/0
  , /*decltype(_impl_.reverse_)*/0
  , /*decltype(_impl_.left_)*/0
  , /*decltype(_impl_.right_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SupportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SupportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SupportDefaultTypeInternal() {}
  union {
    Support _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SupportDefaultTypeInternal _Support_default_instance_;
PROTOBUF_CONSTEXPR LocationSupport::LocationSupport(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.support_)*/nullptr
  , /*decltype(_impl_.oneof_location_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct LocationSupportDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LocationSupportDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LocationSupportDefaultTypeInternal() {}
  union {
    LocationSupport _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LocationSupportDefaultTypeInternal _LocationSupport_default_instance_;
PROTOBUF_CONSTEXPR Translation::Translation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_)*/nullptr
  , /*decltype(_impl_.to_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TranslationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TranslationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TranslationDefaultTypeInternal() {}
  union {
    Translation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TranslationDefaultTypeInternal _Translation_default_instance_;
}  // namespace vg
static ::_pb::Metadata file_level_metadata_vg_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_vg_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_vg_2eproto = nullptr;

const uint32_t TableStruct_vg_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Graph, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Graph, _impl_.node_),
  PROTOBUF_FIELD_OFFSET(::vg::Graph, _impl_.edge_),
  PROTOBUF_FIELD_OFFSET(::vg::Graph, _impl_.path_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Node, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Node, _impl_.sequence_),
  PROTOBUF_FIELD_OFFSET(::vg::Node, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vg::Node, _impl_.id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Edge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Edge, _impl_.from_),
  PROTOBUF_FIELD_OFFSET(::vg::Edge, _impl_.to_),
  PROTOBUF_FIELD_OFFSET(::vg::Edge, _impl_.from_start_),
  PROTOBUF_FIELD_OFFSET(::vg::Edge, _impl_.to_end_),
  PROTOBUF_FIELD_OFFSET(::vg::Edge, _impl_.overlap_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Edit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Edit, _impl_.from_length_),
  PROTOBUF_FIELD_OFFSET(::vg::Edit, _impl_.to_length_),
  PROTOBUF_FIELD_OFFSET(::vg::Edit, _impl_.sequence_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Mapping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Mapping, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::vg::Mapping, _impl_.edit_),
  PROTOBUF_FIELD_OFFSET(::vg::Mapping, _impl_.rank_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Position, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Position, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::vg::Position, _impl_.offset_),
  PROTOBUF_FIELD_OFFSET(::vg::Position, _impl_.is_reverse_),
  PROTOBUF_FIELD_OFFSET(::vg::Position, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Path, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Path, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vg::Path, _impl_.mapping_),
  PROTOBUF_FIELD_OFFSET(::vg::Path, _impl_.is_circular_),
  PROTOBUF_FIELD_OFFSET(::vg::Path, _impl_.length_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.sequence_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.mapping_quality_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.query_position_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.sample_name_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.read_group_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.fragment_prev_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.fragment_next_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.is_secondary_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.identity_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.fragment_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.locus_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.refpos_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.read_paired_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.read_mapped_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.mate_unmapped_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.read_on_reverse_strand_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.mate_on_reverse_strand_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.soft_clipped_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.discordant_insert_size_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.uniqueness_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.correct_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.secondary_score_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.fragment_score_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.mate_mapped_to_disjoint_subgraph_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.fragment_length_distribution_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.haplotype_scored_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.haplotype_logprob_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.time_used_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.to_correct_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.correctly_mapped_),
  PROTOBUF_FIELD_OFFSET(::vg::Alignment, _impl_.annotation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.sequence_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.sample_name_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.read_group_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.subpath_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.mapping_quality_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.paired_read_name_),
  PROTOBUF_FIELD_OFFSET(::vg::MultipathAlignment, _impl_.annotation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Subpath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Subpath, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::vg::Subpath, _impl_.next_),
  PROTOBUF_FIELD_OFFSET(::vg::Subpath, _impl_.score_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::KmerMatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::KmerMatch, _impl_.sequence_),
  PROTOBUF_FIELD_OFFSET(::vg::KmerMatch, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::vg::KmerMatch, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::vg::KmerMatch, _impl_.backward_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::BasePileup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::BasePileup, _impl_.ref_base_),
  PROTOBUF_FIELD_OFFSET(::vg::BasePileup, _impl_.num_bases_),
  PROTOBUF_FIELD_OFFSET(::vg::BasePileup, _impl_.bases_),
  PROTOBUF_FIELD_OFFSET(::vg::BasePileup, _impl_.qualities_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::NodePileup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::NodePileup, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::vg::NodePileup, _impl_.base_pileup_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::EdgePileup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::EdgePileup, _impl_.edge_),
  PROTOBUF_FIELD_OFFSET(::vg::EdgePileup, _impl_.num_reads_),
  PROTOBUF_FIELD_OFFSET(::vg::EdgePileup, _impl_.num_forward_reads_),
  PROTOBUF_FIELD_OFFSET(::vg::EdgePileup, _impl_.qualities_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Pileup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Pileup, _impl_.node_pileups_),
  PROTOBUF_FIELD_OFFSET(::vg::Pileup, _impl_.edge_pileups_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.end_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.parent_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.start_self_reachable_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.end_self_reachable_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.start_end_reachable_),
  PROTOBUF_FIELD_OFFSET(::vg::Snarl, _impl_.directed_acyclic_net_graph_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Visit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Visit, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::vg::Visit, _impl_.snarl_),
  PROTOBUF_FIELD_OFFSET(::vg::Visit, _impl_.backward_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::SnarlTraversal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::SnarlTraversal, _impl_.visit_),
  PROTOBUF_FIELD_OFFSET(::vg::SnarlTraversal, _impl_.name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Locus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Locus, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::vg::Locus, _impl_.allele_),
  PROTOBUF_FIELD_OFFSET(::vg::Locus, _impl_.support_),
  PROTOBUF_FIELD_OFFSET(::vg::Locus, _impl_.genotype_),
  PROTOBUF_FIELD_OFFSET(::vg::Locus, _impl_.overall_support_),
  PROTOBUF_FIELD_OFFSET(::vg::Locus, _impl_.allele_log_likelihood_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Genotype, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Genotype, _impl_.allele_),
  PROTOBUF_FIELD_OFFSET(::vg::Genotype, _impl_.is_phased_),
  PROTOBUF_FIELD_OFFSET(::vg::Genotype, _impl_.likelihood_),
  PROTOBUF_FIELD_OFFSET(::vg::Genotype, _impl_.log_likelihood_),
  PROTOBUF_FIELD_OFFSET(::vg::Genotype, _impl_.log_prior_),
  PROTOBUF_FIELD_OFFSET(::vg::Genotype, _impl_.log_posterior_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Support, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Support, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::vg::Support, _impl_.forward_),
  PROTOBUF_FIELD_OFFSET(::vg::Support, _impl_.reverse_),
  PROTOBUF_FIELD_OFFSET(::vg::Support, _impl_.left_),
  PROTOBUF_FIELD_OFFSET(::vg::Support, _impl_.right_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::LocationSupport, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::vg::LocationSupport, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::LocationSupport, _impl_.support_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::vg::LocationSupport, _impl_.oneof_location_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::vg::Translation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::vg::Translation, _impl_.from_),
  PROTOBUF_FIELD_OFFSET(::vg::Translation, _impl_.to_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::vg::Graph)},
  { 9, -1, -1, sizeof(::vg::Node)},
  { 18, -1, -1, sizeof(::vg::Edge)},
  { 29, -1, -1, sizeof(::vg::Edit)},
  { 38, -1, -1, sizeof(::vg::Mapping)},
  { 47, -1, -1, sizeof(::vg::Position)},
  { 57, -1, -1, sizeof(::vg::Path)},
  { 67, -1, -1, sizeof(::vg::Alignment)},
  { 108, -1, -1, sizeof(::vg::MultipathAlignment)},
  { 124, -1, -1, sizeof(::vg::Subpath)},
  { 133, -1, -1, sizeof(::vg::KmerMatch)},
  { 143, -1, -1, sizeof(::vg::BasePileup)},
  { 153, -1, -1, sizeof(::vg::NodePileup)},
  { 161, -1, -1, sizeof(::vg::EdgePileup)},
  { 171, -1, -1, sizeof(::vg::Pileup)},
  { 179, -1, -1, sizeof(::vg::Snarl)},
  { 194, -1, -1, sizeof(::vg::Visit)},
  { 203, -1, -1, sizeof(::vg::SnarlTraversal)},
  { 211, -1, -1, sizeof(::vg::Locus)},
  { 223, -1, -1, sizeof(::vg::Genotype)},
  { 235, -1, -1, sizeof(::vg::Support)},
  { 246, -1, -1, sizeof(::vg::LocationSupport)},
  { 256, -1, -1, sizeof(::vg::Translation)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::vg::_Graph_default_instance_._instance,
  &::vg::_Node_default_instance_._instance,
  &::vg::_Edge_default_instance_._instance,
  &::vg::_Edit_default_instance_._instance,
  &::vg::_Mapping_default_instance_._instance,
  &::vg::_Position_default_instance_._instance,
  &::vg::_Path_default_instance_._instance,
  &::vg::_Alignment_default_instance_._instance,
  &::vg::_MultipathAlignment_default_instance_._instance,
  &::vg::_Subpath_default_instance_._instance,
  &::vg::_KmerMatch_default_instance_._instance,
  &::vg::_BasePileup_default_instance_._instance,
  &::vg::_NodePileup_default_instance_._instance,
  &::vg::_EdgePileup_default_instance_._instance,
  &::vg::_Pileup_default_instance_._instance,
  &::vg::_Snarl_default_instance_._instance,
  &::vg::_Visit_default_instance_._instance,
  &::vg::_SnarlTraversal_default_instance_._instance,
  &::vg::_Locus_default_instance_._instance,
  &::vg::_Genotype_default_instance_._instance,
  &::vg::_Support_default_instance_._instance,
  &::vg::_LocationSupport_default_instance_._instance,
  &::vg::_Translation_default_instance_._instance,
};

const char descriptor_table_protodef_vg_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\010vg.proto\022\002vg\032\034google/protobuf/struct.p"
  "roto\"O\n\005Graph\022\026\n\004node\030\001 \003(\0132\010.vg.Node\022\026\n"
  "\004edge\030\002 \003(\0132\010.vg.Edge\022\026\n\004path\030\003 \003(\0132\010.vg"
  ".Path\"2\n\004Node\022\020\n\010sequence\030\001 \001(\t\022\014\n\004name\030"
  "\002 \001(\t\022\n\n\002id\030\003 \001(\003\"U\n\004Edge\022\014\n\004from\030\001 \001(\003\022"
  "\n\n\002to\030\002 \001(\003\022\022\n\nfrom_start\030\003 \001(\010\022\016\n\006to_en"
  "d\030\004 \001(\010\022\017\n\007overlap\030\005 \001(\005\"@\n\004Edit\022\023\n\013from"
  "_length\030\001 \001(\005\022\021\n\tto_length\030\002 \001(\005\022\020\n\010sequ"
  "ence\030\003 \001(\t\"O\n\007Mapping\022\036\n\010position\030\001 \001(\0132"
  "\014.vg.Position\022\026\n\004edit\030\002 \003(\0132\010.vg.Edit\022\014\n"
  "\004rank\030\005 \001(\003\"M\n\010Position\022\017\n\007node_id\030\001 \001(\003"
  "\022\016\n\006offset\030\002 \001(\003\022\022\n\nis_reverse\030\004 \001(\010\022\014\n\004"
  "name\030\005 \001(\t\"W\n\004Path\022\014\n\004name\030\001 \001(\t\022\034\n\007mapp"
  "ing\030\002 \003(\0132\013.vg.Mapping\022\023\n\013is_circular\030\003 "
  "\001(\010\022\016\n\006length\030\004 \001(\003\"\223\007\n\tAlignment\022\020\n\010seq"
  "uence\030\001 \001(\t\022\026\n\004path\030\002 \001(\0132\010.vg.Path\022\014\n\004n"
  "ame\030\003 \001(\t\022\017\n\007quality\030\004 \001(\014\022\027\n\017mapping_qu"
  "ality\030\005 \001(\005\022\r\n\005score\030\006 \001(\005\022\026\n\016query_posi"
  "tion\030\007 \001(\005\022\023\n\013sample_name\030\t \001(\t\022\022\n\nread_"
  "group\030\n \001(\t\022$\n\rfragment_prev\030\013 \001(\0132\r.vg."
  "Alignment\022$\n\rfragment_next\030\014 \001(\0132\r.vg.Al"
  "ignment\022\024\n\014is_secondary\030\017 \001(\010\022\020\n\010identit"
  "y\030\020 \001(\001\022\032\n\010fragment\030\021 \003(\0132\010.vg.Path\022\030\n\005l"
  "ocus\030\022 \003(\0132\t.vg.Locus\022\034\n\006refpos\030\023 \003(\0132\014."
  "vg.Position\022\023\n\013read_paired\030\024 \001(\010\022\023\n\013read"
  "_mapped\030\025 \001(\010\022\025\n\rmate_unmapped\030\026 \001(\010\022\036\n\026"
  "read_on_reverse_strand\030\027 \001(\010\022\036\n\026mate_on_"
  "reverse_strand\030\030 \001(\010\022\024\n\014soft_clipped\030\031 \001"
  "(\010\022\036\n\026discordant_insert_size\030\032 \001(\010\022\022\n\nun"
  "iqueness\030\033 \001(\001\022\017\n\007correct\030\034 \001(\001\022\027\n\017secon"
  "dary_score\030\035 \003(\005\022\026\n\016fragment_score\030\036 \001(\001"
  "\022(\n mate_mapped_to_disjoint_subgraph\030\037 \001"
  "(\010\022$\n\034fragment_length_distribution\030  \001(\t"
  "\022\030\n\020haplotype_scored\030! \001(\010\022\031\n\021haplotype_"
  "logprob\030\" \001(\001\022\021\n\ttime_used\030# \001(\001\022 \n\nto_c"
  "orrect\030$ \001(\0132\014.vg.Position\022\030\n\020correctly_"
  "mapped\030% \001(\010\022+\n\nannotation\030d \001(\0132\027.googl"
  "e.protobuf.Struct\"\373\001\n\022MultipathAlignment"
  "\022\020\n\010sequence\030\001 \001(\t\022\017\n\007quality\030\002 \001(\014\022\014\n\004n"
  "ame\030\003 \001(\t\022\023\n\013sample_name\030\004 \001(\t\022\022\n\nread_g"
  "roup\030\005 \001(\t\022\034\n\007subpath\030\006 \003(\0132\013.vg.Subpath"
  "\022\027\n\017mapping_quality\030\007 \001(\005\022\r\n\005start\030\010 \003(\r"
  "\022\030\n\020paired_read_name\030\t \001(\t\022+\n\nannotation"
  "\030d \001(\0132\027.google.protobuf.Struct\">\n\007Subpa"
  "th\022\026\n\004path\030\001 \001(\0132\010.vg.Path\022\014\n\004next\030\002 \003(\r"
  "\022\r\n\005score\030\003 \001(\005\"R\n\tKmerMatch\022\020\n\010sequence"
  "\030\001 \001(\t\022\017\n\007node_id\030\002 \001(\003\022\020\n\010position\030\003 \001("
  "\021\022\020\n\010backward\030\004 \001(\010\"S\n\nBasePileup\022\020\n\010ref"
  "_base\030\001 \001(\005\022\021\n\tnum_bases\030\002 \001(\005\022\r\n\005bases\030"
  "\003 \001(\t\022\021\n\tqualities\030\004 \001(\014\"B\n\nNodePileup\022\017"
  "\n\007node_id\030\001 \001(\003\022#\n\013base_pileup\030\002 \003(\0132\016.v"
  "g.BasePileup\"e\n\nEdgePileup\022\026\n\004edge\030\001 \001(\013"
  "2\010.vg.Edge\022\021\n\tnum_reads\030\002 \001(\005\022\031\n\021num_for"
  "ward_reads\030\003 \001(\005\022\021\n\tqualities\030\004 \001(\014\"T\n\006P"
  "ileup\022$\n\014node_pileups\030\001 \003(\0132\016.vg.NodePil"
  "eup\022$\n\014edge_pileups\030\002 \003(\0132\016.vg.EdgePileu"
  "p\"\372\001\n\005Snarl\022\033\n\004type\030\001 \001(\0162\r.vg.SnarlType"
  "\022\030\n\005start\030\002 \001(\0132\t.vg.Visit\022\026\n\003end\030\003 \001(\0132"
  "\t.vg.Visit\022\031\n\006parent\030\004 \001(\0132\t.vg.Snarl\022\014\n"
  "\004name\030\005 \001(\t\022\034\n\024start_self_reachable\030\006 \001("
  "\010\022\032\n\022end_self_reachable\030\007 \001(\010\022\033\n\023start_e"
  "nd_reachable\030\010 \001(\010\022\"\n\032directed_acyclic_n"
  "et_graph\030\t \001(\010\"D\n\005Visit\022\017\n\007node_id\030\001 \001(\003"
  "\022\030\n\005snarl\030\002 \001(\0132\t.vg.Snarl\022\020\n\010backward\030\003"
  " \001(\010\"8\n\016SnarlTraversal\022\030\n\005visit\030\001 \003(\0132\t."
  "vg.Visit\022\014\n\004name\030\002 \001(\t\"\262\001\n\005Locus\022\014\n\004name"
  "\030\001 \001(\t\022\030\n\006allele\030\002 \003(\0132\010.vg.Path\022\034\n\007supp"
  "ort\030\003 \003(\0132\013.vg.Support\022\036\n\010genotype\030\004 \003(\013"
  "2\014.vg.Genotype\022$\n\017overall_support\030\005 \001(\0132"
  "\013.vg.Support\022\035\n\025allele_log_likelihood\030\006 "
  "\003(\001\"\203\001\n\010Genotype\022\016\n\006allele\030\001 \003(\005\022\021\n\tis_p"
  "hased\030\002 \001(\010\022\022\n\nlikelihood\030\003 \001(\001\022\026\n\016log_l"
  "ikelihood\030\004 \001(\001\022\021\n\tlog_prior\030\005 \001(\001\022\025\n\rlo"
  "g_posterior\030\006 \001(\001\"Y\n\007Support\022\017\n\007quality\030"
  "\001 \001(\001\022\017\n\007forward\030\002 \001(\001\022\017\n\007reverse\030\003 \001(\001\022"
  "\014\n\004left\030\004 \001(\001\022\r\n\005right\030\005 \001(\001\"n\n\017Location"
  "Support\022\034\n\007support\030\001 \001(\0132\013.vg.Support\022\030\n"
  "\004edge\030\002 \001(\0132\010.vg.EdgeH\000\022\021\n\007node_id\030\003 \001(\003"
  "H\000B\020\n\016oneof_location\";\n\013Translation\022\026\n\004f"
  "rom\030\001 \001(\0132\010.vg.Path\022\024\n\002to\030\002 \001(\0132\010.vg.Pat"
  "h*9\n\tSnarlType\022\020\n\014UNCLASSIFIED\020\000\022\017\n\013ULTR"
  "ABUBBLE\020\001\022\t\n\005UNARY\020\002b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_vg_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fstruct_2eproto,
};
static ::_pbi::once_flag descriptor_table_vg_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_vg_2eproto = {
    false, false, 3268, descriptor_table_protodef_vg_2eproto,
    "vg.proto",
    &descriptor_table_vg_2eproto_once, descriptor_table_vg_2eproto_deps, 1, 23,
    schemas, file_default_instances, TableStruct_vg_2eproto::offsets,
    file_level_metadata_vg_2eproto, file_level_enum_descriptors_vg_2eproto,
    file_level_service_descriptors_vg_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_vg_2eproto_getter() {
  return &descriptor_table_vg_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_vg_2eproto(&descriptor_table_vg_2eproto);
namespace vg {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SnarlType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_vg_2eproto);
  return file_level_enum_descriptors_vg_2eproto[0];
}
bool SnarlType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class Graph::_Internal {
 public:
};

Graph::Graph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Graph)
}
Graph::Graph(const Graph& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Graph* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.node_){from._impl_.node_}
    , decltype(_impl_.edge_){from._impl_.edge_}
    , decltype(_impl_.path_){from._impl_.path_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vg.Graph)
}

inline void Graph::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.node_){arena}
    , decltype(_impl_.edge_){arena}
    , decltype(_impl_.path_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Graph::~Graph() {
  // @@protoc_insertion_point(destructor:vg.Graph)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Graph::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_.~RepeatedPtrField();
  _impl_.edge_.~RepeatedPtrField();
  _impl_.path_.~RepeatedPtrField();
}

void Graph::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Graph::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Graph)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.node_.Clear();
  _impl_.edge_.Clear();
  _impl_.path_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Graph::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vg.Node node = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Edge edge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_edge(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Path path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_path(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Graph::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Graph)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vg.Node node = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_size()); i < n; i++) {
    const auto& repfield = this->_internal_node(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vg.Edge edge = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_edge_size()); i < n; i++) {
    const auto& repfield = this->_internal_edge(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vg.Path path = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_path_size()); i < n; i++) {
    const auto& repfield = this->_internal_path(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Graph)
  return target;
}

size_t Graph::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Graph)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.Node node = 1;
  total_size += 1UL * this->_internal_node_size();
  for (const auto& msg : this->_impl_.node_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vg.Edge edge = 2;
  total_size += 1UL * this->_internal_edge_size();
  for (const auto& msg : this->_impl_.edge_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vg.Path path = 3;
  total_size += 1UL * this->_internal_path_size();
  for (const auto& msg : this->_impl_.path_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Graph::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Graph::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Graph::GetClassData() const { return &_class_data_; }


void Graph::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Graph*>(&to_msg);
  auto& from = static_cast<const Graph&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Graph)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.node_.MergeFrom(from._impl_.node_);
  _this->_impl_.edge_.MergeFrom(from._impl_.edge_);
  _this->_impl_.path_.MergeFrom(from._impl_.path_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Graph::CopyFrom(const Graph& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Graph)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Graph::IsInitialized() const {
  return true;
}

void Graph::InternalSwap(Graph* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.node_.InternalSwap(&other->_impl_.node_);
  _impl_.edge_.InternalSwap(&other->_impl_.edge_);
  _impl_.path_.InternalSwap(&other->_impl_.path_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Graph::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[0]);
}

// ===================================================================

class Node::_Internal {
 public:
};

Node::Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Node)
}
Node::Node(const Node& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Node* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sequence_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequence().empty()) {
    _this->_impl_.sequence_.Set(from._internal_sequence(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.id_ = from._impl_.id_;
  // @@protoc_insertion_point(copy_constructor:vg.Node)
}

inline void Node::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sequence_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.id_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Node::~Node() {
  // @@protoc_insertion_point(destructor:vg.Node)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Node::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sequence_.Destroy();
  _impl_.name_.Destroy();
}

void Node::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Node::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Node)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sequence_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Node::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sequence();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Node.sequence"));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Node.name"));
        } else
          goto handle_unusual;
        continue;
      // int64 id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Node::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Node)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequence().data(), static_cast<int>(this->_internal_sequence().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Node.sequence");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sequence(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Node.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // int64 id = 3;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Node)
  return target;
}

size_t Node::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Node)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequence());
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int64 id = 3;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Node::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Node::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Node::GetClassData() const { return &_class_data_; }


void Node::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Node*>(&to_msg);
  auto& from = static_cast<const Node&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Node)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sequence().empty()) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_id() != 0) {
    _this->_internal_set_id(from._internal_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Node::CopyFrom(const Node& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Node)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Node::IsInitialized() const {
  return true;
}

void Node::InternalSwap(Node* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sequence_, lhs_arena,
      &other->_impl_.sequence_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.id_, other->_impl_.id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Node::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[1]);
}

// ===================================================================

class Edge::_Internal {
 public:
};

Edge::Edge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Edge)
}
Edge::Edge(const Edge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Edge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){}
    , decltype(_impl_.to_){}
    , decltype(_impl_.from_start_){}
    , decltype(_impl_.to_end_){}
    , decltype(_impl_.overlap_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.from_, &from._impl_.from_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.overlap_) -
    reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.overlap_));
  // @@protoc_insertion_point(copy_constructor:vg.Edge)
}

inline void Edge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){int64_t{0}}
    , decltype(_impl_.to_){int64_t{0}}
    , decltype(_impl_.from_start_){false}
    , decltype(_impl_.to_end_){false}
    , decltype(_impl_.overlap_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Edge::~Edge() {
  // @@protoc_insertion_point(destructor:vg.Edge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Edge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Edge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Edge::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Edge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.from_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.overlap_) -
      reinterpret_cast<char*>(&_impl_.from_)) + sizeof(_impl_.overlap_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Edge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 from = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 to = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.to_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool from_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.from_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool to_end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.to_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 overlap = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.overlap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Edge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Edge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 from = 1;
  if (this->_internal_from() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_from(), target);
  }

  // int64 to = 2;
  if (this->_internal_to() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_to(), target);
  }

  // bool from_start = 3;
  if (this->_internal_from_start() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_from_start(), target);
  }

  // bool to_end = 4;
  if (this->_internal_to_end() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_to_end(), target);
  }

  // int32 overlap = 5;
  if (this->_internal_overlap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_overlap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Edge)
  return target;
}

size_t Edge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Edge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int64 from = 1;
  if (this->_internal_from() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_from());
  }

  // int64 to = 2;
  if (this->_internal_to() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_to());
  }

  // bool from_start = 3;
  if (this->_internal_from_start() != 0) {
    total_size += 1 + 1;
  }

  // bool to_end = 4;
  if (this->_internal_to_end() != 0) {
    total_size += 1 + 1;
  }

  // int32 overlap = 5;
  if (this->_internal_overlap() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_overlap());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Edge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Edge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Edge::GetClassData() const { return &_class_data_; }


void Edge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Edge*>(&to_msg);
  auto& from = static_cast<const Edge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Edge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_from() != 0) {
    _this->_internal_set_from(from._internal_from());
  }
  if (from._internal_to() != 0) {
    _this->_internal_set_to(from._internal_to());
  }
  if (from._internal_from_start() != 0) {
    _this->_internal_set_from_start(from._internal_from_start());
  }
  if (from._internal_to_end() != 0) {
    _this->_internal_set_to_end(from._internal_to_end());
  }
  if (from._internal_overlap() != 0) {
    _this->_internal_set_overlap(from._internal_overlap());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Edge::CopyFrom(const Edge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Edge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Edge::IsInitialized() const {
  return true;
}

void Edge::InternalSwap(Edge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Edge, _impl_.overlap_)
      + sizeof(Edge::_impl_.overlap_)
      - PROTOBUF_FIELD_OFFSET(Edge, _impl_.from_)>(
          reinterpret_cast<char*>(&_impl_.from_),
          reinterpret_cast<char*>(&other->_impl_.from_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Edge::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[2]);
}

// ===================================================================

class Edit::_Internal {
 public:
};

Edit::Edit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Edit)
}
Edit::Edit(const Edit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Edit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sequence_){}
    , decltype(_impl_.from_length_){}
    , decltype(_impl_.to_length_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequence().empty()) {
    _this->_impl_.sequence_.Set(from._internal_sequence(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.from_length_, &from._impl_.from_length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.to_length_) -
    reinterpret_cast<char*>(&_impl_.from_length_)) + sizeof(_impl_.to_length_));
  // @@protoc_insertion_point(copy_constructor:vg.Edit)
}

inline void Edit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sequence_){}
    , decltype(_impl_.from_length_){0}
    , decltype(_impl_.to_length_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Edit::~Edit() {
  // @@protoc_insertion_point(destructor:vg.Edit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Edit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sequence_.Destroy();
}

void Edit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Edit::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Edit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sequence_.ClearToEmpty();
  ::memset(&_impl_.from_length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.to_length_) -
      reinterpret_cast<char*>(&_impl_.from_length_)) + sizeof(_impl_.to_length_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Edit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 from_length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.from_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 to_length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.to_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string sequence = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_sequence();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Edit.sequence"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Edit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Edit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 from_length = 1;
  if (this->_internal_from_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_from_length(), target);
  }

  // int32 to_length = 2;
  if (this->_internal_to_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_to_length(), target);
  }

  // string sequence = 3;
  if (!this->_internal_sequence().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequence().data(), static_cast<int>(this->_internal_sequence().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Edit.sequence");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_sequence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Edit)
  return target;
}

size_t Edit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Edit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sequence = 3;
  if (!this->_internal_sequence().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequence());
  }

  // int32 from_length = 1;
  if (this->_internal_from_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_from_length());
  }

  // int32 to_length = 2;
  if (this->_internal_to_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_to_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Edit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Edit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Edit::GetClassData() const { return &_class_data_; }


void Edit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Edit*>(&to_msg);
  auto& from = static_cast<const Edit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Edit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sequence().empty()) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  if (from._internal_from_length() != 0) {
    _this->_internal_set_from_length(from._internal_from_length());
  }
  if (from._internal_to_length() != 0) {
    _this->_internal_set_to_length(from._internal_to_length());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Edit::CopyFrom(const Edit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Edit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Edit::IsInitialized() const {
  return true;
}

void Edit::InternalSwap(Edit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sequence_, lhs_arena,
      &other->_impl_.sequence_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Edit, _impl_.to_length_)
      + sizeof(Edit::_impl_.to_length_)
      - PROTOBUF_FIELD_OFFSET(Edit, _impl_.from_length_)>(
          reinterpret_cast<char*>(&_impl_.from_length_),
          reinterpret_cast<char*>(&other->_impl_.from_length_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Edit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[3]);
}

// ===================================================================

class Mapping::_Internal {
 public:
  static const ::vg::Position& position(const Mapping* msg);
};

const ::vg::Position&
Mapping::_Internal::position(const Mapping* msg) {
  return *msg->_impl_.position_;
}
Mapping::Mapping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Mapping)
}
Mapping::Mapping(const Mapping& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Mapping* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.edit_){from._impl_.edit_}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rank_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_position()) {
    _this->_impl_.position_ = new ::vg::Position(*from._impl_.position_);
  }
  _this->_impl_.rank_ = from._impl_.rank_;
  // @@protoc_insertion_point(copy_constructor:vg.Mapping)
}

inline void Mapping::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.edit_){arena}
    , decltype(_impl_.position_){nullptr}
    , decltype(_impl_.rank_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Mapping::~Mapping() {
  // @@protoc_insertion_point(destructor:vg.Mapping)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Mapping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.edit_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.position_;
}

void Mapping::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Mapping::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Mapping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.edit_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.position_ != nullptr) {
    delete _impl_.position_;
  }
  _impl_.position_ = nullptr;
  _impl_.rank_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Mapping::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vg.Position position = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_position(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Edit edit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_edit(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int64 rank = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.rank_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Mapping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Mapping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vg.Position position = 1;
  if (this->_internal_has_position()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::position(this),
        _Internal::position(this).GetCachedSize(), target, stream);
  }

  // repeated .vg.Edit edit = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_edit_size()); i < n; i++) {
    const auto& repfield = this->_internal_edit(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int64 rank = 5;
  if (this->_internal_rank() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_rank(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Mapping)
  return target;
}

size_t Mapping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Mapping)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.Edit edit = 2;
  total_size += 1UL * this->_internal_edit_size();
  for (const auto& msg : this->_impl_.edit_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .vg.Position position = 1;
  if (this->_internal_has_position()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.position_);
  }

  // int64 rank = 5;
  if (this->_internal_rank() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_rank());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Mapping::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Mapping::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Mapping::GetClassData() const { return &_class_data_; }


void Mapping::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Mapping*>(&to_msg);
  auto& from = static_cast<const Mapping&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Mapping)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.edit_.MergeFrom(from._impl_.edit_);
  if (from._internal_has_position()) {
    _this->_internal_mutable_position()->::vg::Position::MergeFrom(
        from._internal_position());
  }
  if (from._internal_rank() != 0) {
    _this->_internal_set_rank(from._internal_rank());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Mapping::CopyFrom(const Mapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Mapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mapping::IsInitialized() const {
  return true;
}

void Mapping::InternalSwap(Mapping* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.edit_.InternalSwap(&other->_impl_.edit_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Mapping, _impl_.rank_)
      + sizeof(Mapping::_impl_.rank_)
      - PROTOBUF_FIELD_OFFSET(Mapping, _impl_.position_)>(
          reinterpret_cast<char*>(&_impl_.position_),
          reinterpret_cast<char*>(&other->_impl_.position_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Mapping::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[4]);
}

// ===================================================================

class Position::_Internal {
 public:
};

Position::Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Position)
}
Position::Position(const Position& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Position* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.offset_){}
    , decltype(_impl_.is_reverse_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_reverse_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.is_reverse_));
  // @@protoc_insertion_point(copy_constructor:vg.Position)
}

inline void Position::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.node_id_){int64_t{0}}
    , decltype(_impl_.offset_){int64_t{0}}
    , decltype(_impl_.is_reverse_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Position::~Position() {
  // @@protoc_insertion_point(destructor:vg.Position)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Position::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void Position::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Position::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Position)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_reverse_) -
      reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.is_reverse_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Position::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_reverse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.is_reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Position.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Position::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Position)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 node_id = 1;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_node_id(), target);
  }

  // int64 offset = 2;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_offset(), target);
  }

  // bool is_reverse = 4;
  if (this->_internal_is_reverse() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_reverse(), target);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Position.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Position)
  return target;
}

size_t Position::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Position)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int64 node_id = 1;
  if (this->_internal_node_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_node_id());
  }

  // int64 offset = 2;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
  }

  // bool is_reverse = 4;
  if (this->_internal_is_reverse() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Position::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Position::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Position::GetClassData() const { return &_class_data_; }


void Position::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Position*>(&to_msg);
  auto& from = static_cast<const Position&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Position)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_node_id() != 0) {
    _this->_internal_set_node_id(from._internal_node_id());
  }
  if (from._internal_offset() != 0) {
    _this->_internal_set_offset(from._internal_offset());
  }
  if (from._internal_is_reverse() != 0) {
    _this->_internal_set_is_reverse(from._internal_is_reverse());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Position::CopyFrom(const Position& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Position)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Position::IsInitialized() const {
  return true;
}

void Position::InternalSwap(Position* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Position, _impl_.is_reverse_)
      + sizeof(Position::_impl_.is_reverse_)
      - PROTOBUF_FIELD_OFFSET(Position, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Position::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[5]);
}

// ===================================================================

class Path::_Internal {
 public:
};

Path::Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Path)
}
Path::Path(const Path& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Path* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.mapping_){from._impl_.mapping_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.length_){}
    , decltype(_impl_.is_circular_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.length_, &from._impl_.length_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_circular_) -
    reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.is_circular_));
  // @@protoc_insertion_point(copy_constructor:vg.Path)
}

inline void Path::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.mapping_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.length_){int64_t{0}}
    , decltype(_impl_.is_circular_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Path::~Path() {
  // @@protoc_insertion_point(destructor:vg.Path)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Path::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mapping_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void Path::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Path::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Path)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.mapping_.Clear();
  _impl_.name_.ClearToEmpty();
  ::memset(&_impl_.length_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_circular_) -
      reinterpret_cast<char*>(&_impl_.length_)) + sizeof(_impl_.is_circular_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Path::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Path.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Mapping mapping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_mapping(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool is_circular = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.is_circular_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Path::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Path)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Path.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .vg.Mapping mapping = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_mapping_size()); i < n; i++) {
    const auto& repfield = this->_internal_mapping(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool is_circular = 3;
  if (this->_internal_is_circular() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_circular(), target);
  }

  // int64 length = 4;
  if (this->_internal_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Path)
  return target;
}

size_t Path::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Path)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.Mapping mapping = 2;
  total_size += 1UL * this->_internal_mapping_size();
  for (const auto& msg : this->_impl_.mapping_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // int64 length = 4;
  if (this->_internal_length() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
  }

  // bool is_circular = 3;
  if (this->_internal_is_circular() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Path::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Path::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Path::GetClassData() const { return &_class_data_; }


void Path::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Path*>(&to_msg);
  auto& from = static_cast<const Path&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Path)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.mapping_.MergeFrom(from._impl_.mapping_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_length() != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  if (from._internal_is_circular() != 0) {
    _this->_internal_set_is_circular(from._internal_is_circular());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Path::CopyFrom(const Path& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Path::IsInitialized() const {
  return true;
}

void Path::InternalSwap(Path* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.mapping_.InternalSwap(&other->_impl_.mapping_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Path, _impl_.is_circular_)
      + sizeof(Path::_impl_.is_circular_)
      - PROTOBUF_FIELD_OFFSET(Path, _impl_.length_)>(
          reinterpret_cast<char*>(&_impl_.length_),
          reinterpret_cast<char*>(&other->_impl_.length_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Path::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[6]);
}

// ===================================================================

class Alignment::_Internal {
 public:
  static const ::vg::Path& path(const Alignment* msg);
  static const ::vg::Alignment& fragment_prev(const Alignment* msg);
  static const ::vg::Alignment& fragment_next(const Alignment* msg);
  static const ::vg::Position& to_correct(const Alignment* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Struct& annotation(const Alignment* msg);
};

const ::vg::Path&
Alignment::_Internal::path(const Alignment* msg) {
  return *msg->_impl_.path_;
}
const ::vg::Alignment&
Alignment::_Internal::fragment_prev(const Alignment* msg) {
  return *msg->_impl_.fragment_prev_;
}
const ::vg::Alignment&
Alignment::_Internal::fragment_next(const Alignment* msg) {
  return *msg->_impl_.fragment_next_;
}
const ::vg::Position&
Alignment::_Internal::to_correct(const Alignment* msg) {
  return *msg->_impl_.to_correct_;
}
const ::PROTOBUF_NAMESPACE_ID::Struct&
Alignment::_Internal::annotation(const Alignment* msg) {
  return *msg->_impl_.annotation_;
}
void Alignment::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
}
Alignment::Alignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Alignment)
}
Alignment::Alignment(const Alignment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Alignment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.fragment_){from._impl_.fragment_}
    , decltype(_impl_.locus_){from._impl_.locus_}
    , decltype(_impl_.refpos_){from._impl_.refpos_}
    , decltype(_impl_.secondary_score_){from._impl_.secondary_score_}
    , /*decltype(_impl_._secondary_score_cached_byte_size_)*/{0}
    , decltype(_impl_.sequence_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.sample_name_){}
    , decltype(_impl_.read_group_){}
    , decltype(_impl_.fragment_length_distribution_){}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.fragment_prev_){nullptr}
    , decltype(_impl_.fragment_next_){nullptr}
    , decltype(_impl_.to_correct_){nullptr}
    , decltype(_impl_.annotation_){nullptr}
    , decltype(_impl_.mapping_quality_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.identity_){}
    , decltype(_impl_.query_position_){}
    , decltype(_impl_.is_secondary_){}
    , decltype(_impl_.read_paired_){}
    , decltype(_impl_.read_mapped_){}
    , decltype(_impl_.mate_unmapped_){}
    , decltype(_impl_.uniqueness_){}
    , decltype(_impl_.correct_){}
    , decltype(_impl_.read_on_reverse_strand_){}
    , decltype(_impl_.mate_on_reverse_strand_){}
    , decltype(_impl_.soft_clipped_){}
    , decltype(_impl_.discordant_insert_size_){}
    , decltype(_impl_.mate_mapped_to_disjoint_subgraph_){}
    , decltype(_impl_.haplotype_scored_){}
    , decltype(_impl_.correctly_mapped_){}
    , decltype(_impl_.fragment_score_){}
    , decltype(_impl_.haplotype_logprob_){}
    , decltype(_impl_.time_used_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequence().empty()) {
    _this->_impl_.sequence_.Set(from._internal_sequence(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.quality_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quality_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quality().empty()) {
    _this->_impl_.quality_.Set(from._internal_quality(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sample_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sample_name().empty()) {
    _this->_impl_.sample_name_.Set(from._internal_sample_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_group().empty()) {
    _this->_impl_.read_group_.Set(from._internal_read_group(), 
      _this->GetArenaForAllocation());
  }
  _impl_.fragment_length_distribution_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fragment_length_distribution_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_fragment_length_distribution().empty()) {
    _this->_impl_.fragment_length_distribution_.Set(from._internal_fragment_length_distribution(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::vg::Path(*from._impl_.path_);
  }
  if (from._internal_has_fragment_prev()) {
    _this->_impl_.fragment_prev_ = new ::vg::Alignment(*from._impl_.fragment_prev_);
  }
  if (from._internal_has_fragment_next()) {
    _this->_impl_.fragment_next_ = new ::vg::Alignment(*from._impl_.fragment_next_);
  }
  if (from._internal_has_to_correct()) {
    _this->_impl_.to_correct_ = new ::vg::Position(*from._impl_.to_correct_);
  }
  if (from._internal_has_annotation()) {
    _this->_impl_.annotation_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.annotation_);
  }
  ::memcpy(&_impl_.mapping_quality_, &from._impl_.mapping_quality_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_used_) -
    reinterpret_cast<char*>(&_impl_.mapping_quality_)) + sizeof(_impl_.time_used_));
  // @@protoc_insertion_point(copy_constructor:vg.Alignment)
}

inline void Alignment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.fragment_){arena}
    , decltype(_impl_.locus_){arena}
    , decltype(_impl_.refpos_){arena}
    , decltype(_impl_.secondary_score_){arena}
    , /*decltype(_impl_._secondary_score_cached_byte_size_)*/{0}
    , decltype(_impl_.sequence_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.sample_name_){}
    , decltype(_impl_.read_group_){}
    , decltype(_impl_.fragment_length_distribution_){}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.fragment_prev_){nullptr}
    , decltype(_impl_.fragment_next_){nullptr}
    , decltype(_impl_.to_correct_){nullptr}
    , decltype(_impl_.annotation_){nullptr}
    , decltype(_impl_.mapping_quality_){0}
    , decltype(_impl_.score_){0}
    , decltype(_impl_.identity_){0}
    , decltype(_impl_.query_position_){0}
    , decltype(_impl_.is_secondary_){false}
    , decltype(_impl_.read_paired_){false}
    , decltype(_impl_.read_mapped_){false}
    , decltype(_impl_.mate_unmapped_){false}
    , decltype(_impl_.uniqueness_){0}
    , decltype(_impl_.correct_){0}
    , decltype(_impl_.read_on_reverse_strand_){false}
    , decltype(_impl_.mate_on_reverse_strand_){false}
    , decltype(_impl_.soft_clipped_){false}
    , decltype(_impl_.discordant_insert_size_){false}
    , decltype(_impl_.mate_mapped_to_disjoint_subgraph_){false}
    , decltype(_impl_.haplotype_scored_){false}
    , decltype(_impl_.correctly_mapped_){false}
    , decltype(_impl_.fragment_score_){0}
    , decltype(_impl_.haplotype_logprob_){0}
    , decltype(_impl_.time_used_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quality_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quality_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sample_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fragment_length_distribution_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.fragment_length_distribution_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Alignment::~Alignment() {
  // @@protoc_insertion_point(destructor:vg.Alignment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Alignment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fragment_.~RepeatedPtrField();
  _impl_.locus_.~RepeatedPtrField();
  _impl_.refpos_.~RepeatedPtrField();
  _impl_.secondary_score_.~RepeatedField();
  _impl_.sequence_.Destroy();
  _impl_.name_.Destroy();
  _impl_.quality_.Destroy();
  _impl_.sample_name_.Destroy();
  _impl_.read_group_.Destroy();
  _impl_.fragment_length_distribution_.Destroy();
  if (this != internal_default_instance()) delete _impl_.path_;
  if (this != internal_default_instance()) delete _impl_.fragment_prev_;
  if (this != internal_default_instance()) delete _impl_.fragment_next_;
  if (this != internal_default_instance()) delete _impl_.to_correct_;
  if (this != internal_default_instance()) delete _impl_.annotation_;
}

void Alignment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Alignment::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Alignment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fragment_.Clear();
  _impl_.locus_.Clear();
  _impl_.refpos_.Clear();
  _impl_.secondary_score_.Clear();
  _impl_.sequence_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.quality_.ClearToEmpty();
  _impl_.sample_name_.ClearToEmpty();
  _impl_.read_group_.ClearToEmpty();
  _impl_.fragment_length_distribution_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.path_ != nullptr) {
    delete _impl_.path_;
  }
  _impl_.path_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.fragment_prev_ != nullptr) {
    delete _impl_.fragment_prev_;
  }
  _impl_.fragment_prev_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.fragment_next_ != nullptr) {
    delete _impl_.fragment_next_;
  }
  _impl_.fragment_next_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.to_correct_ != nullptr) {
    delete _impl_.to_correct_;
  }
  _impl_.to_correct_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
  ::memset(&_impl_.mapping_quality_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.time_used_) -
      reinterpret_cast<char*>(&_impl_.mapping_quality_)) + sizeof(_impl_.time_used_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Alignment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sequence();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Alignment.sequence"));
        } else
          goto handle_unusual;
        continue;
      // .vg.Path path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Alignment.name"));
        } else
          goto handle_unusual;
        continue;
      // bytes quality = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_quality();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 mapping_quality = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.mapping_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 score = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 query_position = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.query_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string sample_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_sample_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Alignment.sample_name"));
        } else
          goto handle_unusual;
        continue;
      // string read_group = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_read_group();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Alignment.read_group"));
        } else
          goto handle_unusual;
        continue;
      // .vg.Alignment fragment_prev = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_fragment_prev(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vg.Alignment fragment_next = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_fragment_next(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_secondary = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _impl_.is_secondary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double identity = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _impl_.identity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Path fragment = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_fragment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Locus locus = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_locus(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Position refpos = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_refpos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<154>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool read_paired = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _impl_.read_paired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool read_mapped = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.read_mapped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool mate_unmapped = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.mate_unmapped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool read_on_reverse_strand = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _impl_.read_on_reverse_strand_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool mate_on_reverse_strand = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _impl_.mate_on_reverse_strand_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool soft_clipped = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.soft_clipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool discordant_insert_size = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _impl_.discordant_insert_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double uniqueness = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 217)) {
          _impl_.uniqueness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double correct = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 225)) {
          _impl_.correct_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 secondary_score = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_secondary_score(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 232) {
          _internal_add_secondary_score(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fragment_score = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 241)) {
          _impl_.fragment_score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool mate_mapped_to_disjoint_subgraph = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _impl_.mate_mapped_to_disjoint_subgraph_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string fragment_length_distribution = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_fragment_length_distribution();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Alignment.fragment_length_distribution"));
        } else
          goto handle_unusual;
        continue;
      // bool haplotype_scored = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.haplotype_scored_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double haplotype_logprob = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.haplotype_logprob_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double time_used = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.time_used_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // .vg.Position to_correct = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_to_correct(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool correctly_mapped = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.correctly_mapped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct annotation = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_annotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Alignment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Alignment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequence().data(), static_cast<int>(this->_internal_sequence().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Alignment.sequence");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sequence(), target);
  }

  // .vg.Path path = 2;
  if (this->_internal_has_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Alignment.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // bytes quality = 4;
  if (!this->_internal_quality().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_quality(), target);
  }

  // int32 mapping_quality = 5;
  if (this->_internal_mapping_quality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mapping_quality(), target);
  }

  // int32 score = 6;
  if (this->_internal_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_score(), target);
  }

  // int32 query_position = 7;
  if (this->_internal_query_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_query_position(), target);
  }

  // string sample_name = 9;
  if (!this->_internal_sample_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sample_name().data(), static_cast<int>(this->_internal_sample_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Alignment.sample_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_sample_name(), target);
  }

  // string read_group = 10;
  if (!this->_internal_read_group().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_read_group().data(), static_cast<int>(this->_internal_read_group().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Alignment.read_group");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_read_group(), target);
  }

  // .vg.Alignment fragment_prev = 11;
  if (this->_internal_has_fragment_prev()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::fragment_prev(this),
        _Internal::fragment_prev(this).GetCachedSize(), target, stream);
  }

  // .vg.Alignment fragment_next = 12;
  if (this->_internal_has_fragment_next()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::fragment_next(this),
        _Internal::fragment_next(this).GetCachedSize(), target, stream);
  }

  // bool is_secondary = 15;
  if (this->_internal_is_secondary() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_secondary(), target);
  }

  // double identity = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_identity = this->_internal_identity();
  uint64_t raw_identity;
  memcpy(&raw_identity, &tmp_identity, sizeof(tmp_identity));
  if (raw_identity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(16, this->_internal_identity(), target);
  }

  // repeated .vg.Path fragment = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fragment_size()); i < n; i++) {
    const auto& repfield = this->_internal_fragment(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vg.Locus locus = 18;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_locus_size()); i < n; i++) {
    const auto& repfield = this->_internal_locus(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(18, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vg.Position refpos = 19;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_refpos_size()); i < n; i++) {
    const auto& repfield = this->_internal_refpos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(19, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool read_paired = 20;
  if (this->_internal_read_paired() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_read_paired(), target);
  }

  // bool read_mapped = 21;
  if (this->_internal_read_mapped() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_read_mapped(), target);
  }

  // bool mate_unmapped = 22;
  if (this->_internal_mate_unmapped() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_mate_unmapped(), target);
  }

  // bool read_on_reverse_strand = 23;
  if (this->_internal_read_on_reverse_strand() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_read_on_reverse_strand(), target);
  }

  // bool mate_on_reverse_strand = 24;
  if (this->_internal_mate_on_reverse_strand() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_mate_on_reverse_strand(), target);
  }

  // bool soft_clipped = 25;
  if (this->_internal_soft_clipped() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_soft_clipped(), target);
  }

  // bool discordant_insert_size = 26;
  if (this->_internal_discordant_insert_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_discordant_insert_size(), target);
  }

  // double uniqueness = 27;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_uniqueness = this->_internal_uniqueness();
  uint64_t raw_uniqueness;
  memcpy(&raw_uniqueness, &tmp_uniqueness, sizeof(tmp_uniqueness));
  if (raw_uniqueness != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(27, this->_internal_uniqueness(), target);
  }

  // double correct = 28;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_correct = this->_internal_correct();
  uint64_t raw_correct;
  memcpy(&raw_correct, &tmp_correct, sizeof(tmp_correct));
  if (raw_correct != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(28, this->_internal_correct(), target);
  }

  // repeated int32 secondary_score = 29;
  {
    int byte_size = _impl_._secondary_score_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          29, _internal_secondary_score(), byte_size, target);
    }
  }

  // double fragment_score = 30;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fragment_score = this->_internal_fragment_score();
  uint64_t raw_fragment_score;
  memcpy(&raw_fragment_score, &tmp_fragment_score, sizeof(tmp_fragment_score));
  if (raw_fragment_score != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(30, this->_internal_fragment_score(), target);
  }

  // bool mate_mapped_to_disjoint_subgraph = 31;
  if (this->_internal_mate_mapped_to_disjoint_subgraph() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(31, this->_internal_mate_mapped_to_disjoint_subgraph(), target);
  }

  // string fragment_length_distribution = 32;
  if (!this->_internal_fragment_length_distribution().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_fragment_length_distribution().data(), static_cast<int>(this->_internal_fragment_length_distribution().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Alignment.fragment_length_distribution");
    target = stream->WriteStringMaybeAliased(
        32, this->_internal_fragment_length_distribution(), target);
  }

  // bool haplotype_scored = 33;
  if (this->_internal_haplotype_scored() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(33, this->_internal_haplotype_scored(), target);
  }

  // double haplotype_logprob = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_haplotype_logprob = this->_internal_haplotype_logprob();
  uint64_t raw_haplotype_logprob;
  memcpy(&raw_haplotype_logprob, &tmp_haplotype_logprob, sizeof(tmp_haplotype_logprob));
  if (raw_haplotype_logprob != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(34, this->_internal_haplotype_logprob(), target);
  }

  // double time_used = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_used = this->_internal_time_used();
  uint64_t raw_time_used;
  memcpy(&raw_time_used, &tmp_time_used, sizeof(tmp_time_used));
  if (raw_time_used != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(35, this->_internal_time_used(), target);
  }

  // .vg.Position to_correct = 36;
  if (this->_internal_has_to_correct()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(36, _Internal::to_correct(this),
        _Internal::to_correct(this).GetCachedSize(), target, stream);
  }

  // bool correctly_mapped = 37;
  if (this->_internal_correctly_mapped() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(37, this->_internal_correctly_mapped(), target);
  }

  // .google.protobuf.Struct annotation = 100;
  if (this->_internal_has_annotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(100, _Internal::annotation(this),
        _Internal::annotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Alignment)
  return target;
}

size_t Alignment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Alignment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.Path fragment = 17;
  total_size += 2UL * this->_internal_fragment_size();
  for (const auto& msg : this->_impl_.fragment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vg.Locus locus = 18;
  total_size += 2UL * this->_internal_locus_size();
  for (const auto& msg : this->_impl_.locus_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vg.Position refpos = 19;
  total_size += 2UL * this->_internal_refpos_size();
  for (const auto& msg : this->_impl_.refpos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 secondary_score = 29;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.secondary_score_);
    if (data_size > 0) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._secondary_score_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequence());
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // bytes quality = 4;
  if (!this->_internal_quality().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_quality());
  }

  // string sample_name = 9;
  if (!this->_internal_sample_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sample_name());
  }

  // string read_group = 10;
  if (!this->_internal_read_group().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_read_group());
  }

  // string fragment_length_distribution = 32;
  if (!this->_internal_fragment_length_distribution().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_fragment_length_distribution());
  }

  // .vg.Path path = 2;
  if (this->_internal_has_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.path_);
  }

  // .vg.Alignment fragment_prev = 11;
  if (this->_internal_has_fragment_prev()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fragment_prev_);
  }

  // .vg.Alignment fragment_next = 12;
  if (this->_internal_has_fragment_next()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.fragment_next_);
  }

  // .vg.Position to_correct = 36;
  if (this->_internal_has_to_correct()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.to_correct_);
  }

  // .google.protobuf.Struct annotation = 100;
  if (this->_internal_has_annotation()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.annotation_);
  }

  // int32 mapping_quality = 5;
  if (this->_internal_mapping_quality() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mapping_quality());
  }

  // int32 score = 6;
  if (this->_internal_score() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_score());
  }

  // double identity = 16;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_identity = this->_internal_identity();
  uint64_t raw_identity;
  memcpy(&raw_identity, &tmp_identity, sizeof(tmp_identity));
  if (raw_identity != 0) {
    total_size += 2 + 8;
  }

  // int32 query_position = 7;
  if (this->_internal_query_position() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_query_position());
  }

  // bool is_secondary = 15;
  if (this->_internal_is_secondary() != 0) {
    total_size += 1 + 1;
  }

  // bool read_paired = 20;
  if (this->_internal_read_paired() != 0) {
    total_size += 2 + 1;
  }

  // bool read_mapped = 21;
  if (this->_internal_read_mapped() != 0) {
    total_size += 2 + 1;
  }

  // bool mate_unmapped = 22;
  if (this->_internal_mate_unmapped() != 0) {
    total_size += 2 + 1;
  }

  // double uniqueness = 27;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_uniqueness = this->_internal_uniqueness();
  uint64_t raw_uniqueness;
  memcpy(&raw_uniqueness, &tmp_uniqueness, sizeof(tmp_uniqueness));
  if (raw_uniqueness != 0) {
    total_size += 2 + 8;
  }

  // double correct = 28;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_correct = this->_internal_correct();
  uint64_t raw_correct;
  memcpy(&raw_correct, &tmp_correct, sizeof(tmp_correct));
  if (raw_correct != 0) {
    total_size += 2 + 8;
  }

  // bool read_on_reverse_strand = 23;
  if (this->_internal_read_on_reverse_strand() != 0) {
    total_size += 2 + 1;
  }

  // bool mate_on_reverse_strand = 24;
  if (this->_internal_mate_on_reverse_strand() != 0) {
    total_size += 2 + 1;
  }

  // bool soft_clipped = 25;
  if (this->_internal_soft_clipped() != 0) {
    total_size += 2 + 1;
  }

  // bool discordant_insert_size = 26;
  if (this->_internal_discordant_insert_size() != 0) {
    total_size += 2 + 1;
  }

  // bool mate_mapped_to_disjoint_subgraph = 31;
  if (this->_internal_mate_mapped_to_disjoint_subgraph() != 0) {
    total_size += 2 + 1;
  }

  // bool haplotype_scored = 33;
  if (this->_internal_haplotype_scored() != 0) {
    total_size += 2 + 1;
  }

  // bool correctly_mapped = 37;
  if (this->_internal_correctly_mapped() != 0) {
    total_size += 2 + 1;
  }

  // double fragment_score = 30;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fragment_score = this->_internal_fragment_score();
  uint64_t raw_fragment_score;
  memcpy(&raw_fragment_score, &tmp_fragment_score, sizeof(tmp_fragment_score));
  if (raw_fragment_score != 0) {
    total_size += 2 + 8;
  }

  // double haplotype_logprob = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_haplotype_logprob = this->_internal_haplotype_logprob();
  uint64_t raw_haplotype_logprob;
  memcpy(&raw_haplotype_logprob, &tmp_haplotype_logprob, sizeof(tmp_haplotype_logprob));
  if (raw_haplotype_logprob != 0) {
    total_size += 2 + 8;
  }

  // double time_used = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_used = this->_internal_time_used();
  uint64_t raw_time_used;
  memcpy(&raw_time_used, &tmp_time_used, sizeof(tmp_time_used));
  if (raw_time_used != 0) {
    total_size += 2 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Alignment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Alignment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Alignment::GetClassData() const { return &_class_data_; }


void Alignment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Alignment*>(&to_msg);
  auto& from = static_cast<const Alignment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Alignment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fragment_.MergeFrom(from._impl_.fragment_);
  _this->_impl_.locus_.MergeFrom(from._impl_.locus_);
  _this->_impl_.refpos_.MergeFrom(from._impl_.refpos_);
  _this->_impl_.secondary_score_.MergeFrom(from._impl_.secondary_score_);
  if (!from._internal_sequence().empty()) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_quality().empty()) {
    _this->_internal_set_quality(from._internal_quality());
  }
  if (!from._internal_sample_name().empty()) {
    _this->_internal_set_sample_name(from._internal_sample_name());
  }
  if (!from._internal_read_group().empty()) {
    _this->_internal_set_read_group(from._internal_read_group());
  }
  if (!from._internal_fragment_length_distribution().empty()) {
    _this->_internal_set_fragment_length_distribution(from._internal_fragment_length_distribution());
  }
  if (from._internal_has_path()) {
    _this->_internal_mutable_path()->::vg::Path::MergeFrom(
        from._internal_path());
  }
  if (from._internal_has_fragment_prev()) {
    _this->_internal_mutable_fragment_prev()->::vg::Alignment::MergeFrom(
        from._internal_fragment_prev());
  }
  if (from._internal_has_fragment_next()) {
    _this->_internal_mutable_fragment_next()->::vg::Alignment::MergeFrom(
        from._internal_fragment_next());
  }
  if (from._internal_has_to_correct()) {
    _this->_internal_mutable_to_correct()->::vg::Position::MergeFrom(
        from._internal_to_correct());
  }
  if (from._internal_has_annotation()) {
    _this->_internal_mutable_annotation()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_annotation());
  }
  if (from._internal_mapping_quality() != 0) {
    _this->_internal_set_mapping_quality(from._internal_mapping_quality());
  }
  if (from._internal_score() != 0) {
    _this->_internal_set_score(from._internal_score());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_identity = from._internal_identity();
  uint64_t raw_identity;
  memcpy(&raw_identity, &tmp_identity, sizeof(tmp_identity));
  if (raw_identity != 0) {
    _this->_internal_set_identity(from._internal_identity());
  }
  if (from._internal_query_position() != 0) {
    _this->_internal_set_query_position(from._internal_query_position());
  }
  if (from._internal_is_secondary() != 0) {
    _this->_internal_set_is_secondary(from._internal_is_secondary());
  }
  if (from._internal_read_paired() != 0) {
    _this->_internal_set_read_paired(from._internal_read_paired());
  }
  if (from._internal_read_mapped() != 0) {
    _this->_internal_set_read_mapped(from._internal_read_mapped());
  }
  if (from._internal_mate_unmapped() != 0) {
    _this->_internal_set_mate_unmapped(from._internal_mate_unmapped());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_uniqueness = from._internal_uniqueness();
  uint64_t raw_uniqueness;
  memcpy(&raw_uniqueness, &tmp_uniqueness, sizeof(tmp_uniqueness));
  if (raw_uniqueness != 0) {
    _this->_internal_set_uniqueness(from._internal_uniqueness());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_correct = from._internal_correct();
  uint64_t raw_correct;
  memcpy(&raw_correct, &tmp_correct, sizeof(tmp_correct));
  if (raw_correct != 0) {
    _this->_internal_set_correct(from._internal_correct());
  }
  if (from._internal_read_on_reverse_strand() != 0) {
    _this->_internal_set_read_on_reverse_strand(from._internal_read_on_reverse_strand());
  }
  if (from._internal_mate_on_reverse_strand() != 0) {
    _this->_internal_set_mate_on_reverse_strand(from._internal_mate_on_reverse_strand());
  }
  if (from._internal_soft_clipped() != 0) {
    _this->_internal_set_soft_clipped(from._internal_soft_clipped());
  }
  if (from._internal_discordant_insert_size() != 0) {
    _this->_internal_set_discordant_insert_size(from._internal_discordant_insert_size());
  }
  if (from._internal_mate_mapped_to_disjoint_subgraph() != 0) {
    _this->_internal_set_mate_mapped_to_disjoint_subgraph(from._internal_mate_mapped_to_disjoint_subgraph());
  }
  if (from._internal_haplotype_scored() != 0) {
    _this->_internal_set_haplotype_scored(from._internal_haplotype_scored());
  }
  if (from._internal_correctly_mapped() != 0) {
    _this->_internal_set_correctly_mapped(from._internal_correctly_mapped());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fragment_score = from._internal_fragment_score();
  uint64_t raw_fragment_score;
  memcpy(&raw_fragment_score, &tmp_fragment_score, sizeof(tmp_fragment_score));
  if (raw_fragment_score != 0) {
    _this->_internal_set_fragment_score(from._internal_fragment_score());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_haplotype_logprob = from._internal_haplotype_logprob();
  uint64_t raw_haplotype_logprob;
  memcpy(&raw_haplotype_logprob, &tmp_haplotype_logprob, sizeof(tmp_haplotype_logprob));
  if (raw_haplotype_logprob != 0) {
    _this->_internal_set_haplotype_logprob(from._internal_haplotype_logprob());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_time_used = from._internal_time_used();
  uint64_t raw_time_used;
  memcpy(&raw_time_used, &tmp_time_used, sizeof(tmp_time_used));
  if (raw_time_used != 0) {
    _this->_internal_set_time_used(from._internal_time_used());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Alignment::CopyFrom(const Alignment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Alignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Alignment::IsInitialized() const {
  return true;
}

void Alignment::InternalSwap(Alignment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.fragment_.InternalSwap(&other->_impl_.fragment_);
  _impl_.locus_.InternalSwap(&other->_impl_.locus_);
  _impl_.refpos_.InternalSwap(&other->_impl_.refpos_);
  _impl_.secondary_score_.InternalSwap(&other->_impl_.secondary_score_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sequence_, lhs_arena,
      &other->_impl_.sequence_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.quality_, lhs_arena,
      &other->_impl_.quality_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sample_name_, lhs_arena,
      &other->_impl_.sample_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_group_, lhs_arena,
      &other->_impl_.read_group_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.fragment_length_distribution_, lhs_arena,
      &other->_impl_.fragment_length_distribution_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Alignment, _impl_.time_used_)
      + sizeof(Alignment::_impl_.time_used_)
      - PROTOBUF_FIELD_OFFSET(Alignment, _impl_.path_)>(
          reinterpret_cast<char*>(&_impl_.path_),
          reinterpret_cast<char*>(&other->_impl_.path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Alignment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[7]);
}

// ===================================================================

class MultipathAlignment::_Internal {
 public:
  static const ::PROTOBUF_NAMESPACE_ID::Struct& annotation(const MultipathAlignment* msg);
};

const ::PROTOBUF_NAMESPACE_ID::Struct&
MultipathAlignment::_Internal::annotation(const MultipathAlignment* msg) {
  return *msg->_impl_.annotation_;
}
void MultipathAlignment::clear_annotation() {
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
}
MultipathAlignment::MultipathAlignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.MultipathAlignment)
}
MultipathAlignment::MultipathAlignment(const MultipathAlignment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  MultipathAlignment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.subpath_){from._impl_.subpath_}
    , decltype(_impl_.start_){from._impl_.start_}
    , /*decltype(_impl_._start_cached_byte_size_)*/{0}
    , decltype(_impl_.sequence_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.sample_name_){}
    , decltype(_impl_.read_group_){}
    , decltype(_impl_.paired_read_name_){}
    , decltype(_impl_.annotation_){nullptr}
    , decltype(_impl_.mapping_quality_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequence().empty()) {
    _this->_impl_.sequence_.Set(from._internal_sequence(), 
      _this->GetArenaForAllocation());
  }
  _impl_.quality_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quality_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_quality().empty()) {
    _this->_impl_.quality_.Set(from._internal_quality(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sample_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sample_name().empty()) {
    _this->_impl_.sample_name_.Set(from._internal_sample_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.read_group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_read_group().empty()) {
    _this->_impl_.read_group_.Set(from._internal_read_group(), 
      _this->GetArenaForAllocation());
  }
  _impl_.paired_read_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paired_read_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_paired_read_name().empty()) {
    _this->_impl_.paired_read_name_.Set(from._internal_paired_read_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_annotation()) {
    _this->_impl_.annotation_ = new ::PROTOBUF_NAMESPACE_ID::Struct(*from._impl_.annotation_);
  }
  _this->_impl_.mapping_quality_ = from._impl_.mapping_quality_;
  // @@protoc_insertion_point(copy_constructor:vg.MultipathAlignment)
}

inline void MultipathAlignment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.subpath_){arena}
    , decltype(_impl_.start_){arena}
    , /*decltype(_impl_._start_cached_byte_size_)*/{0}
    , decltype(_impl_.sequence_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.sample_name_){}
    , decltype(_impl_.read_group_){}
    , decltype(_impl_.paired_read_name_){}
    , decltype(_impl_.annotation_){nullptr}
    , decltype(_impl_.mapping_quality_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.quality_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.quality_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sample_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sample_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.read_group_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.read_group_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.paired_read_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paired_read_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

MultipathAlignment::~MultipathAlignment() {
  // @@protoc_insertion_point(destructor:vg.MultipathAlignment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MultipathAlignment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subpath_.~RepeatedPtrField();
  _impl_.start_.~RepeatedField();
  _impl_.sequence_.Destroy();
  _impl_.quality_.Destroy();
  _impl_.name_.Destroy();
  _impl_.sample_name_.Destroy();
  _impl_.read_group_.Destroy();
  _impl_.paired_read_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.annotation_;
}

void MultipathAlignment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void MultipathAlignment::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.MultipathAlignment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subpath_.Clear();
  _impl_.start_.Clear();
  _impl_.sequence_.ClearToEmpty();
  _impl_.quality_.ClearToEmpty();
  _impl_.name_.ClearToEmpty();
  _impl_.sample_name_.ClearToEmpty();
  _impl_.read_group_.ClearToEmpty();
  _impl_.paired_read_name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.annotation_ != nullptr) {
    delete _impl_.annotation_;
  }
  _impl_.annotation_ = nullptr;
  _impl_.mapping_quality_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MultipathAlignment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sequence();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.MultipathAlignment.sequence"));
        } else
          goto handle_unusual;
        continue;
      // bytes quality = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_quality();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.MultipathAlignment.name"));
        } else
          goto handle_unusual;
        continue;
      // string sample_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_sample_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.MultipathAlignment.sample_name"));
        } else
          goto handle_unusual;
        continue;
      // string read_group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_read_group();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.MultipathAlignment.read_group"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Subpath subpath = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_subpath(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 mapping_quality = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.mapping_quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 start = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_start(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          _internal_add_start(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string paired_read_name = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_paired_read_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.MultipathAlignment.paired_read_name"));
        } else
          goto handle_unusual;
        continue;
      // .google.protobuf.Struct annotation = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_annotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MultipathAlignment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.MultipathAlignment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequence().data(), static_cast<int>(this->_internal_sequence().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.MultipathAlignment.sequence");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sequence(), target);
  }

  // bytes quality = 2;
  if (!this->_internal_quality().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_quality(), target);
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.MultipathAlignment.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // string sample_name = 4;
  if (!this->_internal_sample_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sample_name().data(), static_cast<int>(this->_internal_sample_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.MultipathAlignment.sample_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_sample_name(), target);
  }

  // string read_group = 5;
  if (!this->_internal_read_group().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_read_group().data(), static_cast<int>(this->_internal_read_group().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.MultipathAlignment.read_group");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_read_group(), target);
  }

  // repeated .vg.Subpath subpath = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_subpath_size()); i < n; i++) {
    const auto& repfield = this->_internal_subpath(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 mapping_quality = 7;
  if (this->_internal_mapping_quality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_mapping_quality(), target);
  }

  // repeated uint32 start = 8;
  {
    int byte_size = _impl_._start_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          8, _internal_start(), byte_size, target);
    }
  }

  // string paired_read_name = 9;
  if (!this->_internal_paired_read_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_paired_read_name().data(), static_cast<int>(this->_internal_paired_read_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.MultipathAlignment.paired_read_name");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_paired_read_name(), target);
  }

  // .google.protobuf.Struct annotation = 100;
  if (this->_internal_has_annotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(100, _Internal::annotation(this),
        _Internal::annotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.MultipathAlignment)
  return target;
}

size_t MultipathAlignment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.MultipathAlignment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.Subpath subpath = 6;
  total_size += 1UL * this->_internal_subpath_size();
  for (const auto& msg : this->_impl_.subpath_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated uint32 start = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.start_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._start_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequence());
  }

  // bytes quality = 2;
  if (!this->_internal_quality().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_quality());
  }

  // string name = 3;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string sample_name = 4;
  if (!this->_internal_sample_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sample_name());
  }

  // string read_group = 5;
  if (!this->_internal_read_group().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_read_group());
  }

  // string paired_read_name = 9;
  if (!this->_internal_paired_read_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_paired_read_name());
  }

  // .google.protobuf.Struct annotation = 100;
  if (this->_internal_has_annotation()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.annotation_);
  }

  // int32 mapping_quality = 7;
  if (this->_internal_mapping_quality() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mapping_quality());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData MultipathAlignment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    MultipathAlignment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*MultipathAlignment::GetClassData() const { return &_class_data_; }


void MultipathAlignment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<MultipathAlignment*>(&to_msg);
  auto& from = static_cast<const MultipathAlignment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.MultipathAlignment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subpath_.MergeFrom(from._impl_.subpath_);
  _this->_impl_.start_.MergeFrom(from._impl_.start_);
  if (!from._internal_sequence().empty()) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  if (!from._internal_quality().empty()) {
    _this->_internal_set_quality(from._internal_quality());
  }
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_sample_name().empty()) {
    _this->_internal_set_sample_name(from._internal_sample_name());
  }
  if (!from._internal_read_group().empty()) {
    _this->_internal_set_read_group(from._internal_read_group());
  }
  if (!from._internal_paired_read_name().empty()) {
    _this->_internal_set_paired_read_name(from._internal_paired_read_name());
  }
  if (from._internal_has_annotation()) {
    _this->_internal_mutable_annotation()->::PROTOBUF_NAMESPACE_ID::Struct::MergeFrom(
        from._internal_annotation());
  }
  if (from._internal_mapping_quality() != 0) {
    _this->_internal_set_mapping_quality(from._internal_mapping_quality());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void MultipathAlignment::CopyFrom(const MultipathAlignment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.MultipathAlignment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultipathAlignment::IsInitialized() const {
  return true;
}

void MultipathAlignment::InternalSwap(MultipathAlignment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.subpath_.InternalSwap(&other->_impl_.subpath_);
  _impl_.start_.InternalSwap(&other->_impl_.start_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sequence_, lhs_arena,
      &other->_impl_.sequence_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.quality_, lhs_arena,
      &other->_impl_.quality_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sample_name_, lhs_arena,
      &other->_impl_.sample_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.read_group_, lhs_arena,
      &other->_impl_.read_group_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.paired_read_name_, lhs_arena,
      &other->_impl_.paired_read_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MultipathAlignment, _impl_.mapping_quality_)
      + sizeof(MultipathAlignment::_impl_.mapping_quality_)
      - PROTOBUF_FIELD_OFFSET(MultipathAlignment, _impl_.annotation_)>(
          reinterpret_cast<char*>(&_impl_.annotation_),
          reinterpret_cast<char*>(&other->_impl_.annotation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MultipathAlignment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[8]);
}

// ===================================================================

class Subpath::_Internal {
 public:
  static const ::vg::Path& path(const Subpath* msg);
};

const ::vg::Path&
Subpath::_Internal::path(const Subpath* msg) {
  return *msg->_impl_.path_;
}
Subpath::Subpath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Subpath)
}
Subpath::Subpath(const Subpath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Subpath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.next_){from._impl_.next_}
    , /*decltype(_impl_._next_cached_byte_size_)*/{0}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.score_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_path()) {
    _this->_impl_.path_ = new ::vg::Path(*from._impl_.path_);
  }
  _this->_impl_.score_ = from._impl_.score_;
  // @@protoc_insertion_point(copy_constructor:vg.Subpath)
}

inline void Subpath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.next_){arena}
    , /*decltype(_impl_._next_cached_byte_size_)*/{0}
    , decltype(_impl_.path_){nullptr}
    , decltype(_impl_.score_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Subpath::~Subpath() {
  // @@protoc_insertion_point(destructor:vg.Subpath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Subpath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.next_.~RepeatedField();
  if (this != internal_default_instance()) delete _impl_.path_;
}

void Subpath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Subpath::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Subpath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.next_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.path_ != nullptr) {
    delete _impl_.path_;
  }
  _impl_.path_ = nullptr;
  _impl_.score_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Subpath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vg.Path path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_path(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 next = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_next(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_next(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 score = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Subpath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Subpath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vg.Path path = 1;
  if (this->_internal_has_path()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::path(this),
        _Internal::path(this).GetCachedSize(), target, stream);
  }

  // repeated uint32 next = 2;
  {
    int byte_size = _impl_._next_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          2, _internal_next(), byte_size, target);
    }
  }

  // int32 score = 3;
  if (this->_internal_score() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_score(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Subpath)
  return target;
}

size_t Subpath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Subpath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 next = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.next_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._next_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // .vg.Path path = 1;
  if (this->_internal_has_path()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.path_);
  }

  // int32 score = 3;
  if (this->_internal_score() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_score());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Subpath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Subpath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Subpath::GetClassData() const { return &_class_data_; }


void Subpath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Subpath*>(&to_msg);
  auto& from = static_cast<const Subpath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Subpath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.next_.MergeFrom(from._impl_.next_);
  if (from._internal_has_path()) {
    _this->_internal_mutable_path()->::vg::Path::MergeFrom(
        from._internal_path());
  }
  if (from._internal_score() != 0) {
    _this->_internal_set_score(from._internal_score());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Subpath::CopyFrom(const Subpath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Subpath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Subpath::IsInitialized() const {
  return true;
}

void Subpath::InternalSwap(Subpath* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.next_.InternalSwap(&other->_impl_.next_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Subpath, _impl_.score_)
      + sizeof(Subpath::_impl_.score_)
      - PROTOBUF_FIELD_OFFSET(Subpath, _impl_.path_)>(
          reinterpret_cast<char*>(&_impl_.path_),
          reinterpret_cast<char*>(&other->_impl_.path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Subpath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[9]);
}

// ===================================================================

class KmerMatch::_Internal {
 public:
};

KmerMatch::KmerMatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.KmerMatch)
}
KmerMatch::KmerMatch(const KmerMatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  KmerMatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.sequence_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.position_){}
    , decltype(_impl_.backward_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sequence().empty()) {
    _this->_impl_.sequence_.Set(from._internal_sequence(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.backward_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.backward_));
  // @@protoc_insertion_point(copy_constructor:vg.KmerMatch)
}

inline void KmerMatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.sequence_){}
    , decltype(_impl_.node_id_){int64_t{0}}
    , decltype(_impl_.position_){0}
    , decltype(_impl_.backward_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.sequence_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sequence_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

KmerMatch::~KmerMatch() {
  // @@protoc_insertion_point(destructor:vg.KmerMatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void KmerMatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sequence_.Destroy();
}

void KmerMatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void KmerMatch::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.KmerMatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sequence_.ClearToEmpty();
  ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.backward_) -
      reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.backward_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KmerMatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sequence();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.KmerMatch.sequence"));
        } else
          goto handle_unusual;
        continue;
      // int64 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // sint32 position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool backward = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.backward_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* KmerMatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.KmerMatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_sequence().data(), static_cast<int>(this->_internal_sequence().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.KmerMatch.sequence");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sequence(), target);
  }

  // int64 node_id = 2;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_node_id(), target);
  }

  // sint32 position = 3;
  if (this->_internal_position() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(3, this->_internal_position(), target);
  }

  // bool backward = 4;
  if (this->_internal_backward() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_backward(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.KmerMatch)
  return target;
}

size_t KmerMatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.KmerMatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string sequence = 1;
  if (!this->_internal_sequence().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_sequence());
  }

  // int64 node_id = 2;
  if (this->_internal_node_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_node_id());
  }

  // sint32 position = 3;
  if (this->_internal_position() != 0) {
    total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_position());
  }

  // bool backward = 4;
  if (this->_internal_backward() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KmerMatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    KmerMatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KmerMatch::GetClassData() const { return &_class_data_; }


void KmerMatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<KmerMatch*>(&to_msg);
  auto& from = static_cast<const KmerMatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.KmerMatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_sequence().empty()) {
    _this->_internal_set_sequence(from._internal_sequence());
  }
  if (from._internal_node_id() != 0) {
    _this->_internal_set_node_id(from._internal_node_id());
  }
  if (from._internal_position() != 0) {
    _this->_internal_set_position(from._internal_position());
  }
  if (from._internal_backward() != 0) {
    _this->_internal_set_backward(from._internal_backward());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KmerMatch::CopyFrom(const KmerMatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.KmerMatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KmerMatch::IsInitialized() const {
  return true;
}

void KmerMatch::InternalSwap(KmerMatch* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sequence_, lhs_arena,
      &other->_impl_.sequence_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KmerMatch, _impl_.backward_)
      + sizeof(KmerMatch::_impl_.backward_)
      - PROTOBUF_FIELD_OFFSET(KmerMatch, _impl_.node_id_)>(
          reinterpret_cast<char*>(&_impl_.node_id_),
          reinterpret_cast<char*>(&other->_impl_.node_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KmerMatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[10]);
}

// ===================================================================

class BasePileup::_Internal {
 public:
};

BasePileup::BasePileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.BasePileup)
}
BasePileup::BasePileup(const BasePileup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BasePileup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.bases_){}
    , decltype(_impl_.qualities_){}
    , decltype(_impl_.ref_base_){}
    , decltype(_impl_.num_bases_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.bases_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bases_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bases().empty()) {
    _this->_impl_.bases_.Set(from._internal_bases(), 
      _this->GetArenaForAllocation());
  }
  _impl_.qualities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qualities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_qualities().empty()) {
    _this->_impl_.qualities_.Set(from._internal_qualities(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.ref_base_, &from._impl_.ref_base_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_bases_) -
    reinterpret_cast<char*>(&_impl_.ref_base_)) + sizeof(_impl_.num_bases_));
  // @@protoc_insertion_point(copy_constructor:vg.BasePileup)
}

inline void BasePileup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.bases_){}
    , decltype(_impl_.qualities_){}
    , decltype(_impl_.ref_base_){0}
    , decltype(_impl_.num_bases_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.bases_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bases_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.qualities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qualities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BasePileup::~BasePileup() {
  // @@protoc_insertion_point(destructor:vg.BasePileup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BasePileup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bases_.Destroy();
  _impl_.qualities_.Destroy();
}

void BasePileup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BasePileup::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.BasePileup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.bases_.ClearToEmpty();
  _impl_.qualities_.ClearToEmpty();
  ::memset(&_impl_.ref_base_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.num_bases_) -
      reinterpret_cast<char*>(&_impl_.ref_base_)) + sizeof(_impl_.num_bases_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BasePileup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 ref_base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ref_base_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 num_bases = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.num_bases_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string bases = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_bases();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.BasePileup.bases"));
        } else
          goto handle_unusual;
        continue;
      // bytes qualities = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_qualities();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BasePileup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.BasePileup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 ref_base = 1;
  if (this->_internal_ref_base() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ref_base(), target);
  }

  // int32 num_bases = 2;
  if (this->_internal_num_bases() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_bases(), target);
  }

  // string bases = 3;
  if (!this->_internal_bases().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bases().data(), static_cast<int>(this->_internal_bases().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.BasePileup.bases");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_bases(), target);
  }

  // bytes qualities = 4;
  if (!this->_internal_qualities().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_qualities(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.BasePileup)
  return target;
}

size_t BasePileup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.BasePileup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string bases = 3;
  if (!this->_internal_bases().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_bases());
  }

  // bytes qualities = 4;
  if (!this->_internal_qualities().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_qualities());
  }

  // int32 ref_base = 1;
  if (this->_internal_ref_base() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ref_base());
  }

  // int32 num_bases = 2;
  if (this->_internal_num_bases() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_bases());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BasePileup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BasePileup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BasePileup::GetClassData() const { return &_class_data_; }


void BasePileup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BasePileup*>(&to_msg);
  auto& from = static_cast<const BasePileup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.BasePileup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_bases().empty()) {
    _this->_internal_set_bases(from._internal_bases());
  }
  if (!from._internal_qualities().empty()) {
    _this->_internal_set_qualities(from._internal_qualities());
  }
  if (from._internal_ref_base() != 0) {
    _this->_internal_set_ref_base(from._internal_ref_base());
  }
  if (from._internal_num_bases() != 0) {
    _this->_internal_set_num_bases(from._internal_num_bases());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BasePileup::CopyFrom(const BasePileup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.BasePileup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BasePileup::IsInitialized() const {
  return true;
}

void BasePileup::InternalSwap(BasePileup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bases_, lhs_arena,
      &other->_impl_.bases_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.qualities_, lhs_arena,
      &other->_impl_.qualities_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BasePileup, _impl_.num_bases_)
      + sizeof(BasePileup::_impl_.num_bases_)
      - PROTOBUF_FIELD_OFFSET(BasePileup, _impl_.ref_base_)>(
          reinterpret_cast<char*>(&_impl_.ref_base_),
          reinterpret_cast<char*>(&other->_impl_.ref_base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BasePileup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[11]);
}

// ===================================================================

class NodePileup::_Internal {
 public:
};

NodePileup::NodePileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.NodePileup)
}
NodePileup::NodePileup(const NodePileup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NodePileup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.base_pileup_){from._impl_.base_pileup_}
    , decltype(_impl_.node_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.node_id_ = from._impl_.node_id_;
  // @@protoc_insertion_point(copy_constructor:vg.NodePileup)
}

inline void NodePileup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.base_pileup_){arena}
    , decltype(_impl_.node_id_){int64_t{0}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NodePileup::~NodePileup() {
  // @@protoc_insertion_point(destructor:vg.NodePileup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodePileup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.base_pileup_.~RepeatedPtrField();
}

void NodePileup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NodePileup::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.NodePileup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.base_pileup_.Clear();
  _impl_.node_id_ = int64_t{0};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NodePileup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.BasePileup base_pileup = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_base_pileup(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodePileup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.NodePileup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 node_id = 1;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_node_id(), target);
  }

  // repeated .vg.BasePileup base_pileup = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_base_pileup_size()); i < n; i++) {
    const auto& repfield = this->_internal_base_pileup(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.NodePileup)
  return target;
}

size_t NodePileup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.NodePileup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.BasePileup base_pileup = 2;
  total_size += 1UL * this->_internal_base_pileup_size();
  for (const auto& msg : this->_impl_.base_pileup_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int64 node_id = 1;
  if (this->_internal_node_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_node_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NodePileup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NodePileup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NodePileup::GetClassData() const { return &_class_data_; }


void NodePileup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NodePileup*>(&to_msg);
  auto& from = static_cast<const NodePileup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.NodePileup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.base_pileup_.MergeFrom(from._impl_.base_pileup_);
  if (from._internal_node_id() != 0) {
    _this->_internal_set_node_id(from._internal_node_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NodePileup::CopyFrom(const NodePileup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.NodePileup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodePileup::IsInitialized() const {
  return true;
}

void NodePileup::InternalSwap(NodePileup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.base_pileup_.InternalSwap(&other->_impl_.base_pileup_);
  swap(_impl_.node_id_, other->_impl_.node_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NodePileup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[12]);
}

// ===================================================================

class EdgePileup::_Internal {
 public:
  static const ::vg::Edge& edge(const EdgePileup* msg);
};

const ::vg::Edge&
EdgePileup::_Internal::edge(const EdgePileup* msg) {
  return *msg->_impl_.edge_;
}
EdgePileup::EdgePileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.EdgePileup)
}
EdgePileup::EdgePileup(const EdgePileup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EdgePileup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.qualities_){}
    , decltype(_impl_.edge_){nullptr}
    , decltype(_impl_.num_reads_){}
    , decltype(_impl_.num_forward_reads_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.qualities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qualities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_qualities().empty()) {
    _this->_impl_.qualities_.Set(from._internal_qualities(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_edge()) {
    _this->_impl_.edge_ = new ::vg::Edge(*from._impl_.edge_);
  }
  ::memcpy(&_impl_.num_reads_, &from._impl_.num_reads_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_forward_reads_) -
    reinterpret_cast<char*>(&_impl_.num_reads_)) + sizeof(_impl_.num_forward_reads_));
  // @@protoc_insertion_point(copy_constructor:vg.EdgePileup)
}

inline void EdgePileup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.qualities_){}
    , decltype(_impl_.edge_){nullptr}
    , decltype(_impl_.num_reads_){0}
    , decltype(_impl_.num_forward_reads_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.qualities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.qualities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EdgePileup::~EdgePileup() {
  // @@protoc_insertion_point(destructor:vg.EdgePileup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EdgePileup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.qualities_.Destroy();
  if (this != internal_default_instance()) delete _impl_.edge_;
}

void EdgePileup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EdgePileup::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.EdgePileup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.qualities_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.edge_ != nullptr) {
    delete _impl_.edge_;
  }
  _impl_.edge_ = nullptr;
  ::memset(&_impl_.num_reads_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.num_forward_reads_) -
      reinterpret_cast<char*>(&_impl_.num_reads_)) + sizeof(_impl_.num_forward_reads_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EdgePileup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vg.Edge edge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 num_reads = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.num_reads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 num_forward_reads = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.num_forward_reads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes qualities = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_qualities();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EdgePileup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.EdgePileup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::edge(this),
        _Internal::edge(this).GetCachedSize(), target, stream);
  }

  // int32 num_reads = 2;
  if (this->_internal_num_reads() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_reads(), target);
  }

  // int32 num_forward_reads = 3;
  if (this->_internal_num_forward_reads() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_num_forward_reads(), target);
  }

  // bytes qualities = 4;
  if (!this->_internal_qualities().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_qualities(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.EdgePileup)
  return target;
}

size_t EdgePileup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.EdgePileup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes qualities = 4;
  if (!this->_internal_qualities().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_qualities());
  }

  // .vg.Edge edge = 1;
  if (this->_internal_has_edge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.edge_);
  }

  // int32 num_reads = 2;
  if (this->_internal_num_reads() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_reads());
  }

  // int32 num_forward_reads = 3;
  if (this->_internal_num_forward_reads() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_forward_reads());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EdgePileup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EdgePileup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EdgePileup::GetClassData() const { return &_class_data_; }


void EdgePileup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EdgePileup*>(&to_msg);
  auto& from = static_cast<const EdgePileup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.EdgePileup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_qualities().empty()) {
    _this->_internal_set_qualities(from._internal_qualities());
  }
  if (from._internal_has_edge()) {
    _this->_internal_mutable_edge()->::vg::Edge::MergeFrom(
        from._internal_edge());
  }
  if (from._internal_num_reads() != 0) {
    _this->_internal_set_num_reads(from._internal_num_reads());
  }
  if (from._internal_num_forward_reads() != 0) {
    _this->_internal_set_num_forward_reads(from._internal_num_forward_reads());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EdgePileup::CopyFrom(const EdgePileup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.EdgePileup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EdgePileup::IsInitialized() const {
  return true;
}

void EdgePileup::InternalSwap(EdgePileup* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.qualities_, lhs_arena,
      &other->_impl_.qualities_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EdgePileup, _impl_.num_forward_reads_)
      + sizeof(EdgePileup::_impl_.num_forward_reads_)
      - PROTOBUF_FIELD_OFFSET(EdgePileup, _impl_.edge_)>(
          reinterpret_cast<char*>(&_impl_.edge_),
          reinterpret_cast<char*>(&other->_impl_.edge_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EdgePileup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[13]);
}

// ===================================================================

class Pileup::_Internal {
 public:
};

Pileup::Pileup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Pileup)
}
Pileup::Pileup(const Pileup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Pileup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.node_pileups_){from._impl_.node_pileups_}
    , decltype(_impl_.edge_pileups_){from._impl_.edge_pileups_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:vg.Pileup)
}

inline void Pileup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.node_pileups_){arena}
    , decltype(_impl_.edge_pileups_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Pileup::~Pileup() {
  // @@protoc_insertion_point(destructor:vg.Pileup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Pileup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.node_pileups_.~RepeatedPtrField();
  _impl_.edge_pileups_.~RepeatedPtrField();
}

void Pileup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Pileup::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Pileup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.node_pileups_.Clear();
  _impl_.edge_pileups_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Pileup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vg.NodePileup node_pileups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_node_pileups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.EdgePileup edge_pileups = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_edge_pileups(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Pileup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Pileup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vg.NodePileup node_pileups = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_node_pileups_size()); i < n; i++) {
    const auto& repfield = this->_internal_node_pileups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vg.EdgePileup edge_pileups = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_edge_pileups_size()); i < n; i++) {
    const auto& repfield = this->_internal_edge_pileups(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Pileup)
  return target;
}

size_t Pileup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Pileup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.NodePileup node_pileups = 1;
  total_size += 1UL * this->_internal_node_pileups_size();
  for (const auto& msg : this->_impl_.node_pileups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vg.EdgePileup edge_pileups = 2;
  total_size += 1UL * this->_internal_edge_pileups_size();
  for (const auto& msg : this->_impl_.edge_pileups_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pileup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Pileup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pileup::GetClassData() const { return &_class_data_; }


void Pileup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Pileup*>(&to_msg);
  auto& from = static_cast<const Pileup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Pileup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.node_pileups_.MergeFrom(from._impl_.node_pileups_);
  _this->_impl_.edge_pileups_.MergeFrom(from._impl_.edge_pileups_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Pileup::CopyFrom(const Pileup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Pileup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pileup::IsInitialized() const {
  return true;
}

void Pileup::InternalSwap(Pileup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.node_pileups_.InternalSwap(&other->_impl_.node_pileups_);
  _impl_.edge_pileups_.InternalSwap(&other->_impl_.edge_pileups_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Pileup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[14]);
}

// ===================================================================

class Snarl::_Internal {
 public:
  static const ::vg::Visit& start(const Snarl* msg);
  static const ::vg::Visit& end(const Snarl* msg);
  static const ::vg::Snarl& parent(const Snarl* msg);
};

const ::vg::Visit&
Snarl::_Internal::start(const Snarl* msg) {
  return *msg->_impl_.start_;
}
const ::vg::Visit&
Snarl::_Internal::end(const Snarl* msg) {
  return *msg->_impl_.end_;
}
const ::vg::Snarl&
Snarl::_Internal::parent(const Snarl* msg) {
  return *msg->_impl_.parent_;
}
Snarl::Snarl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Snarl)
}
Snarl::Snarl(const Snarl& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Snarl* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.start_self_reachable_){}
    , decltype(_impl_.end_self_reachable_){}
    , decltype(_impl_.start_end_reachable_){}
    , decltype(_impl_.directed_acyclic_net_graph_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::vg::Visit(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::vg::Visit(*from._impl_.end_);
  }
  if (from._internal_has_parent()) {
    _this->_impl_.parent_ = new ::vg::Snarl(*from._impl_.parent_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.directed_acyclic_net_graph_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.directed_acyclic_net_graph_));
  // @@protoc_insertion_point(copy_constructor:vg.Snarl)
}

inline void Snarl::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.parent_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.start_self_reachable_){false}
    , decltype(_impl_.end_self_reachable_){false}
    , decltype(_impl_.start_end_reachable_){false}
    , decltype(_impl_.directed_acyclic_net_graph_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Snarl::~Snarl() {
  // @@protoc_insertion_point(destructor:vg.Snarl)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Snarl::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
  if (this != internal_default_instance()) delete _impl_.parent_;
}

void Snarl::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Snarl::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Snarl)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
    delete _impl_.start_;
  }
  _impl_.start_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
    delete _impl_.end_;
  }
  _impl_.end_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.parent_ != nullptr) {
    delete _impl_.parent_;
  }
  _impl_.parent_ = nullptr;
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.directed_acyclic_net_graph_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.directed_acyclic_net_graph_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Snarl::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vg.SnarlType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::vg::SnarlType>(val));
        } else
          goto handle_unusual;
        continue;
      // .vg.Visit start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vg.Visit end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vg.Snarl parent = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_parent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Snarl.name"));
        } else
          goto handle_unusual;
        continue;
      // bool start_self_reachable = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.start_self_reachable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool end_self_reachable = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.end_self_reachable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool start_end_reachable = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.start_end_reachable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool directed_acyclic_net_graph = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.directed_acyclic_net_graph_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Snarl::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Snarl)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vg.SnarlType type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // .vg.Visit start = 2;
  if (this->_internal_has_start()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // .vg.Visit end = 3;
  if (this->_internal_has_end()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  // .vg.Snarl parent = 4;
  if (this->_internal_has_parent()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::parent(this),
        _Internal::parent(this).GetCachedSize(), target, stream);
  }

  // string name = 5;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Snarl.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  // bool start_self_reachable = 6;
  if (this->_internal_start_self_reachable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_start_self_reachable(), target);
  }

  // bool end_self_reachable = 7;
  if (this->_internal_end_self_reachable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_end_self_reachable(), target);
  }

  // bool start_end_reachable = 8;
  if (this->_internal_start_end_reachable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_start_end_reachable(), target);
  }

  // bool directed_acyclic_net_graph = 9;
  if (this->_internal_directed_acyclic_net_graph() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_directed_acyclic_net_graph(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Snarl)
  return target;
}

size_t Snarl::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Snarl)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 5;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vg.Visit start = 2;
  if (this->_internal_has_start()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_);
  }

  // .vg.Visit end = 3;
  if (this->_internal_has_end()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.end_);
  }

  // .vg.Snarl parent = 4;
  if (this->_internal_has_parent()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.parent_);
  }

  // .vg.SnarlType type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // bool start_self_reachable = 6;
  if (this->_internal_start_self_reachable() != 0) {
    total_size += 1 + 1;
  }

  // bool end_self_reachable = 7;
  if (this->_internal_end_self_reachable() != 0) {
    total_size += 1 + 1;
  }

  // bool start_end_reachable = 8;
  if (this->_internal_start_end_reachable() != 0) {
    total_size += 1 + 1;
  }

  // bool directed_acyclic_net_graph = 9;
  if (this->_internal_directed_acyclic_net_graph() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Snarl::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Snarl::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Snarl::GetClassData() const { return &_class_data_; }


void Snarl::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Snarl*>(&to_msg);
  auto& from = static_cast<const Snarl&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Snarl)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_start()) {
    _this->_internal_mutable_start()->::vg::Visit::MergeFrom(
        from._internal_start());
  }
  if (from._internal_has_end()) {
    _this->_internal_mutable_end()->::vg::Visit::MergeFrom(
        from._internal_end());
  }
  if (from._internal_has_parent()) {
    _this->_internal_mutable_parent()->::vg::Snarl::MergeFrom(
        from._internal_parent());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_start_self_reachable() != 0) {
    _this->_internal_set_start_self_reachable(from._internal_start_self_reachable());
  }
  if (from._internal_end_self_reachable() != 0) {
    _this->_internal_set_end_self_reachable(from._internal_end_self_reachable());
  }
  if (from._internal_start_end_reachable() != 0) {
    _this->_internal_set_start_end_reachable(from._internal_start_end_reachable());
  }
  if (from._internal_directed_acyclic_net_graph() != 0) {
    _this->_internal_set_directed_acyclic_net_graph(from._internal_directed_acyclic_net_graph());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Snarl::CopyFrom(const Snarl& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Snarl)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Snarl::IsInitialized() const {
  return true;
}

void Snarl::InternalSwap(Snarl* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Snarl, _impl_.directed_acyclic_net_graph_)
      + sizeof(Snarl::_impl_.directed_acyclic_net_graph_)
      - PROTOBUF_FIELD_OFFSET(Snarl, _impl_.start_)>(
          reinterpret_cast<char*>(&_impl_.start_),
          reinterpret_cast<char*>(&other->_impl_.start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Snarl::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[15]);
}

// ===================================================================

class Visit::_Internal {
 public:
  static const ::vg::Snarl& snarl(const Visit* msg);
};

const ::vg::Snarl&
Visit::_Internal::snarl(const Visit* msg) {
  return *msg->_impl_.snarl_;
}
Visit::Visit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Visit)
}
Visit::Visit(const Visit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Visit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.snarl_){nullptr}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.backward_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_snarl()) {
    _this->_impl_.snarl_ = new ::vg::Snarl(*from._impl_.snarl_);
  }
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.backward_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.backward_));
  // @@protoc_insertion_point(copy_constructor:vg.Visit)
}

inline void Visit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.snarl_){nullptr}
    , decltype(_impl_.node_id_){int64_t{0}}
    , decltype(_impl_.backward_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Visit::~Visit() {
  // @@protoc_insertion_point(destructor:vg.Visit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Visit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.snarl_;
}

void Visit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Visit::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Visit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.snarl_ != nullptr) {
    delete _impl_.snarl_;
  }
  _impl_.snarl_ = nullptr;
  ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.backward_) -
      reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.backward_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Visit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int64 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vg.Snarl snarl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_snarl(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool backward = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.backward_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Visit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Visit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int64 node_id = 1;
  if (this->_internal_node_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_node_id(), target);
  }

  // .vg.Snarl snarl = 2;
  if (this->_internal_has_snarl()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::snarl(this),
        _Internal::snarl(this).GetCachedSize(), target, stream);
  }

  // bool backward = 3;
  if (this->_internal_backward() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_backward(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Visit)
  return target;
}

size_t Visit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Visit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vg.Snarl snarl = 2;
  if (this->_internal_has_snarl()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.snarl_);
  }

  // int64 node_id = 1;
  if (this->_internal_node_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_node_id());
  }

  // bool backward = 3;
  if (this->_internal_backward() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Visit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Visit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Visit::GetClassData() const { return &_class_data_; }


void Visit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Visit*>(&to_msg);
  auto& from = static_cast<const Visit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Visit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_snarl()) {
    _this->_internal_mutable_snarl()->::vg::Snarl::MergeFrom(
        from._internal_snarl());
  }
  if (from._internal_node_id() != 0) {
    _this->_internal_set_node_id(from._internal_node_id());
  }
  if (from._internal_backward() != 0) {
    _this->_internal_set_backward(from._internal_backward());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Visit::CopyFrom(const Visit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Visit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Visit::IsInitialized() const {
  return true;
}

void Visit::InternalSwap(Visit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Visit, _impl_.backward_)
      + sizeof(Visit::_impl_.backward_)
      - PROTOBUF_FIELD_OFFSET(Visit, _impl_.snarl_)>(
          reinterpret_cast<char*>(&_impl_.snarl_),
          reinterpret_cast<char*>(&other->_impl_.snarl_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Visit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[16]);
}

// ===================================================================

class SnarlTraversal::_Internal {
 public:
};

SnarlTraversal::SnarlTraversal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.SnarlTraversal)
}
SnarlTraversal::SnarlTraversal(const SnarlTraversal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SnarlTraversal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.visit_){from._impl_.visit_}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:vg.SnarlTraversal)
}

inline void SnarlTraversal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.visit_){arena}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SnarlTraversal::~SnarlTraversal() {
  // @@protoc_insertion_point(destructor:vg.SnarlTraversal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SnarlTraversal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.visit_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void SnarlTraversal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SnarlTraversal::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.SnarlTraversal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.visit_.Clear();
  _impl_.name_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SnarlTraversal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .vg.Visit visit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_visit(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.SnarlTraversal.name"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SnarlTraversal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.SnarlTraversal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .vg.Visit visit = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_visit_size()); i < n; i++) {
    const auto& repfield = this->_internal_visit(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.SnarlTraversal.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.SnarlTraversal)
  return target;
}

size_t SnarlTraversal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.SnarlTraversal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.Visit visit = 1;
  total_size += 1UL * this->_internal_visit_size();
  for (const auto& msg : this->_impl_.visit_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnarlTraversal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SnarlTraversal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnarlTraversal::GetClassData() const { return &_class_data_; }


void SnarlTraversal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SnarlTraversal*>(&to_msg);
  auto& from = static_cast<const SnarlTraversal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.SnarlTraversal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.visit_.MergeFrom(from._impl_.visit_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SnarlTraversal::CopyFrom(const SnarlTraversal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.SnarlTraversal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnarlTraversal::IsInitialized() const {
  return true;
}

void SnarlTraversal::InternalSwap(SnarlTraversal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.visit_.InternalSwap(&other->_impl_.visit_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SnarlTraversal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[17]);
}

// ===================================================================

class Locus::_Internal {
 public:
  static const ::vg::Support& overall_support(const Locus* msg);
};

const ::vg::Support&
Locus::_Internal::overall_support(const Locus* msg) {
  return *msg->_impl_.overall_support_;
}
Locus::Locus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Locus)
}
Locus::Locus(const Locus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Locus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.allele_){from._impl_.allele_}
    , decltype(_impl_.support_){from._impl_.support_}
    , decltype(_impl_.genotype_){from._impl_.genotype_}
    , decltype(_impl_.allele_log_likelihood_){from._impl_.allele_log_likelihood_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.overall_support_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_overall_support()) {
    _this->_impl_.overall_support_ = new ::vg::Support(*from._impl_.overall_support_);
  }
  // @@protoc_insertion_point(copy_constructor:vg.Locus)
}

inline void Locus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.allele_){arena}
    , decltype(_impl_.support_){arena}
    , decltype(_impl_.genotype_){arena}
    , decltype(_impl_.allele_log_likelihood_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.overall_support_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Locus::~Locus() {
  // @@protoc_insertion_point(destructor:vg.Locus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Locus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allele_.~RepeatedPtrField();
  _impl_.support_.~RepeatedPtrField();
  _impl_.genotype_.~RepeatedPtrField();
  _impl_.allele_log_likelihood_.~RepeatedField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.overall_support_;
}

void Locus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Locus::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Locus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allele_.Clear();
  _impl_.support_.Clear();
  _impl_.genotype_.Clear();
  _impl_.allele_log_likelihood_.Clear();
  _impl_.name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.overall_support_ != nullptr) {
    delete _impl_.overall_support_;
  }
  _impl_.overall_support_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Locus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "vg.Locus.name"));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Path allele = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_allele(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Support support = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_support(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .vg.Genotype genotype = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_genotype(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .vg.Support overall_support = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_overall_support(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated double allele_log_likelihood = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_allele_log_likelihood(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 49) {
          _internal_add_allele_log_likelihood(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Locus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Locus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "vg.Locus.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated .vg.Path allele = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_allele_size()); i < n; i++) {
    const auto& repfield = this->_internal_allele(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vg.Support support = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_support_size()); i < n; i++) {
    const auto& repfield = this->_internal_support(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .vg.Genotype genotype = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_genotype_size()); i < n; i++) {
    const auto& repfield = this->_internal_genotype(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .vg.Support overall_support = 5;
  if (this->_internal_has_overall_support()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::overall_support(this),
        _Internal::overall_support(this).GetCachedSize(), target, stream);
  }

  // repeated double allele_log_likelihood = 6;
  if (this->_internal_allele_log_likelihood_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_allele_log_likelihood(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Locus)
  return target;
}

size_t Locus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Locus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .vg.Path allele = 2;
  total_size += 1UL * this->_internal_allele_size();
  for (const auto& msg : this->_impl_.allele_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vg.Support support = 3;
  total_size += 1UL * this->_internal_support_size();
  for (const auto& msg : this->_impl_.support_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .vg.Genotype genotype = 4;
  total_size += 1UL * this->_internal_genotype_size();
  for (const auto& msg : this->_impl_.genotype_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated double allele_log_likelihood = 6;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_allele_log_likelihood_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .vg.Support overall_support = 5;
  if (this->_internal_has_overall_support()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.overall_support_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Locus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Locus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Locus::GetClassData() const { return &_class_data_; }


void Locus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Locus*>(&to_msg);
  auto& from = static_cast<const Locus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Locus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allele_.MergeFrom(from._impl_.allele_);
  _this->_impl_.support_.MergeFrom(from._impl_.support_);
  _this->_impl_.genotype_.MergeFrom(from._impl_.genotype_);
  _this->_impl_.allele_log_likelihood_.MergeFrom(from._impl_.allele_log_likelihood_);
  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (from._internal_has_overall_support()) {
    _this->_internal_mutable_overall_support()->::vg::Support::MergeFrom(
        from._internal_overall_support());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Locus::CopyFrom(const Locus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Locus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Locus::IsInitialized() const {
  return true;
}

void Locus::InternalSwap(Locus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.allele_.InternalSwap(&other->_impl_.allele_);
  _impl_.support_.InternalSwap(&other->_impl_.support_);
  _impl_.genotype_.InternalSwap(&other->_impl_.genotype_);
  _impl_.allele_log_likelihood_.InternalSwap(&other->_impl_.allele_log_likelihood_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.overall_support_, other->_impl_.overall_support_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Locus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[18]);
}

// ===================================================================

class Genotype::_Internal {
 public:
};

Genotype::Genotype(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Genotype)
}
Genotype::Genotype(const Genotype& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Genotype* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.allele_){from._impl_.allele_}
    , /*decltype(_impl_._allele_cached_byte_size_)*/{0}
    , decltype(_impl_.likelihood_){}
    , decltype(_impl_.log_likelihood_){}
    , decltype(_impl_.log_prior_){}
    , decltype(_impl_.log_posterior_){}
    , decltype(_impl_.is_phased_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.likelihood_, &from._impl_.likelihood_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_phased_) -
    reinterpret_cast<char*>(&_impl_.likelihood_)) + sizeof(_impl_.is_phased_));
  // @@protoc_insertion_point(copy_constructor:vg.Genotype)
}

inline void Genotype::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.allele_){arena}
    , /*decltype(_impl_._allele_cached_byte_size_)*/{0}
    , decltype(_impl_.likelihood_){0}
    , decltype(_impl_.log_likelihood_){0}
    , decltype(_impl_.log_prior_){0}
    , decltype(_impl_.log_posterior_){0}
    , decltype(_impl_.is_phased_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Genotype::~Genotype() {
  // @@protoc_insertion_point(destructor:vg.Genotype)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Genotype::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.allele_.~RepeatedField();
}

void Genotype::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Genotype::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Genotype)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.allele_.Clear();
  ::memset(&_impl_.likelihood_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_phased_) -
      reinterpret_cast<char*>(&_impl_.likelihood_)) + sizeof(_impl_.is_phased_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Genotype::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 allele = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_allele(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_allele(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool is_phased = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.is_phased_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double likelihood = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.likelihood_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double log_likelihood = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.log_likelihood_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double log_prior = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.log_prior_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double log_posterior = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.log_posterior_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Genotype::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Genotype)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 allele = 1;
  {
    int byte_size = _impl_._allele_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          1, _internal_allele(), byte_size, target);
    }
  }

  // bool is_phased = 2;
  if (this->_internal_is_phased() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_phased(), target);
  }

  // double likelihood = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = this->_internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_likelihood(), target);
  }

  // double log_likelihood = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_likelihood = this->_internal_log_likelihood();
  uint64_t raw_log_likelihood;
  memcpy(&raw_log_likelihood, &tmp_log_likelihood, sizeof(tmp_log_likelihood));
  if (raw_log_likelihood != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_log_likelihood(), target);
  }

  // double log_prior = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_prior = this->_internal_log_prior();
  uint64_t raw_log_prior;
  memcpy(&raw_log_prior, &tmp_log_prior, sizeof(tmp_log_prior));
  if (raw_log_prior != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_log_prior(), target);
  }

  // double log_posterior = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_posterior = this->_internal_log_posterior();
  uint64_t raw_log_posterior;
  memcpy(&raw_log_posterior, &tmp_log_posterior, sizeof(tmp_log_posterior));
  if (raw_log_posterior != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(6, this->_internal_log_posterior(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Genotype)
  return target;
}

size_t Genotype::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Genotype)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 allele = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.allele_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._allele_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // double likelihood = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = this->_internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    total_size += 1 + 8;
  }

  // double log_likelihood = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_likelihood = this->_internal_log_likelihood();
  uint64_t raw_log_likelihood;
  memcpy(&raw_log_likelihood, &tmp_log_likelihood, sizeof(tmp_log_likelihood));
  if (raw_log_likelihood != 0) {
    total_size += 1 + 8;
  }

  // double log_prior = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_prior = this->_internal_log_prior();
  uint64_t raw_log_prior;
  memcpy(&raw_log_prior, &tmp_log_prior, sizeof(tmp_log_prior));
  if (raw_log_prior != 0) {
    total_size += 1 + 8;
  }

  // double log_posterior = 6;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_posterior = this->_internal_log_posterior();
  uint64_t raw_log_posterior;
  memcpy(&raw_log_posterior, &tmp_log_posterior, sizeof(tmp_log_posterior));
  if (raw_log_posterior != 0) {
    total_size += 1 + 8;
  }

  // bool is_phased = 2;
  if (this->_internal_is_phased() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Genotype::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Genotype::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Genotype::GetClassData() const { return &_class_data_; }


void Genotype::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Genotype*>(&to_msg);
  auto& from = static_cast<const Genotype&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Genotype)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.allele_.MergeFrom(from._impl_.allele_);
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_likelihood = from._internal_likelihood();
  uint64_t raw_likelihood;
  memcpy(&raw_likelihood, &tmp_likelihood, sizeof(tmp_likelihood));
  if (raw_likelihood != 0) {
    _this->_internal_set_likelihood(from._internal_likelihood());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_likelihood = from._internal_log_likelihood();
  uint64_t raw_log_likelihood;
  memcpy(&raw_log_likelihood, &tmp_log_likelihood, sizeof(tmp_log_likelihood));
  if (raw_log_likelihood != 0) {
    _this->_internal_set_log_likelihood(from._internal_log_likelihood());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_prior = from._internal_log_prior();
  uint64_t raw_log_prior;
  memcpy(&raw_log_prior, &tmp_log_prior, sizeof(tmp_log_prior));
  if (raw_log_prior != 0) {
    _this->_internal_set_log_prior(from._internal_log_prior());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_log_posterior = from._internal_log_posterior();
  uint64_t raw_log_posterior;
  memcpy(&raw_log_posterior, &tmp_log_posterior, sizeof(tmp_log_posterior));
  if (raw_log_posterior != 0) {
    _this->_internal_set_log_posterior(from._internal_log_posterior());
  }
  if (from._internal_is_phased() != 0) {
    _this->_internal_set_is_phased(from._internal_is_phased());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Genotype::CopyFrom(const Genotype& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Genotype)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Genotype::IsInitialized() const {
  return true;
}

void Genotype::InternalSwap(Genotype* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.allele_.InternalSwap(&other->_impl_.allele_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Genotype, _impl_.is_phased_)
      + sizeof(Genotype::_impl_.is_phased_)
      - PROTOBUF_FIELD_OFFSET(Genotype, _impl_.likelihood_)>(
          reinterpret_cast<char*>(&_impl_.likelihood_),
          reinterpret_cast<char*>(&other->_impl_.likelihood_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Genotype::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[19]);
}

// ===================================================================

class Support::_Internal {
 public:
};

Support::Support(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Support)
}
Support::Support(const Support& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Support* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.quality_){}
    , decltype(_impl_.forward_){}
    , decltype(_impl_.reverse_){}
    , decltype(_impl_.left_){}
    , decltype(_impl_.right_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.quality_, &from._impl_.quality_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_) -
    reinterpret_cast<char*>(&_impl_.quality_)) + sizeof(_impl_.right_));
  // @@protoc_insertion_point(copy_constructor:vg.Support)
}

inline void Support::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.quality_){0}
    , decltype(_impl_.forward_){0}
    , decltype(_impl_.reverse_){0}
    , decltype(_impl_.left_){0}
    , decltype(_impl_.right_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Support::~Support() {
  // @@protoc_insertion_point(destructor:vg.Support)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Support::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Support::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Support::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Support)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.quality_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.right_) -
      reinterpret_cast<char*>(&_impl_.quality_)) + sizeof(_impl_.right_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Support::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // double quality = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.quality_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double forward = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.forward_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double reverse = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.reverse_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double left = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double right = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Support::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Support)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // double quality = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_quality = this->_internal_quality();
  uint64_t raw_quality;
  memcpy(&raw_quality, &tmp_quality, sizeof(tmp_quality));
  if (raw_quality != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_quality(), target);
  }

  // double forward = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_forward = this->_internal_forward();
  uint64_t raw_forward;
  memcpy(&raw_forward, &tmp_forward, sizeof(tmp_forward));
  if (raw_forward != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_forward(), target);
  }

  // double reverse = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reverse = this->_internal_reverse();
  uint64_t raw_reverse;
  memcpy(&raw_reverse, &tmp_reverse, sizeof(tmp_reverse));
  if (raw_reverse != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_reverse(), target);
  }

  // double left = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left = this->_internal_left();
  uint64_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(4, this->_internal_left(), target);
  }

  // double right = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right = this->_internal_right();
  uint64_t raw_right;
  memcpy(&raw_right, &tmp_right, sizeof(tmp_right));
  if (raw_right != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_right(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Support)
  return target;
}

size_t Support::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Support)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double quality = 1;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_quality = this->_internal_quality();
  uint64_t raw_quality;
  memcpy(&raw_quality, &tmp_quality, sizeof(tmp_quality));
  if (raw_quality != 0) {
    total_size += 1 + 8;
  }

  // double forward = 2;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_forward = this->_internal_forward();
  uint64_t raw_forward;
  memcpy(&raw_forward, &tmp_forward, sizeof(tmp_forward));
  if (raw_forward != 0) {
    total_size += 1 + 8;
  }

  // double reverse = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reverse = this->_internal_reverse();
  uint64_t raw_reverse;
  memcpy(&raw_reverse, &tmp_reverse, sizeof(tmp_reverse));
  if (raw_reverse != 0) {
    total_size += 1 + 8;
  }

  // double left = 4;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left = this->_internal_left();
  uint64_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    total_size += 1 + 8;
  }

  // double right = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right = this->_internal_right();
  uint64_t raw_right;
  memcpy(&raw_right, &tmp_right, sizeof(tmp_right));
  if (raw_right != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Support::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Support::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Support::GetClassData() const { return &_class_data_; }


void Support::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Support*>(&to_msg);
  auto& from = static_cast<const Support&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Support)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_quality = from._internal_quality();
  uint64_t raw_quality;
  memcpy(&raw_quality, &tmp_quality, sizeof(tmp_quality));
  if (raw_quality != 0) {
    _this->_internal_set_quality(from._internal_quality());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_forward = from._internal_forward();
  uint64_t raw_forward;
  memcpy(&raw_forward, &tmp_forward, sizeof(tmp_forward));
  if (raw_forward != 0) {
    _this->_internal_set_forward(from._internal_forward());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_reverse = from._internal_reverse();
  uint64_t raw_reverse;
  memcpy(&raw_reverse, &tmp_reverse, sizeof(tmp_reverse));
  if (raw_reverse != 0) {
    _this->_internal_set_reverse(from._internal_reverse());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_left = from._internal_left();
  uint64_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    _this->_internal_set_left(from._internal_left());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_right = from._internal_right();
  uint64_t raw_right;
  memcpy(&raw_right, &tmp_right, sizeof(tmp_right));
  if (raw_right != 0) {
    _this->_internal_set_right(from._internal_right());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Support::CopyFrom(const Support& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Support)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Support::IsInitialized() const {
  return true;
}

void Support::InternalSwap(Support* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Support, _impl_.right_)
      + sizeof(Support::_impl_.right_)
      - PROTOBUF_FIELD_OFFSET(Support, _impl_.quality_)>(
          reinterpret_cast<char*>(&_impl_.quality_),
          reinterpret_cast<char*>(&other->_impl_.quality_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Support::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[20]);
}

// ===================================================================

class LocationSupport::_Internal {
 public:
  static const ::vg::Support& support(const LocationSupport* msg);
  static const ::vg::Edge& edge(const LocationSupport* msg);
};

const ::vg::Support&
LocationSupport::_Internal::support(const LocationSupport* msg) {
  return *msg->_impl_.support_;
}
const ::vg::Edge&
LocationSupport::_Internal::edge(const LocationSupport* msg) {
  return *msg->_impl_.oneof_location_.edge_;
}
void LocationSupport::set_allocated_edge(::vg::Edge* edge) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_oneof_location();
  if (edge) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edge);
    if (message_arena != submessage_arena) {
      edge = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edge, submessage_arena);
    }
    set_has_edge();
    _impl_.oneof_location_.edge_ = edge;
  }
  // @@protoc_insertion_point(field_set_allocated:vg.LocationSupport.edge)
}
LocationSupport::LocationSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.LocationSupport)
}
LocationSupport::LocationSupport(const LocationSupport& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LocationSupport* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.support_){nullptr}
    , decltype(_impl_.oneof_location_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_support()) {
    _this->_impl_.support_ = new ::vg::Support(*from._impl_.support_);
  }
  clear_has_oneof_location();
  switch (from.oneof_location_case()) {
    case kEdge: {
      _this->_internal_mutable_edge()->::vg::Edge::MergeFrom(
          from._internal_edge());
      break;
    }
    case kNodeId: {
      _this->_internal_set_node_id(from._internal_node_id());
      break;
    }
    case ONEOF_LOCATION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:vg.LocationSupport)
}

inline void LocationSupport::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.support_){nullptr}
    , decltype(_impl_.oneof_location_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_oneof_location();
}

LocationSupport::~LocationSupport() {
  // @@protoc_insertion_point(destructor:vg.LocationSupport)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LocationSupport::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.support_;
  if (has_oneof_location()) {
    clear_oneof_location();
  }
}

void LocationSupport::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LocationSupport::clear_oneof_location() {
// @@protoc_insertion_point(one_of_clear_start:vg.LocationSupport)
  switch (oneof_location_case()) {
    case kEdge: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.oneof_location_.edge_;
      }
      break;
    }
    case kNodeId: {
      // No need to clear
      break;
    }
    case ONEOF_LOCATION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ONEOF_LOCATION_NOT_SET;
}


void LocationSupport::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.LocationSupport)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.support_ != nullptr) {
    delete _impl_.support_;
  }
  _impl_.support_ = nullptr;
  clear_oneof_location();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LocationSupport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vg.Support support = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_support(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vg.Edge edge = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_edge(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 node_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_node_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LocationSupport::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.LocationSupport)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vg.Support support = 1;
  if (this->_internal_has_support()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::support(this),
        _Internal::support(this).GetCachedSize(), target, stream);
  }

  // .vg.Edge edge = 2;
  if (_internal_has_edge()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::edge(this),
        _Internal::edge(this).GetCachedSize(), target, stream);
  }

  // int64 node_id = 3;
  if (_internal_has_node_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.LocationSupport)
  return target;
}

size_t LocationSupport::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.LocationSupport)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vg.Support support = 1;
  if (this->_internal_has_support()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.support_);
  }

  switch (oneof_location_case()) {
    // .vg.Edge edge = 2;
    case kEdge: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.oneof_location_.edge_);
      break;
    }
    // int64 node_id = 3;
    case kNodeId: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_node_id());
      break;
    }
    case ONEOF_LOCATION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LocationSupport::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LocationSupport::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LocationSupport::GetClassData() const { return &_class_data_; }


void LocationSupport::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LocationSupport*>(&to_msg);
  auto& from = static_cast<const LocationSupport&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.LocationSupport)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_support()) {
    _this->_internal_mutable_support()->::vg::Support::MergeFrom(
        from._internal_support());
  }
  switch (from.oneof_location_case()) {
    case kEdge: {
      _this->_internal_mutable_edge()->::vg::Edge::MergeFrom(
          from._internal_edge());
      break;
    }
    case kNodeId: {
      _this->_internal_set_node_id(from._internal_node_id());
      break;
    }
    case ONEOF_LOCATION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LocationSupport::CopyFrom(const LocationSupport& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.LocationSupport)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocationSupport::IsInitialized() const {
  return true;
}

void LocationSupport::InternalSwap(LocationSupport* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.support_, other->_impl_.support_);
  swap(_impl_.oneof_location_, other->_impl_.oneof_location_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata LocationSupport::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[21]);
}

// ===================================================================

class Translation::_Internal {
 public:
  static const ::vg::Path& from(const Translation* msg);
  static const ::vg::Path& to(const Translation* msg);
};

const ::vg::Path&
Translation::_Internal::from(const Translation* msg) {
  return *msg->_impl_.from_;
}
const ::vg::Path&
Translation::_Internal::to(const Translation* msg) {
  return *msg->_impl_.to_;
}
Translation::Translation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:vg.Translation)
}
Translation::Translation(const Translation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Translation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){nullptr}
    , decltype(_impl_.to_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_from()) {
    _this->_impl_.from_ = new ::vg::Path(*from._impl_.from_);
  }
  if (from._internal_has_to()) {
    _this->_impl_.to_ = new ::vg::Path(*from._impl_.to_);
  }
  // @@protoc_insertion_point(copy_constructor:vg.Translation)
}

inline void Translation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_){nullptr}
    , decltype(_impl_.to_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Translation::~Translation() {
  // @@protoc_insertion_point(destructor:vg.Translation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Translation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.from_;
  if (this != internal_default_instance()) delete _impl_.to_;
}

void Translation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Translation::Clear() {
// @@protoc_insertion_point(message_clear_start:vg.Translation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.to_ != nullptr) {
    delete _impl_.to_;
  }
  _impl_.to_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Translation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .vg.Path from = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_from(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .vg.Path to = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_to(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Translation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:vg.Translation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .vg.Path from = 1;
  if (this->_internal_has_from()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::from(this),
        _Internal::from(this).GetCachedSize(), target, stream);
  }

  // .vg.Path to = 2;
  if (this->_internal_has_to()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::to(this),
        _Internal::to(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:vg.Translation)
  return target;
}

size_t Translation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:vg.Translation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .vg.Path from = 1;
  if (this->_internal_has_from()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.from_);
  }

  // .vg.Path to = 2;
  if (this->_internal_has_to()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.to_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Translation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Translation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Translation::GetClassData() const { return &_class_data_; }


void Translation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Translation*>(&to_msg);
  auto& from = static_cast<const Translation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:vg.Translation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_from()) {
    _this->_internal_mutable_from()->::vg::Path::MergeFrom(
        from._internal_from());
  }
  if (from._internal_has_to()) {
    _this->_internal_mutable_to()->::vg::Path::MergeFrom(
        from._internal_to());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Translation::CopyFrom(const Translation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vg.Translation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Translation::IsInitialized() const {
  return true;
}

void Translation::InternalSwap(Translation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Translation, _impl_.to_)
      + sizeof(Translation::_impl_.to_)
      - PROTOBUF_FIELD_OFFSET(Translation, _impl_.from_)>(
          reinterpret_cast<char*>(&_impl_.from_),
          reinterpret_cast<char*>(&other->_impl_.from_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Translation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_vg_2eproto_getter, &descriptor_table_vg_2eproto_once,
      file_level_metadata_vg_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace vg
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::vg::Graph*
Arena::CreateMaybeMessage< ::vg::Graph >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Graph >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Node*
Arena::CreateMaybeMessage< ::vg::Node >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Node >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Edge*
Arena::CreateMaybeMessage< ::vg::Edge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Edge >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Edit*
Arena::CreateMaybeMessage< ::vg::Edit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Edit >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Mapping*
Arena::CreateMaybeMessage< ::vg::Mapping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Mapping >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Position*
Arena::CreateMaybeMessage< ::vg::Position >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Position >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Path*
Arena::CreateMaybeMessage< ::vg::Path >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Path >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Alignment*
Arena::CreateMaybeMessage< ::vg::Alignment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Alignment >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::MultipathAlignment*
Arena::CreateMaybeMessage< ::vg::MultipathAlignment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::MultipathAlignment >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Subpath*
Arena::CreateMaybeMessage< ::vg::Subpath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Subpath >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::KmerMatch*
Arena::CreateMaybeMessage< ::vg::KmerMatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::KmerMatch >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::BasePileup*
Arena::CreateMaybeMessage< ::vg::BasePileup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::BasePileup >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::NodePileup*
Arena::CreateMaybeMessage< ::vg::NodePileup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::NodePileup >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::EdgePileup*
Arena::CreateMaybeMessage< ::vg::EdgePileup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::EdgePileup >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Pileup*
Arena::CreateMaybeMessage< ::vg::Pileup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Pileup >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Snarl*
Arena::CreateMaybeMessage< ::vg::Snarl >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Snarl >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Visit*
Arena::CreateMaybeMessage< ::vg::Visit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Visit >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::SnarlTraversal*
Arena::CreateMaybeMessage< ::vg::SnarlTraversal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::SnarlTraversal >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Locus*
Arena::CreateMaybeMessage< ::vg::Locus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Locus >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Genotype*
Arena::CreateMaybeMessage< ::vg::Genotype >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Genotype >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Support*
Arena::CreateMaybeMessage< ::vg::Support >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Support >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::LocationSupport*
Arena::CreateMaybeMessage< ::vg::LocationSupport >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::LocationSupport >(arena);
}
template<> PROTOBUF_NOINLINE ::vg::Translation*
Arena::CreateMaybeMessage< ::vg::Translation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::vg::Translation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
